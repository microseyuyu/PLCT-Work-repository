# tick-processor

tools/test.py test/tick-processor

```
[root@openEuler-riscv64 node-v16.14.2]# tools/test.py test/tick-processor
=== release test-tick-processor-builtin ===                   
Path: tick-processor/test-tick-processor-builtin
(node:2016) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
(node:2025) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
(node:2025) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.0/tick-processor.log is broken
"tick,0x3fbd6d6e9c,2343760,0," at the file end is broken
(node:2082) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2082) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.0/tick-processor.log is broken
"script-source,11,node:internal/errors,/* eslint node-core/documented-errors: \"error\" */\\n/* eslint node-core/alphabetize-errors: \"error\" */\\n/* eslint node-core/prefer-util-format-errors: \"error\" */\\n\\n'use strict';\\n\\n// The whole point behind this internal module is to allow Node.js to no\\n// longer be forced to treat every error message change as a semver-major\\n// change. The NodeError classes here all expose a `code` property whose\\n// value statically and permanently identifies the error. While the error\\n// message may change\\x2C the code should not.\\n\\nconst {\\n  AggregateError\\x2C\\n  ArrayFrom\\x2C\\n  ArrayIsArray\\x2C\\n  ArrayPrototypeFilter\\x2C\\n  ArrayPrototypeIncludes\\x2C\\n  ArrayPrototypeIndexOf\\x2C\\n  ArrayPrototypeJoin\\x2C\\n  ArrayPrototypeMap\\x2C\\n  ArrayPrototypePop\\x2C\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypeSlice\\x2C\\n  ArrayPrototypeSplice\\x2C\\n  ArrayPrototypeUnshift\\x2C\\n  Error\\x2C\\n  ErrorCaptureStackTrace\\x2C\\n  ErrorPrototypeToString\\x2C\\n  JSONStringify\\x2C\\n  MapPrototypeGet\\x2C\\n  MathAbs\\x2C\\n  MathMax\\x2C\\n  Number\\x2C\\n  NumberIsInteger\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectDefineProperties\\x2C\\n  ObjectIsExtensible\\x2C\\n  ObjectGetOwnPropertyDescriptor\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  RangeError\\x2C\\n  ReflectApply\\x2C\\n  RegExpPrototypeTest\\x2C\\n  SafeArrayIterator\\x2C\\n  SafeMap\\x2C\\n  SafeWeakMap\\x2C\\n  String\\x2C\\n  StringPrototypeEndsWith\\x2C\\n  StringPrototypeIncludes\\x2C\\n  StringPrototypeMatch\\x2C\\n  StringPrototypeSlice\\x2C\\n  StringPrototypeSplit\\x2C\\n  StringPrototypeStartsWith\\x2C\\n  StringPrototypeToLowerCase\\x2C\\n  Symbol\\x2C\\n  SymbolFor\\x2C\\n  SyntaxError\\x2C\\n  TypeError\\x2C\\n  URIError\\x2C\\n} = primordials;\\n\\nconst kIsNodeError = Symbol('kIsNodeError');\\n\\nconst isWindows = process.platform === 'win32';\\n\\nconst messages = new SafeMap();\\nconst codes = {};\\n\\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\\n// Sorted by a rough estimate on most frequently used entries.\\nconst kTypes = [\\n  'string'\\x2C\\n  'function'\\x2C\\n  'number'\\x2C\\n  'object'\\x2C\\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\\n  'Function'\\x2C\\n  'Object'\\x2C\\n  'boolean'\\x2C\\n  'bigint'\\x2C\\n  'symbol'\\x2C\\n];\\n\\nconst MainContextError = Error;\\nconst overrideStackTrace = new SafeWeakMap();\\nconst kNoOverride = Symbol('kNoOverride');\\nlet userStackTraceLimit;\\nconst nodeInternalPrefix = '__node_internal_';\\nconst prepareStackTrace = (globalThis\\x2C error\\x2C trace) => {\\n  // API for node internals to override error stack formatting\\n  // without interfering with userland code.\\n  if (overrideStackTrace.has(error)) {\\n    const f = overrideStackTrace.get(error);\\n    overrideStackTrace.delete(error);\\n    return f(error\\x2C trace);\\n  }\\n\\n  const firstFrame = trace[0]?.getFunctionName();\\n  if (firstFrame && StringPrototypeStartsWith(firstFrame\\x2C nodeInternalPrefix)) {\\n    for (let l = trace.length - 1; l >= 0; l--) {\\n      const fn = trace[l]?.getFunctionName();\\n      if (fn && StringPrototypeStartsWith(fn\\x2C nodeInternalPrefix)) {\\n        ArrayPrototypeSplice(trace\\x2C 0\\x2C l + 1);\\n        break;\\n      }\\n    }\\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`\\x2C\\n    // it is updated at every new exception in `captureLargerStackTrace`.\\n    if (trace.length > userStackTraceLimit)\\n      ArrayPrototypeSplice(trace\\x2C userStackTraceLimit);\\n  }\\n\\n  const globalOverride =\\n    maybeOverridePrepareStackTrace(globalThis\\x2C error\\x2C trace);\\n  if (globalOverride !== kNoOverride) return globalOverride;\\n\\n  // Normal error formatting:\\n  //\\n  // Error: Message\\n  //     at function (file)\\n  //     at file\\n  let errorString;\\n  if (kIsNodeError in error) {\\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\\n  } else {\\n    errorString = ErrorPrototypeToString(error);\\n  }\\n  if (trace.length === 0) {\\n    return errorString;\\n  }\\n  return `${errorString}\\\\n    at ${ArrayPrototypeJoin(trace\\x2C '\\\\n    at ')}`;\\n};\\n\\nconst maybeOverridePrepareStackTrace = (globalThis\\x2C error\\x2C trace) => {\\n  // Polyfill of V8's Error.prepareStackTrace API.\\n  // https://crbug.com/v8/7848\\n  // `globalThis` is the global that contains the constructor which\\n  // created `error`.\\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\\n    return globalThis.Error.prepareStackTrace(error\\x2C trace);\\n  }\\n  // We still have legacy usage that depends on the main context's `Error`\\n  // being used\\x2C even when the error is from a different context.\\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\\n  if (typeof MainContextError.prepareStackTrace === 'function') {\\n    return MainContextError.prepareStackTrace(error\\x2C trace);\\n  }\\n\\n  return kNoOverride;\\n};\\n\\nconst aggregateTwoErrors = hideStackFrames((innerError\\x2C outerError) => {\\n  if (innerError && outerError) {\\n    if (ArrayIsArray(outerError.errors)) {\\n      // If `outerError` is already an `AggregateError`.\\n      ArrayPrototypePush(outerError.errors\\x2C innerError);\\n      return outerError;\\n    }\\n    // eslint-disable-next-line no-restricted-syntax\\n    const err = new AggregateError(new SafeArrayIterator([\\n      outerError\\x2C\\n      innerError\\x2C\\n    ])\\x2C outerError.message);\\n    err.code = outerError.code;\\n    return err;\\n  }\\n  return innerError || outerError;\\n});\\n\\n// Lazily loaded\\nlet util;\\nlet assert;\\n\\nlet internalUtil = null;\\nfunction lazyInternalUtil() {\\n  if (!internalUtil) {\\n    internalUtil = require('internal/util');\\n  }\\n  return internalUtil;\\n}\\n\\nlet internalUtilInspect = null;\\nfunction lazyInternalUtilInspect() {\\n  if (!internalUtilInspect) {\\n    internalUtilInspect = require('internal/util/inspect');\\n  }\\n  return internalUtilInspect;\\n}\\n\\nlet buffer;\\nfunction lazyBuffer() {\\n  if (buffer === undefined)\\n    buffer = require('buffer').Buffer;\\n  return buffer;\\n}\\n\\nfunction isErrorStackTraceLimitWritable() {\\n  const desc = ObjectGetOwnPropertyDescriptor(Error\\x2C 'stackTraceLimit');\\n  if (desc === undefined) {\\n    return ObjectIsExtensible(Error);\\n  }\\n\\n  return ObjectPrototypeHasOwnProperty(desc\\x2C 'writable') ?\\n    desc.writable :\\n    desc.set !== undefined;\\n}\\n\\n// A specialized Error that includes an additional info property with\\n// additional information about the error condition.\\n// It has the properties present in a UVException but with a custom error\\n// message followed by the uv error code and uv error message.\\n// It also has its own error code with the original uv error context put into\\n// `err.info`.\\n// The context passed into this error must have .code\\x2C .syscall and .message\\x2C\\n// and may have .path and .dest.\\nclass SystemError extends Error {\\n  constructor(key\\x2C context) {\\n    const limit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    super();\\n    // Reset the limit and setting the name property.\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\\n    const prefix = getMessage(key\\x2C []\\x2C this);\\n    let message = `${prefix}: ${context.syscall} returned ` +\\n                  `${context.code} (${context.message})`;\\n\\n    if (context.path !== undefined)\\n      message += ` ${context.path}`;\\n    if (context.dest !== undefined)\\n      message += ` => ${context.dest}`;\\n\\n    captureLargerStackTrace(this);\\n\\n    this.code = key;\\n\\n    ObjectDefineProperties(this\\x2C {\\n      [kIsNodeError]: {\\n        value: true\\x2C\\n        enumerable: false\\x2C\\n        writable: false\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      name: {\\n        value: 'SystemError'\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      message: {\\n        value: message\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      info: {\\n        value: context\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n        writable: false\\x2C\\n      }\\x2C\\n      errno: {\\n        get() {\\n          return context.errno;\\n        }\\x2C\\n        set: (value) => {\\n          context.errno = value;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      syscall: {\\n        get() {\\n          return context.syscall;\\n        }\\x2C\\n        set: (value) => {\\n          context.syscall = value;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n    });\\n\\n    if (context.path !== undefined) {\\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\\n      // introduced. The `path` and `dest` properties in the context seem to\\n      // always be of type string. We should probably just remove the\\n      // `.toString()` and `Buffer.from()` operations and set the value on the\\n      // context as the user did.\\n      ObjectDefineProperty(this\\x2C 'path'\\x2C {\\n        get() {\\n          return context.path != null ?\\n            context.path.toString() : context.path;\\n        }\\x2C\\n        set: (value) => {\\n          context.path = value ?\\n            lazyBuffer().from(value.toString()) : undefined;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\n      });\\n    }\\n\\n    if (context.dest !== undefined) {\\n      ObjectDefineProperty(this\\x2C 'dest'\\x2C {\\n        get() {\\n          return context.dest != null ?\\n            context.dest.toString() : context.dest;\\n        }\\x2C\\n        set: (value) => {\\n          context.dest = value ?\\n            lazyBuffer().from(value.toString()) : undefined;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\n      });\\n    }\\n  }\\n\\n  toString() {\\n    return `${this.name} [${this.code}]: ${this.message}`;\\n  }\\n\\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes\\x2C ctx) {\\n    return lazyInternalUtilInspect().inspect(this\\x2C {\\n      ...ctx\\x2C\\n      getters: true\\x2C\\n      customInspect: false\\n    });\\n  }\\n}\\n\\nfunction makeSystemErrorWithCode(key) {\\n  return class NodeError extends SystemError {\\n    constructor(ctx) {\\n      super(key\\x2C ctx);\\n    }\\n  };\\n}\\n\\nfunction makeNodeErrorWithCode(Base\\x2C key) {\\n  return function NodeError(...args) {\\n    const limit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    const error = new Base();\\n    // Reset the limit and setting the name property.\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\\n    const message = getMessage(key\\x2C args\\x2C error);\\n    ObjectDefineProperties(error\\x2C {\\n      [kIsNodeError]: {\\n        value: true\\x2C\\n        enumerable: false\\x2C\\n        writable: false\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      message: {\\n        value: message\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      toString: {\\n        value() {\\n          return `${this.name} [${key}]: ${this.message}`;\\n        }\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n    });\\n    captureLargerStackTrace(error);\\n    error.code = key;\\n    return error;\\n  };\\n}\\n\\n/**\\n * This function removes unnecessary frames from Node.js core errors.\\n * @template {(...args: any[]) => any} T\\n * @type {(fn: T) => T}\\n */\\nfunction hideStackFrames(fn) {\\n  // We rename the functions that will be hidden to cut off the stacktrace\\n  // at the outermost one\\n  const hidden = nodeInternalPrefix + fn.name;\\n  ObjectDefineProperty(fn\\x2C 'name'\\x2C { value: hidden });\\n  return fn;\\n}\\n\\n// Utility function for registering the error codes. Only used here. Exported\\n// *only* to allow for testing.\\nfunction E(sym\\x2C val\\x2C def\\x2C ...otherClasses) {\\n  // Special case for SystemError that formats the error message differently\\n  // The SystemErrors only have SystemError as their base classes.\\n  messages.set(sym\\x2C val);\\n  if (def === SystemError) {\\n    def = makeSystemErrorWithCode(sym);\\n  } else {\\n    def = makeNodeErrorWithCode(def\\x2C sym);\\n  }\\n\\n  if (otherClasses.length !== 0) {\\n    otherClasses.forEach((clazz) => {\\n      def[clazz.name] = makeNodeErrorWithCode(clazz\\x2C sym);\\n    });\\n  }\\n  codes[sym] = def;\\n}\\n\\nfunction getMessage(key\\x2C args\\x2C self) {\\n  const msg = messages.get(key);\\n\\n  if (assert === undefined) assert = require('internal/assert');\\n\\n  if (typeof msg === 'function') {\\n    assert(\\n      msg.length <= args.length\\x2C // Default options do not count.\\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\\n        `match the required ones (${msg.length}).`\\n    );\\n    return ReflectApply(msg\\x2C self\\x2C args);\\n  }\\n\\n  const expectedLength =\\n    (StringPrototypeMatch(msg\\x2C /%[dfijoOs]/g) || []).length;\\n  assert(\\n    expectedLength === args.length\\x2C\\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\\n      `match the required ones (${expectedLength}).`\\n  );\\n  if (args.length === 0)\\n    return msg;\\n\\n  ArrayPrototypeUnshift(args\\x2C msg);\\n  return ReflectApply(lazyInternalUtilInspect().format\\x2C null\\x2C args);\\n}\\n\\nlet uvBinding;\\n\\nfunction lazyUv() {\\n  if (!uvBinding) {\\n    uvBinding = internalBinding('uv');\\n  }\\n  return uvBinding;\\n}\\n\\nconst uvUnmappedError = ['UNKNOWN'\\x2C 'unknown error'];\\n\\nfunction uvErrmapGet(name) {\\n  uvBinding = lazyUv();\\n  if (!uvBinding.errmap) {\\n    uvBinding.errmap = uvBinding.getErrorMap();\\n  }\\n  return MapPrototypeGet(uvBinding.errmap\\x2C name);\\n}\\n\\nconst captureLargerStackTrace = hideStackFrames(\\n  function captureLargerStackTrace(err) {\\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\\n    if (stackTraceLimitIsWritable) {\\n      userStackTraceLimit = Error.stackTraceLimit;\\n      Error.stackTraceLimit = Infinity;\\n    }\\n    ErrorCaptureStackTrace(err);\\n    // Reset the limit\\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\\n\\n    return err;\\n  });\\n\\n/**\\n * This creates an error compatible with errors produced in the C++\\n * function UVException using a context object with data assembled in C++.\\n * The goal is to migrate them to ERR_* errors later when compatibility is\\n * not a concern.\\n *\\n * @param {object} ctx\\n * @returns {Error}\\n */\\nconst uvException = hideStackFrames(function uvException(ctx) {\\n  const { 0: code\\x2C 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\\n  let message = `${code}: ${ctx.message || uvmsg}\\x2C ${ctx.syscall}`;\\n\\n  let path;\\n  let dest;\\n  if (ctx.path) {\\n    path = ctx.path.toString();\\n    message += ` '${path}'`;\\n  }\\n  if (ctx.dest) {\\n    dest = ctx.dest.toString();\\n    message += ` -> '${dest}'`;\\n  }\\n\\n  // Reducing the limit improves the performance significantly. We do not lose\\n  // the stack frames due to the `captureStackTrace()` function that is called\\n  // later.\\n  const tmpLimit = Error.stackTraceLimit;\\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n  // Pass the message to the constructor instead of setting it on the object\\n  // to make sure it is the same as the one created in C++\\n  // eslint-disable-next-line no-restricted-syntax\\n  const err = new Error(message);\\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n\\n  for (const prop of ObjectKeys(ctx)) {\\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\\n      continue;\\n    }\\n    err[prop] = ctx[prop];\\n  }\\n\\n  err.code = code;\\n  if (path) {\\n    err.path = path;\\n  }\\n  if (dest) {\\n    err.dest = dest;\\n  }\\n\\n  return captureLargerStackTrace(err);\\n});\\n\\n/**\\n * This creates an error compatible with errors produced in the C++\\n * This function should replace the deprecated\\n * `exceptionWithHostPort()` function.\\n *\\n * @param {number} err - A libuv error number\\n * @param {string} syscall\\n * @param {string} address\\n * @param {number} [port]\\n * @returns {Error}\\n */\\nconst uvExceptionWithHostPort = hideStackFrames(\\n  function uvExceptionWithHostPort(err\\x2C syscall\\x2C address\\x2C port) {\\n    const { 0: code\\x2C 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\\n    const message = `${syscall} ${code}: ${uvmsg}`;\\n    let details = '';\\n\\n    if (port && port > 0) {\\n      details = ` ${address}:${port}`;\\n    } else if (address) {\\n      details = ` ${address}`;\\n    }\\n\\n    // Reducing the limit improves the performance significantly. We do not\\n    // lose the stack frames due to the `captureStackTrace()` function that\\n    // is called later.\\n    const tmpLimit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    // eslint-disable-next-line no-restricted-syntax\\n    const ex = new Error(`${message}${details}`);\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n    ex.code = code;\\n    ex.errno = err;\\n    ex.syscall = syscall;\\n    ex.address = address;\\n    if (port) {\\n      ex.port = port;\\n    }\\n\\n    return captureLargerStackTrace(ex);\\n  });\\n\\n/**\\n * This used to be util._errnoException().\\n *\\n * @param {number} err - A libuv error number\\n * @param {string} syscall\\n * @param {string} [original]\\n * @returns {Error}\\n */\\nconst errnoException = hideStackFrames(\\n  function errnoException(err\\x2C syscall\\x2C original) {\\n    // TODO(joyeecheung): We have to use the type-checked\\n    // getSystemErrorName(err) to guard against invalid arguments from users.\\n    // This can be replaced with [ code ] = errmap.get(err) when this method\\n    // is no longer exposed to user land.\\n    if (util === undefined) util = require('util');\\n    const code = util.getSystemErrorName(err);\\n    const message = original ?\\n      `${syscall} ${code} ${original}` : `${syscall} ${code}`;\\n\\n    const tmpLimit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    // eslint-disable-next-line no-restricted-syntax\\n    const ex = new Error(message);\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n    ex.errno = err;\\n    ex.code = code;\\n    ex.syscall = syscall;\\n\\n    return captureLargerStackTrace(ex);\\n  });\\n\\n/**\\n * Deprecated\\x2C new function is `uvExceptionWithHostPort()`\\n * New function added the error description directly\\n * from C++. this method for backwards compatibility\\n * @param {number} err - A libuv error number\\n * @param {string} syscall\\n * @param {string} address\\n * @param {number} [port]\\n * @param {string} [additional]\\n * @returns {Error}\\n */\\nconst exceptionWithHostPort = hideStackFrames(\\n  function exceptionWithHostPort(err\\x2C syscall\\x2C address\\x2C port\\x2C additional) {\\n    // TODO(joyeecheung): We have to use the type-checked\\n    // getSystemErrorName(err) to guard against invalid arguments from users.\\n    // This can be replaced with [ code ] = errmap.get(err) when this method\\n    // is no longer exposed to user land.\\n    if (util === undefined) util = require('util');\\n    const code = util.getSystemErrorName(err);\\n    let details = '';\\n    if (port && port > 0) {\\n      details = ` ${address}:${port}`;\\n    } else if (address) {\\n      details = ` ${address}`;\\n    }\\n    if (additional) {\\n      details += ` - Local (${additional})`;\\n    }\\n\\n    // Reducing the limit improves the performance significantly. We do not\\n    // lose the stack frames due to the `captureStackTrace()` function that\\n    // is called later.\\n    const tmpLimit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    // eslint-disable-next-line no-restricted-syntax\\n    const ex = new Error(`${syscall} ${code}${details}`);\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n    ex.errno = err;\\n    ex.code = code;\\n    ex.syscall = syscall;\\n    ex.address = address;\\n    if (port) {\\n      ex.port = port;\\n    }\\n\\n    return captureLargerStackTrace(ex);\\n  });\\n\\n/**\\n * @param {number|string} code - A libuv error number or a c-ares error code\\n * @param {string} syscall\\n * @param {string} [hostname]\\n * @returns {Error}\\n */\\nconst dnsException = hideStackFrames(function(code\\x2C syscall\\x2C hostname) {\\n  let errno;\\n  // If `code` is of type number\\x2C it is a libuv error number\\x2C else it is a\\n  // c-ares error code.\\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\\n  // make them available in a property that's not error.errno (since they\\n  // can be in conflict with libuv error codes). Also make sure\\n  // util.getSystemErrorName() can understand them when an being informed that\\n  // the number is a c-ares error code.\\n  if (typeof code === 'number') {\\n    errno = code;\\n    // ENOTFOUND is not a proper POSIX error\\x2C but this error has been in place\\n    // long enough that it's not practical to remove it.\\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\\n      code = 'ENOTFOUND'; // Fabricated error name.\\n    } else {\\n      code = lazyInternalUtil().getSystemErrorName(code);\\n    }\\n  }\\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\\n  // Reducing the limit improves the performance significantly. We do not lose\\n  // the stack frames due to the `captureStackTrace()` function that is called\\n  // later.\\n  const tmpLimit = Error.stackTraceLimit;\\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n  // eslint-disable-next-line no-restricted-syntax\\n  const ex = new Error(message);\\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n  ex.errno = errno;\\n  ex.code = code;\\n  ex.syscall = syscall;\\n  if (hostname) {\\n    ex.hostname = hostname;\\n  }\\n\\n  return captureLargerStackTrace(ex);\\n});\\n\\nfunction connResetException(msg) {\\n  // eslint-disable-next-line no-restricted-syntax\\n  const ex = new Error(msg);\\n  ex.code = 'ECONNRESET';\\n  return ex;\\n}\\n\\nlet maxStack_ErrorName;\\nlet maxStack_ErrorMessage;\\n/**\\n * Returns true if `err.name` and `err.message` are equal to engine-specific\\n * values indicating max call stack size has been exceeded.\\n * \"Maximum call stack size exceeded\" in V8.\\n *\\n * @param {Error} err\\n * @returns {boolean}\\n */\\nfunction isStackOverflowError(err) {\\n  if (maxStack_ErrorMessage === undefined) {\\n    try {\\n      function overflowStack() { overflowStack(); }\\n      overflowStack();\\n    } catch (err) {\\n      maxStack_ErrorMessage = err.message;\\n      maxStack_ErrorName = err.name;\\n    }\\n  }\\n\\n  return err && err.name === maxStack_ErrorName &&\\n         err.message === maxStack_ErrorMessage;\\n}\\n\\n// Only use this for integers! Decimal numbers do not work with this function.\\nfunction addNumericalSeparator(val) {\\n  let res = '';\\n  let i = val.length;\\n  const start = val[0] === '-' ? 1 : 0;\\n  for (; i >= start + 4; i -= 3) {\\n    res = `_${StringPrototypeSlice(val\\x2C i - 3\\x2C i)}${res}`;\\n  }\\n  return `${StringPrototypeSlice(val\\x2C 0\\x2C i)}${res}`;\\n}\\n\\n// Used to enhance the stack that will be picked up by the inspector\\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\\n\\n// These are supposed to be called only on fatal exceptions before\\n// the process exits.\\nconst fatalExceptionStackEnhancers = {\\n  beforeInspector(error) {\\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\\n      return error.stack;\\n    }\\n\\n    try {\\n      // Set the error.stack here so it gets picked up by the\\n      // inspector.\\n      error.stack = error[kEnhanceStackBeforeInspector]();\\n    } catch {\\n      // We are just enhancing the error. If it fails\\x2C ignore it.\\n    }\\n    return error.stack;\\n  }\\x2C\\n  afterInspector(error) {\\n    const originalStack = error.stack;\\n    let useColors = true;\\n    // Some consoles do not convert ANSI escape sequences to colors\\x2C\\n    // rather display them directly to the stdout. On those consoles\\x2C\\n    // libuv emulates colors by intercepting stdout stream and calling\\n    // corresponding Windows API functions for setting console colors.\\n    // However\\x2C fatal error are handled differently and we cannot easily\\n    // highlight them. On Windows\\x2C detecting whether a console supports\\n    // ANSI escape sequences is not reliable.\\n    if (process.platform === 'win32') {\\n      const info = internalBinding('os').getOSInformation();\\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2]\\x2C '.')\\x2C\\n                                    Number);\\n      if (ver[0] !== 10 || ver[2] < 14393) {\\n        useColors = false;\\n      }\\n    }\\n    const {\\n      inspect\\x2C\\n      inspectDefaultOptions: {\\n        colors: defaultColors\\n      }\\n    } = lazyInternalUtilInspect();\\n    const colors = useColors &&\\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\\n                   require('internal/tty').hasColors()) ||\\n                   defaultColors);\\n    try {\\n      return inspect(error\\x2C {\\n        colors\\x2C\\n        customInspect: false\\x2C\\n        depth: MathMax(inspect.defaultOptions.depth\\x2C 5)\\n      });\\n    } catch {\\n      return originalStack;\\n    }\\n  }\\n};\\n\\n// Ensures the printed error line is from user code.\\nlet _kArrowMessagePrivateSymbol\\x2C _setHiddenValue;\\nfunction setArrowMessage(err\\x2C arrowMessage) {\\n  if (!_kArrowMessagePrivateSymbol) {\\n    ({\\n      arrow_message_private_symbol: _kArrowMessagePrivateSymbol\\x2C\\n      setHiddenValue: _setHiddenValue\\x2C\\n    } = internalBinding('util'));\\n  }\\n  _setHiddenValue(err\\x2C _kArrowMessagePrivateSymbol\\x2C arrowMessage);\\n}\\n\\n// Hide stack lines before the first user code line.\\nfunction hideInternalStackFrames(error) {\\n  overrideStackTrace.set(error\\x2C (error\\x2C stackFrames) => {\\n    let frames = stackFrames;\\n    if (typeof stackFrames === 'object') {\\n      frames = ArrayPrototypeFilter(\\n        stackFrames\\x2C\\n        (frm) => !StringPrototypeStartsWith(frm.getFileName() || ''\\x2C\\n                                            'node:internal')\\n      );\\n    }\\n    ArrayPrototypeUnshift(frames\\x2C error);\\n    return ArrayPrototypeJoin(frames\\x2C '\\\\n    at ');\\n  });\\n}\\n\\n// Node uses an AbortError that isn't exactly the same as the DOMException\\n// to make usage of the error in userland and readable-stream easier.\\n// It is a regular error with `.code` and `.name`.\\nclass AbortError extends Error {\\n  constructor() {\\n    super('The operation was aborted');\\n    this.code = 'ABORT_ERR';\\n    this.name = 'AbortError';\\n  }\\n}\\nmodule.exports = {\\n  aggregateTwoErrors\\x2C\\n  codes\\x2C\\n  dnsException\\x2C\\n  errnoException\\x2C\\n  exceptionWithHostPort\\x2C\\n  getMessage\\x2C\\n  hideStackFrames\\x2C\\n  hideInternalStackFrames\\x2C\\n  isErrorStackTraceLimitWritable\\x2C\\n  isStackOverflowError\\x2C\\n  setArrowMessage\\x2C\\n  connResetException\\x2C\\n  uvErrmapGet\\x2C\\n  uvException\\x2C\\n  uvExceptionWithHostPort\\x2C\\n  SystemError\\x2C\\n  AbortError\\x2C\\n  // This is exported only to facilitate testing.\\n  E\\x2C\\n  kNoOverride\\x2C\\n  prepareStackTrace\\x2C\\n  maybeOverridePrepareStackTrace\\x2C\\n  overrideStackTrace\\x2C\\n  kEnhanceStackBeforeInspector\\x2C\\n  fatalExceptionStackEnhancers\\x2C\\n  kIsNodeError\\x2C\\n  captureLargerStackTrace\\x2C\\n};\\n\\n// To declare an error message\\x2C use the E(sym\\x2C val\\x2C def) function above. The sym\\n// must be an upper case string. The val can be either a function or a string.\\n// The def must be an error class.\\n// The return value of the function must be a string.\\n// Examples:\\n// E('EXAMPLE_KEY1'\\x2C 'This is the error value'\\x2C Error);\\n// E('EXAMPLE_KEY2'\\x2C (a\\x2C b) => return `${a} ${b}`\\x2C RangeError);\\n//\\n// Once an error code has been assigned\\x2C the code itself MUST NOT change and\\n// any given error code must never be reused to identify a different error.\\n//\\n// Any error code added here should also be added to the documentation\\n//\\n// Note: Please try to keep these in alphabetical order\\n//\\n// Note: Node.js specific errors must begin with the prefix ERR_\\n\\nE('ERR_AMBIGUOUS_ARGUMENT'\\x2C 'The \"%s\" argument is ambiguous. %s'\\x2C TypeError);\\nE('ERR_ARG_NOT_ITERABLE'\\x2C '%s must be iterable'\\x2C TypeError);\\nE('ERR_ASSERTION'\\x2C '%s'\\x2C Error);\\nE('ERR_ASYNC_CALLBACK'\\x2C '%s must be a function'\\x2C TypeError);\\nE('ERR_ASYNC_TYPE'\\x2C 'Invalid name for async \"type\": %s'\\x2C TypeError);\\nE('ERR_BROTLI_INVALID_PARAM'\\x2C '%s is not a valid Brotli parameter'\\x2C RangeError);\\nE('ERR_BUFFER_OUT_OF_BOUNDS'\\x2C\\n  // Using a default argument here is important so the argument is not counted\\n  // towards `Function#length`.\\n  (name = undefined) => {\\n    if (name) {\\n      return `\"${name}\" is outside of buffer bounds`;\\n    }\\n    return 'Attempt to access memory outside buffer bounds';\\n  }\\x2C RangeError);\\nE('ERR_BUFFER_TOO_LARGE'\\x2C\\n  'Cannot create a Buffer larger than %s bytes'\\x2C\\n  RangeError);\\nE('ERR_CANNOT_WATCH_SIGINT'\\x2C 'Cannot watch for SIGINT signals'\\x2C Error);\\nE('ERR_CHILD_CLOSED_BEFORE_REPLY'\\x2C\\n  'Child closed before reply received'\\x2C Error);\\nE('ERR_CHILD_PROCESS_IPC_REQUIRED'\\x2C\\n  \"Forked processes must have an IPC channel\\x2C missing value 'ipc' in %s\"\\x2C\\n  Error);\\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER'\\x2C '%s maxBuffer length exceeded'\\x2C\\n  RangeError);\\nE('ERR_CONSOLE_WRITABLE_STREAM'\\x2C\\n  'Console expects a writable stream instance for %s'\\x2C TypeError);\\nE('ERR_CONTEXT_NOT_INITIALIZED'\\x2C 'context used is not initialized'\\x2C Error);\\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED'\\x2C\\n  'Custom engines not supported by this OpenSSL'\\x2C Error);\\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT'\\x2C 'Invalid ECDH format: %s'\\x2C TypeError);\\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY'\\x2C\\n  'Public key is not valid for specified curve'\\x2C Error);\\nE('ERR_CRYPTO_ENGINE_UNKNOWN'\\x2C 'Engine \"%s\" was not found'\\x2C Error);\\nE('ERR_CRYPTO_FIPS_FORCED'\\x2C\\n  'Cannot set FIPS mode\\x2C it was forced with --force-fips at startup.'\\x2C Error);\\nE('ERR_CRYPTO_FIPS_UNAVAILABLE'\\x2C 'Cannot set FIPS mode in a non-FIPS build.'\\x2C\\n  Error);\\nE('ERR_CRYPTO_HASH_FINALIZED'\\x2C 'Digest already called'\\x2C Error);\\nE('ERR_CRYPTO_HASH_UPDATE_FAILED'\\x2C 'Hash update failed'\\x2C Error);\\nE('ERR_CRYPTO_INCOMPATIBLE_KEY'\\x2C 'Incompatible %s: %s'\\x2C Error);\\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'\\x2C 'The selected key encoding %s %s.'\\x2C\\n  Error);\\nE('ERR_CRYPTO_INVALID_DIGEST'\\x2C 'Invalid digest: %s'\\x2C TypeError);\\nE('ERR_CRYPTO_INVALID_JWK'\\x2C 'Invalid JWK data'\\x2C TypeError);\\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE'\\x2C\\n  'Invalid key object type %s\\x2C expected %s.'\\x2C TypeError);\\nE('ERR_CRYPTO_INVALID_STATE'\\x2C 'Invalid state for operation %s'\\x2C Error);\\nE('ERR_CRYPTO_PBKDF2_ERROR'\\x2C 'PBKDF2 error'\\x2C Error);\\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER'\\x2C 'Invalid scrypt parameter'\\x2C Error);\\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED'\\x2C 'Scrypt algorithm not supported'\\x2C Error);\\n// Switch to TypeError. The current implementation does not seem right.\\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED'\\x2C 'No key provided to sign'\\x2C Error);\\nE('ERR_DEBUGGER_ERROR'\\x2C '%s'\\x2C Error);\\nE('ERR_DEBUGGER_STARTUP_ERROR'\\x2C '%s'\\x2C Error);\\nE('ERR_DIR_CLOSED'\\x2C 'Directory handle was closed'\\x2C Error);\\nE('ERR_DIR_CONCURRENT_OPERATION'\\x2C\\n  'Cannot do synchronous work on directory handle with concurrent ' +\\n  'asynchronous operations'\\x2C Error);\\nE('ERR_DNS_SET_SERVERS_FAILED'\\x2C 'c-ares failed to set servers: \"%s\" [%s]'\\x2C\\n  Error);\\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE'\\x2C\\n  'A callback was registered through ' +\\n     'process.setUncaughtExceptionCaptureCallback()\\x2C which is mutually ' +\\n     'exclusive with using the `domain` module'\\x2C\\n  Error);\\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE'\\x2C\\n  'The `domain` module is in use\\x2C which is mutually exclusive with calling ' +\\n     'process.setUncaughtExceptionCaptureCallback()'\\x2C\\n  Error);\\nE('ERR_ENCODING_INVALID_ENCODED_DATA'\\x2C function(encoding\\x2C ret) {\\n  this.errno = ret;\\n  return `The encoded data was not valid for encoding ${encoding}`;\\n}\\x2C TypeError);\\nE('ERR_ENCODING_NOT_SUPPORTED'\\x2C 'The \"%s\" encoding is not supported'\\x2C\\n  RangeError);\\nE('ERR_EVAL_ESM_CANNOT_PRINT'\\x2C '--print cannot be used with ESM input'\\x2C Error);\\nE('ERR_EVENT_RECURSION'\\x2C 'The event \"%s\" is already being dispatched'\\x2C Error);\\nE('ERR_FALSY_VALUE_REJECTION'\\x2C function(reason) {\\n  this.reason = reason;\\n  return 'Promise was rejected with falsy value';\\n}\\x2C Error);\\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM'\\x2C\\n  'The feature %s is unavailable on the current platform' +\\n  '\\x2C which is being used to run Node.js'\\x2C\\n  TypeError);\\nE('ERR_FS_CP_DIR_TO_NON_DIR'\\x2C\\n  'Cannot overwrite directory with non-directory'\\x2C SystemError);\\nE('ERR_FS_CP_EEXIST'\\x2C 'Target already exists'\\x2C SystemError);\\nE('ERR_FS_CP_EINVAL'\\x2C 'Invalid src or dest'\\x2C SystemError);\\nE('ERR_FS_CP_FIFO_PIPE'\\x2C 'Cannot copy a FIFO pipe'\\x2C SystemError);\\nE('ERR_FS_CP_NON_DIR_TO_DIR'\\x2C\\n  'Cannot overwrite non-directory with directory'\\x2C SystemError);\\nE('ERR_FS_CP_SOCKET'\\x2C 'Cannot copy a socket file'\\x2C SystemError);\\nE('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY'\\x2C\\n  'Cannot overwrite symlink in subdirectory of self'\\x2C SystemError);\\nE('ERR_FS_CP_UNKNOWN'\\x2C 'Cannot copy an unknown file type'\\x2C SystemError);\\nE('ERR_FS_EISDIR'\\x2C 'Path is a directory'\\x2C SystemError);\\nE('ERR_FS_FILE_TOO_LARGE'\\x2C 'File size (%s) is greater than 2 GB'\\x2C RangeError);\\nE('ERR_FS_INVALID_SYMLINK_TYPE'\\x2C\\n  'Symlink type must be one of \"dir\"\\x2C \"file\"\\x2C or \"junction\". Received \"%s\"'\\x2C\\n  Error); // Switch to TypeError. The current implementation does not seem right\\nE('ERR_HTTP2_ALTSVC_INVALID_ORIGIN'\\x2C\\n  'HTTP/2 ALTSVC frames require a valid origin'\\x2C TypeError);\\nE('ERR_HTTP2_ALTSVC_LENGTH'\\x2C\\n  'HTTP/2 ALTSVC frames are limited to 16382 bytes'\\x2C TypeError);\\nE('ERR_HTTP2_CONNECT_AUTHORITY'\\x2C\\n  ':authority header is required for CONNECT requests'\\x2C Error);\\nE('ERR_HTTP2_CONNECT_PATH'\\x2C\\n  'The :path header is forbidden for CONNECT requests'\\x2C Error);\\nE('ERR_HTTP2_CONNECT_SCHEME'\\x2C\\n  'The :scheme header is forbidden for CONNECT requests'\\x2C Error);\\nE('ERR_HTTP2_GOAWAY_SESSION'\\x2C\\n  'New streams cannot be created after receiving a GOAWAY'\\x2C Error);\\nE('ERR_HTTP2_HEADERS_AFTER_RESPOND'\\x2C\\n  'Cannot specify additional headers after response initiated'\\x2C Error);\\nE('ERR_HTTP2_HEADERS_SENT'\\x2C 'Response has already been initiated.'\\x2C Error);\\nE('ERR_HTTP2_HEADER_SINGLE_VALUE'\\x2C\\n  'Header field \"%s\" must only have a single value'\\x2C TypeError);\\nE('ERR_HTTP2_INFO_STATUS_NOT_ALLOWED'\\x2C\\n  'Informational status codes cannot be used'\\x2C RangeError);\\nE('ERR_HTTP2_INVALID_CONNECTION_HEADERS'\\x2C\\n  'HTTP/1 Connection specific headers are forbidden: \"%s\"'\\x2C TypeError);\\nE('ERR_HTTP2_INVALID_HEADER_VALUE'\\x2C\\n  'Invalid value \"%s\" for header \"%s\"'\\x2C TypeError);\\nE('ERR_HTTP2_INVALID_INFO_STATUS'\\x2C\\n  'Invalid informational status code: %s'\\x2C RangeError);\\nE('ERR_HTTP2_INVALID_ORIGIN'\\x2C\\n  'HTTP/2 ORIGIN frames require a valid origin'\\x2C TypeError);\\nE('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH'\\x2C\\n  'Packed settings length must be a multiple of six'\\x2C RangeError);\\nE('ERR_HTTP2_INVALID_PSEUDOHEADER'\\x2C\\n  '\"%s\" is an invalid pseudoheader or is used incorrectly'\\x2C TypeError);\\nE('ERR_HTTP2_INVALID_SESSION'\\x2C 'The session has been destroyed'\\x2C Error);\\nE('ERR_HTTP2_INVALID_SETTING_VALUE'\\x2C\\n  // Using default arguments here is important so the arguments are not counted\\n  // towards `Function#length`.\\n  function(name\\x2C actual\\x2C min = undefined\\x2C max = undefined) {\\n    this.actual = actual;\\n    if (min !== undefined) {\\n      this.min = min;\\n      this.max = max;\\n    }\\n    return `Invalid value for setting \"${name}\": ${actual}`;\\n  }\\x2C TypeError\\x2C RangeError);\\nE('ERR_HTTP2_INVALID_STREAM'\\x2C 'The stream has been destroyed'\\x2C Error);\\nE('ERR_HTTP2_MAX_PENDING_SETTINGS_ACK'\\x2C\\n  'Maximum number of pending settings acknowledgements'\\x2C Error);\\nE('ERR_HTTP2_NESTED_PUSH'\\x2C\\n  'A push stream cannot initiate another push stream.'\\x2C Error);\\nE('ERR_HTTP2_NO_MEM'\\x2C 'Out of memory'\\x2C Error);\\nE('ERR_HTTP2_NO_SOCKET_MANIPULATION'\\x2C\\n  'HTTP/2 sockets should not be directly manipulated (e.g. read and written)'\\x2C\\n  Error);\\nE('ERR_HTTP2_ORIGIN_LENGTH'\\x2C\\n  'HTTP/2 ORIGIN frames are limited to 16382 bytes'\\x2C TypeError);\\nE('ERR_HTTP2_OUT_OF_STREAMS'\\x2C\\n  'No stream ID is available because maximum stream ID has been reached'\\x2C\\n  Error);\\nE('ERR_HTTP2_PAYLOAD_FORBIDDEN'\\x2C\\n  'Responses with %s status must not have a payload'\\x2C Error);\\nE('ERR_HTTP2_PING_CANCEL'\\x2C 'HTTP2 ping cancelled'\\x2C Error);\\nE('ERR_HTTP2_PING_LENGTH'\\x2C 'HTTP2 ping payload must be 8 bytes'\\x2C RangeError);\\nE('ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED'\\x2C\\n  'Cannot set HTTP/2 pseudo-headers'\\x2C TypeError);\\nE('ERR_HTTP2_PUSH_DISABLED'\\x2C 'HTTP/2 client has disabled push streams'\\x2C Error);\\nE('ERR_HTTP2_SEND_FILE'\\x2C 'Directories cannot be sent'\\x2C Error);\\nE('ERR_HTTP2_SEND_FILE_NOSEEK'\\x2C\\n  'Offset or length can only be specified for regular files'\\x2C Error);\\nE('ERR_HTTP2_SESSION_ERROR'\\x2C 'Session closed with error code %s'\\x2C Error);\\nE('ERR_HTTP2_SETTINGS_CANCEL'\\x2C 'HTTP2 session settings canceled'\\x2C Error);\\nE('ERR_HTTP2_SOCKET_BOUND'\\x2C\\n  'The socket is already bound to an Http2Session'\\x2C Error);\\nE('ERR_HTTP2_SOCKET_UNBOUND'\\x2C\\n  'The socket has been disconnected from the Http2Session'\\x2C Error);\\nE('ERR_HTTP2_STATUS_101'\\x2C\\n  'HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2'\\x2C Error);\\nE('ERR_HTTP2_STATUS_INVALID'\\x2C 'Invalid status code: %s'\\x2C RangeError);\\nE('ERR_HTTP2_STREAM_CANCEL'\\x2C function(error) {\\n  let msg = 'The pending stream has been canceled';\\n  if (error) {\\n    this.cause = error;\\n    if (typeof error.message === 'string')\\n      msg += ` (caused by: ${error.message})`;\\n  }\\n  return msg;\\n}\\x2C Error);\\nE('ERR_HTTP2_STREAM_ERROR'\\x2C 'Stream closed with error code %s'\\x2C Error);\\nE('ERR_HTTP2_STREAM_SELF_DEPENDENCY'\\x2C\\n  'A stream cannot depend on itself'\\x2C Error);\\nE('ERR_HTTP2_TOO_MANY_INVALID_FRAMES'\\x2C 'Too many invalid HTTP/2 frames'\\x2C Error);\\nE('ERR_HTTP2_TRAILERS_ALREADY_SENT'\\x2C\\n  'Trailing headers have already been sent'\\x2C Error);\\nE('ERR_HTTP2_TRAILERS_NOT_READY'\\x2C\\n  'Trailing headers cannot be sent until after the wantTrailers event is ' +\\n  'emitted'\\x2C Error);\\nE('ERR_HTTP2_UNSUPPORTED_PROTOCOL'\\x2C 'protocol \"%s\" is unsupported.'\\x2C Error);\\nE('ERR_HTTP_HEADERS_SENT'\\x2C\\n  'Cannot %s headers after they are sent to the client'\\x2C Error);\\nE('ERR_HTTP_INVALID_HEADER_VALUE'\\x2C\\n  'Invalid value \"%s\" for header \"%s\"'\\x2C TypeError);\\nE('ERR_HTTP_INVALID_STATUS_CODE'\\x2C 'Invalid status code: %s'\\x2C RangeError);\\nE('ERR_HTTP_REQUEST_TIMEOUT'\\x2C 'Request timeout'\\x2C Error);\\nE('ERR_HTTP_SOCKET_ENCODING'\\x2C\\n  'Changing the socket encoding is not allowed per RFC7230 Section 3.'\\x2C Error);\\nE('ERR_HTTP_TRAILER_INVALID'\\x2C\\n  'Trailers are invalid with this transfer encoding'\\x2C Error);\\nE('ERR_ILLEGAL_CONSTRUCTOR'\\x2C 'Illegal constructor'\\x2C TypeError);\\nE('ERR_IMPORT_ASSERTION_TYPE_FAILED'\\x2C\\n  'Module \"%s\" is not of type \"%s\"'\\x2C TypeError);\\nE('ERR_IMPORT_ASSERTION_TYPE_MISSING'\\x2C\\n  'Module \"%s\" needs an import assertion of type \"%s\"'\\x2C TypeError);\\nE('ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED'\\x2C\\n  'Import assertion type \"%s\" is unsupported'\\x2C TypeError);\\nE('ERR_INCOMPATIBLE_OPTION_PAIR'\\x2C\\n  'Option \"%s\" cannot be used in combination with option \"%s\"'\\x2C TypeError);\\nE('ERR_INPUT_TYPE_NOT_ALLOWED'\\x2C '--input-type can only be used with string ' +\\n  'input via --eval\\x2C --print\\x2C or STDIN'\\x2C Error);\\nE('ERR_INSPECTOR_ALREADY_ACTIVATED'\\x2C\\n  'Inspector is already activated. Close it with inspector.close() ' +\\n  'before activating it again.'\\x2C\\n  Error);\\nE('ERR_INSPECTOR_ALREADY_CONNECTED'\\x2C '%s is already connected'\\x2C Error);\\nE('ERR_INSPECTOR_CLOSED'\\x2C 'Session was closed'\\x2C Error);\\nE('ERR_INSPECTOR_COMMAND'\\x2C 'Inspector error %d: %s'\\x2C Error);\\nE('ERR_INSPECTOR_NOT_ACTIVE'\\x2C 'Inspector is not active'\\x2C Error);\\nE('ERR_INSPECTOR_NOT_AVAILABLE'\\x2C 'Inspector is not available'\\x2C Error);\\nE('ERR_INSPECTOR_NOT_CONNECTED'\\x2C 'Session is not connected'\\x2C Error);\\nE('ERR_INSPECTOR_NOT_WORKER'\\x2C 'Current thread is not a worker'\\x2C Error);\\nE('ERR_INTERNAL_ASSERTION'\\x2C (message) => {\\n  const suffix = 'This is caused by either a bug in Node.js ' +\\n    'or incorrect usage of Node.js internals.\\\\n' +\\n    'Please open an issue with this stack trace at ' +\\n    'https://github.com/nodejs/node/issues\\\\n';\\n  return message === undefined ? suffix : `${message}\\\\n${suffix}`;\\n}\\x2C Error);\\nE('ERR_INVALID_ADDRESS_FAMILY'\\x2C function(addressType\\x2C host\\x2C port) {\\n  this.host = host;\\n  this.port = port;\\n  return `Invalid address family: ${addressType} ${host}:${port}`;\\n}\\x2C RangeError);\\nE('ERR_INVALID_ARG_TYPE'\\x2C\\n  (name\\x2C expected\\x2C actual) => {\\n    assert(typeof name === 'string'\\x2C \"'name' must be a string\");\\n    if (!ArrayIsArray(expected)) {\\n      expected = [expected];\\n    }\\n\\n    let msg = 'The ';\\n    if (StringPrototypeEndsWith(name\\x2C ' argument')) {\\n      // For cases like 'first argument'\\n      msg += `${name} `;\\n    } else {\\n      const type = StringPrototypeIncludes(name\\x2C '.') ? 'property' : 'argument';\\n      msg += `\"${name}\" ${type} `;\\n    }\\n    msg += 'must be ';\\n\\n    const types = [];\\n    const instances = [];\\n    const other = [];\\n\\n    for (const value of expected) {\\n      assert(typeof value === 'string'\\x2C\\n             'All expected entries have to be of type string');\\n      if (ArrayPrototypeIncludes(kTypes\\x2C value)) {\\n        ArrayPrototypePush(types\\x2C StringPrototypeToLowerCase(value));\\n      } else if (RegExpPrototypeTest(classRegExp\\x2C value)) {\\n        ArrayPrototypePush(instances\\x2C value);\\n      } else {\\n        assert(value !== 'object'\\x2C\\n               'The value \"object\" should be written as \"Object\"');\\n        ArrayPrototypePush(other\\x2C value);\\n      }\\n    }\\n\\n    // Special handle `object` in case other instances are allowed to outline\\n    // the differences between each other.\\n    if (instances.length > 0) {\\n      const pos = ArrayPrototypeIndexOf(types\\x2C 'object');\\n      if (pos !== -1) {\\n        ArrayPrototypeSplice(types\\x2C pos\\x2C 1);\\n        ArrayPrototypePush(instances\\x2C 'Object');\\n      }\\n    }\\n\\n    if (types.length > 0) {\\n      if (types.length > 2) {\\n        const last = ArrayPrototypePop(types);\\n        msg += `one of type ${ArrayPrototypeJoin(types\\x2C '\\x2C ')}\\x2C or ${last}`;\\n      } else if (types.length === 2) {\\n        msg += `one of type ${types[0]} or ${types[1]}`;\\n      } else {\\n        msg += `of type ${types[0]}`;\\n      }\\n      if (instances.length > 0 || other.length > 0)\\n        msg += ' or ';\\n    }\\n\\n    if (instances.length > 0) {\\n      if (instances.length > 2) {\\n        const last = ArrayPrototypePop(instances);\\n        msg +=\\n          `an instance of ${ArrayPrototypeJoin(instances\\x2C '\\x2C ')}\\x2C or ${last}`;\\n      } else {\\n        msg += `an instance of ${instances[0]}`;\\n        if (instances.length === 2) {\\n          msg += ` or ${instances[1]}`;\\n        }\\n      }\\n      if (other.length > 0)\\n        msg += ' or ';\\n    }\\n\\n    if (other.length > 0) {\\n      if (other.length > 2) {\\n        const last = ArrayPrototypePop(other);\\n        msg += `one of ${ArrayPrototypeJoin(other\\x2C '\\x2C ')}\\x2C or ${last}`;\\n      } else if (other.length === 2) {\\n        msg += `one of ${other[0]} or ${other[1]}`;\\n      } else {\\n        if (StringPrototypeToLowerCase(other[0]) !== other[0])\\n          msg += 'an ';\\n        msg += `${other[0]}`;\\n      }\\n    }\\n\\n    if (actual == null) {\\n      msg += `. Received ${actual}`;\\n    } else if (typeof actual === 'function' && actual.name) {\\n      msg += `. Received function ${actual.name}`;\\n    } else if (typeof actual === 'object') {\\n      if (actual.constructor && actual.constructor.name) {\\n        msg += `. Received an instance of ${actual.constructor.name}`;\\n      } else {\\n        const inspected = lazyInternalUtilInspect()\\n          .inspect(actual\\x2C { depth: -1 });\\n        msg += `. Received ${inspected}`;\\n      }\\n    } else {\\n      let inspected = lazyInternalUtilInspect()\\n        .inspect(actual\\x2C { colors: false });\\n      if (inspected.length > 25)\\n        inspected = `${StringPrototypeSlice(inspected\\x2C 0\\x2C 25)}...`;\\n      msg += `. Received type ${typeof actual} (${inspected})`;\\n    }\\n    return msg;\\n  }\\x2C TypeError);\\nE('ERR_INVALID_ARG_VALUE'\\x2C (name\\x2C value\\x2C reason = 'is invalid') => {\\n  let inspected = lazyInternalUtilInspect().inspect(value);\\n  if (inspected.length > 128) {\\n    inspected = `${StringPrototypeSlice(inspected\\x2C 0\\x2C 128)}...`;\\n  }\\n  const type = StringPrototypeIncludes(name\\x2C '.') ? 'property' : 'argument';\\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\\n}\\x2C TypeError\\x2C RangeError);\\nE('ERR_INVALID_ASYNC_ID'\\x2C 'Invalid %s value: %s'\\x2C RangeError);\\nE('ERR_INVALID_BUFFER_SIZE'\\x2C\\n  'Buffer size must be a multiple of %s'\\x2C RangeError);\\nE('ERR_INVALID_CALLBACK'\\x2C\\n  'Callback must be a function. Received %O'\\x2C TypeError);\\nE('ERR_INVALID_CHAR'\\x2C\\n  // Using a default argument here is important so the argument is not counted\\n  // towards `Function#length`.\\n  (name\\x2C field = undefined) => {\\n    let msg = `Invalid character in ${name}`;\\n    if (field !== undefined) {\\n      msg += ` [\"${field}\"]`;\\n    }\\n    return msg;\\n  }\\x2C TypeError);\\nE('ERR_INVALID_CURSOR_POS'\\x2C\\n  'Cannot set cursor row without setting its column'\\x2C TypeError);\\nE('ERR_INVALID_FD'\\x2C\\n  '\"fd\" must be a positive integer: %s'\\x2C RangeError);\\nE('ERR_INVALID_FD_TYPE'\\x2C 'Unsupported fd type: %s'\\x2C TypeError);\\nE('ERR_INVALID_FILE_URL_HOST'\\x2C\\n  'File URL host must be \"localhost\" or empty on %s'\\x2C TypeError);\\nE('ERR_INVALID_FILE_URL_PATH'\\x2C 'File URL path %s'\\x2C TypeError);\\nE('ERR_INVALID_HANDLE_TYPE'\\x2C 'This handle type cannot be sent'\\x2C TypeError);\\nE('ERR_INVALID_HTTP_TOKEN'\\x2C '%s must be a valid HTTP token [\"%s\"]'\\x2C TypeError);\\nE('ERR_INVALID_IP_ADDRESS'\\x2C 'Invalid IP address: %s'\\x2C TypeError);\\nE('ERR_INVALID_MODULE_SPECIFIER'\\x2C (request\\x2C reason\\x2C base = undefined) => {\\n  return `Invalid module \"${request}\" ${reason}${base ?\\n    ` imported from ${base}` : ''}`;\\n}\\x2C TypeError);\\nE('ERR_INVALID_PACKAGE_CONFIG'\\x2C (path\\x2C base\\x2C message) => {\\n  return `Invalid package config ${path}${base ? ` while importing ${base}` :\\n    ''}${message ? `. ${message}` : ''}`;\\n}\\x2C Error);\\nE('ERR_INVALID_PACKAGE_TARGET'\\x2C\\n  (pkgPath\\x2C key\\x2C target\\x2C isImport = false\\x2C base = undefined) => {\\n    const relError = typeof target === 'string' && !isImport &&\\n      target.length && !StringPrototypeStartsWith(target\\x2C './');\\n    if (key === '.') {\\n      assert(isImport === false);\\n      return `Invalid \"exports\" main target ${JSONStringify(target)} defined ` +\\n        `in the package config ${pkgPath}package.json${base ?\\n          ` imported from ${base}` : ''}${relError ?\\n          '; targets must start with \"./\"' : ''}`;\\n    }\\n    return `Invalid \"${isImport ? 'imports' : 'exports'}\" target ${\\n      JSONStringify(target)} defined for '${key}' in the package config ${\\n      pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ?\\n      '; targets must start with \"./\"' : ''}`;\\n  }\\x2C Error);\\nE('ERR_INVALID_PROTOCOL'\\x2C\\n  'Protocol \"%s\" not supported. Expected \"%s\"'\\x2C\\n  TypeError);\\nE('ERR_INVALID_REPL_EVAL_CONFIG'\\x2C\\n  'Cannot specify both \"breakEvalOnSigint\" and \"eval\" for REPL'\\x2C TypeError);\\nE('ERR_INVALID_REPL_INPUT'\\x2C '%s'\\x2C TypeError);\\nE('ERR_INVALID_RETURN_PROPERTY'\\x2C (input\\x2C name\\x2C prop\\x2C value) => {\\n  return `Expected a valid ${input} to be returned for the \"${prop}\" from the` +\\n         ` \"${name}\" function but got ${value}.`;\\n}\\x2C TypeError);\\nE('ERR_INVALID_RETURN_PROPERTY_VALUE'\\x2C (input\\x2C name\\x2C prop\\x2C value) => {\\n  let type;\\n  if (value && value.constructor && value.constructor.name) {\\n    type = `instance of ${value.constructor.name}`;\\n  } else {\\n    type = `type ${typeof value}`;\\n  }\\n  return `Expected ${input} to be returned for the \"${prop}\" from the` +\\n         ` \"${name}\" function but got ${type}.`;\\n}\\x2C TypeError);\\nE('ERR_INVALID_RETURN_VALUE'\\x2C (input\\x2C name\\x2C value) => {\\n  let type;\\n  if (value && value.constructor && value.constructor.name) {\\n    type = `instance of ${value.constructor.name}`;\\n  } else {\\n    type = `type ${typeof value}`;\\n  }\\n  return `Expected ${input} to be returned from the \"${name}\"` +\\n         ` function but got ${type}.`;\\n}\\x2C TypeError\\x2C RangeError);\\nE('ERR_INVALID_STATE'\\x2C 'Invalid state: %s'\\x2C Error\\x2C TypeError\\x2C RangeError);\\nE('ERR_INVALID_SYNC_FORK_INPUT'\\x2C\\n  'Asynchronous forks do not support ' +\\n    'Buffer\\x2C TypedArray\\x2C DataView or string input: %s'\\x2C\\n  TypeError);\\nE('ERR_INVALID_THIS'\\x2C 'Value of \"this\" must be of type %s'\\x2C TypeError);\\nE('ERR_INVALID_TUPLE'\\x2C '%s must be an iterable %s tuple'\\x2C TypeError);\\nE('ERR_INVALID_URI'\\x2C 'URI malformed'\\x2C URIError);\\nE('ERR_INVALID_URL'\\x2C function(input) {\\n  this.input = input;\\n  // Don't include URL in message.\\n  // (See https://github.com/nodejs/node/pull/38614)\\n  return 'Invalid URL';\\n}\\x2C TypeError);\\nE('ERR_INVALID_URL_SCHEME'\\x2C\\n  (expected) => {\\n    if (typeof expected === 'string')\\n      expected = [expected];\\n    assert(expected.length <= 2);\\n    const res = expected.length === 2 ?\\n      `one of scheme ${expected[0]} or ${expected[1]}` :\\n      `of scheme ${expected[0]}`;\\n    return `The URL must be ${res}`;\\n  }\\x2C TypeError);\\nE('ERR_IPC_CHANNEL_CLOSED'\\x2C 'Channel closed'\\x2C Error);\\nE('ERR_IPC_DISCONNECTED'\\x2C 'IPC channel is already disconnected'\\x2C Error);\\nE('ERR_IPC_ONE_PIPE'\\x2C 'Child process can have only one IPC pipe'\\x2C Error);\\nE('ERR_IPC_SYNC_FORK'\\x2C 'IPC cannot be used with synchronous forks'\\x2C Error);\\nE('ERR_MANIFEST_ASSERT_INTEGRITY'\\x2C\\n  (moduleURL\\x2C realIntegrities) => {\\n    let msg = `The content of \"${\\n      moduleURL\\n    }\" does not match the expected integrity.`;\\n    if (realIntegrities.size) {\\n      const sri = ArrayPrototypeJoin(\\n        ArrayFrom(realIntegrities.entries()\\x2C\\n                  ({ 0: alg\\x2C 1: dgs }) => `${alg}-${dgs}`)\\x2C\\n        ' '\\n      );\\n      msg += ` Integrities found are: ${sri}`;\\n    } else {\\n      msg += ' The resource was not found in the policy.';\\n    }\\n    return msg;\\n  }\\x2C Error);\\nE('ERR_MANIFEST_DEPENDENCY_MISSING'\\x2C\\n  'Manifest resource %s does not list %s as a dependency specifier for ' +\\n  'conditions: %s'\\x2C\\n  Error);\\nE('ERR_MANIFEST_INTEGRITY_MISMATCH'\\x2C\\n  'Manifest resource %s has multiple entries but integrity lists do not match'\\x2C\\n  SyntaxError);\\nE('ERR_MANIFEST_INVALID_RESOURCE_FIELD'\\x2C\\n  'Manifest resource %s has invalid property value for %s'\\x2C\\n  TypeError);\\nE('ERR_MANIFEST_INVALID_SPECIFIER'\\x2C\\n  'Manifest resource %s has invalid dependency mapping %s'\\x2C\\n  TypeError);\\nE('ERR_MANIFEST_TDZ'\\x2C 'Manifest initialization has not yet run'\\x2C Error);\\nE('ERR_MANIFEST_UNKNOWN_ONERROR'\\x2C\\n  'Manifest specified unknown error behavior \"%s\".'\\x2C\\n  SyntaxError);\\nE('ERR_METHOD_NOT_IMPLEMENTED'\\x2C 'The %s method is not implemented'\\x2C Error);\\nE('ERR_MISSING_ARGS'\\x2C\\n  (...args) => {\\n    assert(args.length > 0\\x2C 'At least one arg needs to be specified');\\n    let msg = 'The ';\\n    const len = args.length;\\n    const wrap = (a) => `\"${a}\"`;\\n    args = ArrayPrototypeMap(\\n      args\\x2C\\n      (a) => (ArrayIsArray(a) ?\\n        ArrayPrototypeJoin(ArrayPrototypeMap(a\\x2C wrap)\\x2C ' or ') :\\n        wrap(a))\\n    );\\n    switch (len) {\\n      case 1:\\n        msg += `${args[0]} argument`;\\n        break;\\n      case 2:\\n        msg += `${args[0]} and ${args[1]} arguments`;\\n        break;\\n      default:\\n        msg += ArrayPrototypeJoin(ArrayPrototypeSlice(args\\x2C 0\\x2C len - 1)\\x2C '\\x2C ');\\n        msg += `\\x2C and ${args[len - 1]} arguments`;\\n        break;\\n    }\\n    return `${msg} must be specified`;\\n  }\\x2C TypeError);\\nE('ERR_MISSING_OPTION'\\x2C '%s is required'\\x2C TypeError);\\nE('ERR_MODULE_NOT_FOUND'\\x2C (path\\x2C base\\x2C type = 'package') => {\\n  return `Cannot find ${type} '${path}' imported from ${base}`;\\n}\\x2C Error);\\nE('ERR_MULTIPLE_CALLBACK'\\x2C 'Callback called multiple times'\\x2C Error);\\nE('ERR_NAPI_CONS_FUNCTION'\\x2C 'Constructor must be a function'\\x2C TypeError);\\nE('ERR_NAPI_INVALID_DATAVIEW_ARGS'\\x2C\\n  'byte_offset + byte_length should be less than or equal to the size in ' +\\n    'bytes of the array passed in'\\x2C\\n  RangeError);\\nE('ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT'\\x2C\\n  'start offset of %s should be a multiple of %s'\\x2C RangeError);\\nE('ERR_NAPI_INVALID_TYPEDARRAY_LENGTH'\\x2C\\n  'Invalid typed array length'\\x2C RangeError);\\nE('ERR_NO_CRYPTO'\\x2C\\n  'Node.js is not compiled with OpenSSL crypto support'\\x2C Error);\\nE('ERR_NO_ICU'\\x2C\\n  '%s is not supported on Node.js compiled without ICU'\\x2C TypeError);\\nE('ERR_OPERATION_FAILED'\\x2C 'Operation failed: %s'\\x2C Error\\x2C TypeError);\\nE('ERR_OUT_OF_RANGE'\\x2C\\n  (str\\x2C range\\x2C input\\x2C replaceDefaultBoolean = false) => {\\n    assert(range\\x2C 'Missing \"range\" argument');\\n    let msg = replaceDefaultBoolean ? str :\\n      `The value of \"${str}\" is out of range.`;\\n    let received;\\n    if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\\n      received = addNumericalSeparator(String(input));\\n    } else if (typeof input === 'bigint') {\\n      received = String(input);\\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\\n        received = addNumericalSeparator(received);\\n      }\\n      received += 'n';\\n    } else {\\n      received = lazyInternalUtilInspect().inspect(input);\\n    }\\n    msg += ` It must be ${range}. Received ${received}`;\\n    return msg;\\n  }\\x2C RangeError);\\nE('ERR_PACKAGE_IMPORT_NOT_DEFINED'\\x2C (specifier\\x2C packagePath\\x2C base) => {\\n  return `Package import specifier \"${specifier}\" is not defined${packagePath ?\\n    ` in package ${packagePath}package.json` : ''} imported from ${base}`;\\n}\\x2C TypeError);\\nE('ERR_PACKAGE_PATH_NOT_EXPORTED'\\x2C (pkgPath\\x2C subpath\\x2C base = undefined) => {\\n  if (subpath === '.')\\n    return `No \"exports\" main defined in ${pkgPath}package.json${base ?\\n      ` imported from ${base}` : ''}`;\\n  return `Package subpath '${subpath}' is not defined by \"exports\" in ${\\n    pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\\n}\\x2C Error);\\nE('ERR_PERFORMANCE_INVALID_TIMESTAMP'\\x2C\\n  '%d is not a valid timestamp'\\x2C TypeError);\\nE('ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS'\\x2C '%s'\\x2C TypeError);\\nE('ERR_REQUIRE_ESM'\\x2C\\n  function(filename\\x2C hasEsmSyntax\\x2C parentPath = null\\x2C packageJsonPath = null) {\\n    hideInternalStackFrames(this);\\n    let msg = `require() of ES Module ${filename}${parentPath ? ` from ${\\n      parentPath}` : ''} not supported.`;\\n    if (!packageJsonPath) {\\n      if (StringPrototypeEndsWith(filename\\x2C '.mjs'))\\n        msg += `\\\\nInstead change the require of ${filename} to a dynamic ` +\\n            'import() which is available in all CommonJS modules.';\\n      return msg;\\n    }\\n    const path = require('path');\\n    const basename = parentPath && path.basename(filename) ===\\n      path.basename(parentPath) ? filename : path.basename(filename);\\n    if (hasEsmSyntax) {\\n      msg += `\\\\nInstead change the require of ${basename} in ${parentPath} to` +\\n        ' a dynamic import() which is available in all CommonJS modules.';\\n      return msg;\\n    }\\n    msg += `\\\\n${basename} is treated as an ES module file as it is a .js ` +\\n      'file whose nearest parent package.json contains \"type\": \"module\" ' +\\n      'which declares all .js files in that package scope as ES modules.' +\\n      `\\\\nInstead rename ${basename} to end in .cjs\\x2C change the requiring ` +\\n      'code to use dynamic import() which is available in all CommonJS ' +\\n      'modules\\x2C or change \"type\": \"module\" to \"type\": \"commonjs\" in ' +\\n      `${packageJsonPath} to treat all .js files as CommonJS (using .mjs for ` +\\n      'all ES modules instead).\\\\n';\\n    return msg;\\n  }\\x2C Error);\\nE('ERR_SCRIPT_EXECUTION_INTERRUPTED'\\x2C\\n  'Script execution was interrupted by `SIGINT`'\\x2C Error);\\nE('ERR_SERVER_ALREADY_LISTEN'\\x2C\\n  'Listen method has been called more than once without closing.'\\x2C Error);\\nE('ERR_SERVER_NOT_RUNNING'\\x2C 'Server is not running.'\\x2C Error);\\nE('ERR_SOCKET_ALREADY_BOUND'\\x2C 'Socket is already bound'\\x2C Error);\\nE('ERR_SOCKET_BAD_BUFFER_SIZE'\\x2C\\n  'Buffer size must be a positive integer'\\x2C TypeError);\\nE('ERR_SOCKET_BAD_PORT'\\x2C (name\\x2C port\\x2C allowZero = true) => {\\n  assert(typeof allowZero === 'boolean'\\x2C\\n         \"The 'allowZero' argument must be of type boolean.\");\\n  const operator = allowZero ? '>=' : '>';\\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\\n}\\x2C RangeError);\\nE('ERR_SOCKET_BAD_TYPE'\\x2C\\n  'Bad socket type specified. Valid types are: udp4\\x2C udp6'\\x2C TypeError);\\nE('ERR_SOCKET_BUFFER_SIZE'\\x2C\\n  'Could not get or set buffer size'\\x2C\\n  SystemError);\\nE('ERR_SOCKET_CLOSED'\\x2C 'Socket is closed'\\x2C Error);\\nE('ERR_SOCKET_DGRAM_IS_CONNECTED'\\x2C 'Already connected'\\x2C Error);\\nE('ERR_SOCKET_DGRAM_NOT_CONNECTED'\\x2C 'Not connected'\\x2C Error);\\nE('ERR_SOCKET_DGRAM_NOT_RUNNING'\\x2C 'Not running'\\x2C Error);\\nE('ERR_SRI_PARSE'\\x2C\\n  'Subresource Integrity string %j had an unexpected %j at position %d'\\x2C\\n  SyntaxError);\\nE('ERR_STREAM_ALREADY_FINISHED'\\x2C\\n  'Cannot call %s after a stream was finished'\\x2C\\n  Error);\\nE('ERR_STREAM_CANNOT_PIPE'\\x2C 'Cannot pipe\\x2C not readable'\\x2C Error);\\nE('ERR_STREAM_DESTROYED'\\x2C 'Cannot call %s after a stream was destroyed'\\x2C Error);\\nE('ERR_STREAM_NULL_VALUES'\\x2C 'May not write null values to stream'\\x2C TypeError);\\nE('ERR_STREAM_PREMATURE_CLOSE'\\x2C 'Premature close'\\x2C Error);\\nE('ERR_STREAM_PUSH_AFTER_EOF'\\x2C 'stream.push() after EOF'\\x2C Error);\\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT'\\x2C\\n  'stream.unshift() after end event'\\x2C Error);\\nE('ERR_STREAM_WRAP'\\x2C 'Stream has StringDecoder set or is in objectMode'\\x2C Error);\\nE('ERR_STREAM_WRITE_AFTER_END'\\x2C 'write after end'\\x2C Error);\\nE('ERR_SYNTHETIC'\\x2C 'JavaScript Callstack'\\x2C Error);\\nE('ERR_SYSTEM_ERROR'\\x2C 'A system error occurred'\\x2C SystemError);\\nE('ERR_TLS_CERT_ALTNAME_FORMAT'\\x2C 'Invalid subject alternative name string'\\x2C\\n  SyntaxError);\\nE('ERR_TLS_CERT_ALTNAME_INVALID'\\x2C function(reason\\x2C host\\x2C cert) {\\n  this.reason = reason;\\n  this.host = host;\\n  this.cert = cert;\\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\\n}\\x2C Error);\\nE('ERR_TLS_DH_PARAM_SIZE'\\x2C 'DH parameter size %s is less than 2048'\\x2C Error);\\nE('ERR_TLS_HANDSHAKE_TIMEOUT'\\x2C 'TLS handshake timeout'\\x2C Error);\\nE('ERR_TLS_INVALID_CONTEXT'\\x2C '%s must be a SecureContext'\\x2C TypeError);\\nE('ERR_TLS_INVALID_PROTOCOL_VERSION'\\x2C\\n  '%j is not a valid %s TLS protocol version'\\x2C TypeError);\\nE('ERR_TLS_INVALID_STATE'\\x2C 'TLS socket connection must be securely established'\\x2C\\n  Error);\\nE('ERR_TLS_PROTOCOL_VERSION_CONFLICT'\\x2C\\n  'TLS protocol version %j conflicts with secureProtocol %j'\\x2C TypeError);\\nE('ERR_TLS_RENEGOTIATION_DISABLED'\\x2C\\n  'TLS session renegotiation disabled for this socket'\\x2C Error);\\n\\n// This should probably be a `TypeError`.\\nE('ERR_TLS_REQUIRED_SERVER_NAME'\\x2C\\n  '\"servername\" is required parameter for Server.addContext'\\x2C Error);\\nE('ERR_TLS_SESSION_ATTACK'\\x2C 'TLS session renegotiation attack detected'\\x2C Error);\\nE('ERR_TLS_SNI_FROM_SERVER'\\x2C\\n  'Cannot issue SNI from a TLS server-side socket'\\x2C Error);\\nE('ERR_TRACE_EVENTS_CATEGORY_REQUIRED'\\x2C\\n  'At least one category is required'\\x2C TypeError);\\nE('ERR_TRACE_EVENTS_UNAVAILABLE'\\x2C 'Trace events are unavailable'\\x2C Error);\\n\\n// This should probably be a `RangeError`.\\nE('ERR_TTY_INIT_FAILED'\\x2C 'TTY initialization failed'\\x2C SystemError);\\nE('ERR_UNAVAILABLE_DURING_EXIT'\\x2C 'Cannot call function in process exit ' +\\n  'handler'\\x2C Error);\\nE('ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET'\\x2C\\n  '`process.setupUncaughtExceptionCapture()` was called while a capture ' +\\n    'callback was already active'\\x2C\\n  Error);\\nE('ERR_UNESCAPED_CHARACTERS'\\x2C '%s contains unescaped characters'\\x2C TypeError);\\nE('ERR_UNHANDLED_ERROR'\\x2C\\n  // Using a default argument here is important so the argument is not counted\\n  // towards `Function#length`.\\n  (err = undefined) => {\\n    const msg = 'Unhandled error.';\\n    if (err === undefined) return msg;\\n    return `${msg} (${err})`;\\n  }\\x2C Error);\\nE('ERR_UNKNOWN_BUILTIN_MODULE'\\x2C 'No such built-in module: %s'\\x2C Error);\\nE('ERR_UNKNOWN_CREDENTIAL'\\x2C '%s identifier does not exist: %s'\\x2C Error);\\nE('ERR_UNKNOWN_ENCODING'\\x2C 'Unknown encoding: %s'\\x2C TypeError);\\nE('ERR_UNKNOWN_FILE_EXTENSION'\\x2C\\n  'Unknown file extension \"%s\" for %s'\\x2C\\n  TypeError);\\nE('ERR_UNKNOWN_MODULE_FORMAT'\\x2C 'Unknown module format: %s'\\x2C RangeError);\\nE('ERR_UNKNOWN_SIGNAL'\\x2C 'Unknown signal: %s'\\x2C TypeError);\\nE('ERR_UNSUPPORTED_DIR_IMPORT'\\x2C \"Directory import '%s' is not supported \" +\\n'resolving ES modules imported from %s'\\x2C Error);\\nE('ERR_UNSUPPORTED_ESM_URL_SCHEME'\\x2C (url) => {\\n  let msg = 'Only file and data URLs are supported by the default ESM loader';\\n  if (isWindows && url.protocol.length === 2) {\\n    msg +=\\n      '. On Windows\\x2C absolute paths must be valid file:// URLs';\\n  }\\n  msg += `. Received protocol '${url.protocol}'`;\\n  return msg;\\n}\\x2C Error);\\n\\n// This should probably be a `TypeError`.\\nE('ERR_VALID_PERFORMANCE_ENTRY_TYPE'\\x2C\\n  'At least one valid performance entry type is required'\\x2C Error);\\nE('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING'\\x2C\\n  'A dynamic import callback was not specified.'\\x2C TypeError);\\nE('ERR_VM_MODULE_ALREADY_LINKED'\\x2C 'Module has already been linked'\\x2C Error);\\nE('ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA'\\x2C\\n  'Cached data cannot be created for a module which has been evaluated'\\x2C Error);\\nE('ERR_VM_MODULE_DIFFERENT_CONTEXT'\\x2C\\n  'Linked modules must use the same context'\\x2C Error);\\nE('ERR_VM_MODULE_LINKING_ERRORED'\\x2C\\n  'Linking has already failed for the provided module'\\x2C Error);\\nE('ERR_VM_MODULE_NOT_MODULE'\\x2C\\n  'Provided module is not an instance of Module'\\x2C Error);\\nE('ERR_VM_MODULE_STATUS'\\x2C 'Module status %s'\\x2C Error);\\nE('ERR_WASI_ALREADY_STARTED'\\x2C 'WASI instance has already started'\\x2C Error);\\nE('ERR_WORKER_INIT_FAILED'\\x2C 'Worker initialization failure: %s'\\x2C Error);\\nE('ERR_WORKER_INVALID_EXEC_ARGV'\\x2C (errors\\x2C msg = 'invalid execArgv flags') =>\\n  `Initiated Worker with ${msg}: ${ArrayPrototypeJoin(errors\\x2C '\\x2C ')}`\\x2C\\n  Error);\\nE('ERR_WORKER_NOT_RUNNING'\\x2C 'Worker instance not running'\\x2C Error);\\nE('ERR_WORKER_OUT_OF_MEMORY'\\x2C\\n  'Worker terminated due to reaching memory limit: %s'\\x2C Error);\\nE('ERR_WORKER_PATH'\\x2C (filename) =>\\n  'The worker script or module filename must " at the file end is broken
(node:2138) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2194) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2194) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.0/tick-processor.log is broken
"script-source,37,node:internal/console/constructor,'use strict';\\n\\n// The Console constructor is not actually used to construct the global\\n// console. It's exported for backwards compatibility.\\n\\nconst {\\n  ArrayFrom\\x2C\\n  ArrayIsArray\\x2C\\n  ArrayPrototypeForEach\\x2C\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypeUnshift\\x2C\\n  Boolean\\x2C\\n  ErrorCaptureStackTrace\\x2C\\n  FunctionPrototypeBind\\x2C\\n  MathFloor\\x2C\\n  Number\\x2C\\n  NumberPrototypeToFixed\\x2C\\n  ObjectCreate\\x2C\\n  ObjectDefineProperties\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  ObjectValues\\x2C\\n  ReflectApply\\x2C\\n  ReflectConstruct\\x2C\\n  ReflectOwnKeys\\x2C\\n  SafeArrayIterator\\x2C\\n  SafeMap\\x2C\\n  SafeWeakMap\\x2C\\n  StringPrototypeIncludes\\x2C\\n  StringPrototypePadStart\\x2C\\n  StringPrototypeRepeat\\x2C\\n  StringPrototypeReplace\\x2C\\n  StringPrototypeSlice\\x2C\\n  StringPrototypeSplit\\x2C\\n  Symbol\\x2C\\n  SymbolHasInstance\\x2C\\n  SymbolToStringTag\\x2C\\n} = primordials;\\n\\nconst { trace } = internalBinding('trace_events');\\nconst {\\n  isStackOverflowError\\x2C\\n  codes: {\\n    ERR_CONSOLE_WRITABLE_STREAM\\x2C\\n    ERR_INVALID_ARG_VALUE\\x2C\\n    ERR_INCOMPATIBLE_OPTION_PAIR\\x2C\\n  }\\x2C\\n} = require('internal/errors');\\nconst {\\n  validateArray\\x2C\\n  validateInteger\\x2C\\n  validateObject\\x2C\\n} = require('internal/validators');\\nconst { previewEntries } = internalBinding('util');\\nconst { Buffer: { isBuffer } } = require('buffer');\\nconst {\\n  inspect\\x2C\\n  formatWithOptions\\n} = require('internal/util/inspect');\\nconst {\\n  isTypedArray\\x2C isSet\\x2C isMap\\x2C isSetIterator\\x2C isMapIterator\\x2C\\n} = require('internal/util/types');\\nconst {\\n  CHAR_LOWERCASE_B: kTraceBegin\\x2C\\n  CHAR_LOWERCASE_E: kTraceEnd\\x2C\\n  CHAR_LOWERCASE_N: kTraceInstant\\x2C\\n  CHAR_UPPERCASE_C: kTraceCount\\x2C\\n} = require('internal/constants');\\nconst kCounts = Symbol('counts');\\n\\nconst kTraceConsoleCategory = 'node\\x2Cnode.console';\\n\\nconst kSecond = 1000;\\nconst kMinute = 60 * kSecond;\\nconst kHour = 60 * kMinute;\\nconst kMaxGroupIndentation = 1000;\\n\\n// Lazy loaded for startup performance.\\nlet cliTable;\\n\\n// Track amount of indentation required via `console.group()`.\\nconst kGroupIndent = Symbol('kGroupIndent');\\nconst kGroupIndentationWidth = Symbol('kGroupIndentWidth');\\nconst kFormatForStderr = Symbol('kFormatForStderr');\\nconst kFormatForStdout = Symbol('kFormatForStdout');\\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\\nconst kColorMode = Symbol('kColorMode');\\nconst kIsConsole = Symbol('kIsConsole');\\nconst kWriteToConsole = Symbol('kWriteToConsole');\\nconst kBindProperties = Symbol('kBindProperties');\\nconst kBindStreamsEager = Symbol('kBindStreamsEager');\\nconst kBindStreamsLazy = Symbol('kBindStreamsLazy');\\nconst kUseStdout = Symbol('kUseStdout');\\nconst kUseStderr = Symbol('kUseStderr');\\n\\nconst optionsMap = new SafeWeakMap();\\n\\nfunction Console(options /* or: stdout\\x2C stderr\\x2C ignoreErrors = true */) {\\n  // We have to test new.target here to see if this function is called\\n  // with new\\x2C because we need to define a custom instanceof to accommodate\\n  // the global console.\\n  if (!new.target) {\\n    return ReflectConstruct(Console\\x2C arguments);\\n  }\\n\\n  if (!options || typeof options.write === 'function') {\\n    options = {\\n      stdout: options\\x2C\\n      stderr: arguments[1]\\x2C\\n      ignoreErrors: arguments[2]\\n    };\\n  }\\n\\n  const {\\n    stdout\\x2C\\n    stderr = stdout\\x2C\\n    ignoreErrors = true\\x2C\\n    colorMode = 'auto'\\x2C\\n    inspectOptions\\x2C\\n    groupIndentation\\x2C\\n  } = options;\\n\\n  if (!stdout || typeof stdout.write !== 'function') {\\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\\n  }\\n  if (!stderr || typeof stderr.write !== 'function') {\\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\\n  }\\n\\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\\n    throw new ERR_INVALID_ARG_VALUE('colorMode'\\x2C colorMode);\\n\\n  if (groupIndentation !== undefined) {\\n    validateInteger(groupIndentation\\x2C 'groupIndentation'\\x2C\\n                    0\\x2C kMaxGroupIndentation);\\n  }\\n\\n  if (inspectOptions !== undefined) {\\n    validateObject(inspectOptions\\x2C 'options.inspectOptions');\\n\\n    if (inspectOptions.colors !== undefined &&\\n        options.colorMode !== undefined) {\\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\\n        'options.inspectOptions.color'\\x2C 'colorMode');\\n    }\\n    optionsMap.set(this\\x2C inspectOptions);\\n  }\\n\\n  // Bind the prototype functions to this Console instance\\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype)\\x2C (key) => {\\n    // We have to bind the methods grabbed from the instance instead of from\\n    // the prototype so that users extending the Console can override them\\n    // from the prototype chain of the subclass.\\n    this[key] = FunctionPrototypeBind(this[key]\\x2C this);\\n    ObjectDefineProperty(this[key]\\x2C 'name'\\x2C {\\n      value: key\\n    });\\n  });\\n\\n  this[kBindStreamsEager](stdout\\x2C stderr);\\n  this[kBindProperties](ignoreErrors\\x2C colorMode\\x2C groupIndentation);\\n}\\n\\nconst consolePropAttributes = {\\n  writable: true\\x2C\\n  enumerable: false\\x2C\\n  configurable: true\\n};\\n\\n// Fixup global.console instanceof global.console.Console\\nObjectDefineProperty(Console\\x2C SymbolHasInstance\\x2C {\\n  value(instance) {\\n    return instance[kIsConsole];\\n  }\\n});\\n\\nconst kColorInspectOptions = { colors: true };\\nconst kNoColorInspectOptions = {};\\n\\nObjectDefineProperties(Console.prototype\\x2C {\\n  [kBindStreamsEager]: {\\n    ...consolePropAttributes\\x2C\\n    // Eager version for the Console constructor\\n    value: function(stdout\\x2C stderr) {\\n      ObjectDefineProperties(this\\x2C {\\n        '_stdout': { ...consolePropAttributes\\x2C value: stdout }\\x2C\\n        '_stderr': { ...consolePropAttributes\\x2C value: stderr }\\n      });\\n    }\\n  }\\x2C\\n  [kBindStreamsLazy]: {\\n    ...consolePropAttributes\\x2C\\n    // Lazily load the stdout and stderr from an object so we don't\\n    // create the stdio streams when they are not even accessed\\n    value: function(object) {\\n      let stdout;\\n      let stderr;\\n      ObjectDefineProperties(this\\x2C {\\n        '_stdout': {\\n          enumerable: false\\x2C\\n          configurable: true\\x2C\\n          get() {\\n            if (!stdout) stdout = object.stdout;\\n            return stdout;\\n          }\\x2C\\n          set(value) { stdout = value; }\\n        }\\x2C\\n        '_stderr': {\\n          enumerable: false\\x2C\\n          configurable: true\\x2C\\n          get() {\\n            if (!stderr) { stderr = object.stderr; }\\n            return stderr;\\n          }\\x2C\\n          set(value) { stderr = value; }\\n        }\\n      });\\n    }\\n  }\\x2C\\n  [kBindProperties]: {\\n    ...consolePropAttributes\\x2C\\n    value: function(ignoreErrors\\x2C colorMode\\x2C groupIndentation = 2) {\\n      ObjectDefineProperties(this\\x2C {\\n        '_stdoutErrorHandler': {\\n          ...consolePropAttributes\\x2C\\n          value: createWriteErrorHandler(this\\x2C kUseStdout)\\n        }\\x2C\\n        '_stderrErrorHandler': {\\n          ...consolePropAttributes\\x2C\\n          value: createWriteErrorHandler(this\\x2C kUseStderr)\\n        }\\x2C\\n        '_ignoreErrors': {\\n          ...consolePropAttributes\\x2C\\n          value: Boolean(ignoreErrors)\\n        }\\x2C\\n        '_times': { ...consolePropAttributes\\x2C value: new SafeMap() }\\x2C\\n        // Corresponds to https://console.spec.whatwg.org/#count-map\\n        [kCounts]: { ...consolePropAttributes\\x2C value: new SafeMap() }\\x2C\\n        [kColorMode]: { ...consolePropAttributes\\x2C value: colorMode }\\x2C\\n        [kIsConsole]: { ...consolePropAttributes\\x2C value: true }\\x2C\\n        [kGroupIndent]: { ...consolePropAttributes\\x2C value: '' }\\x2C\\n        [kGroupIndentationWidth]: {\\n          ...consolePropAttributes\\x2C\\n          value: groupIndentation\\n        }\\x2C\\n        [SymbolToStringTag]: {\\n          writable: false\\x2C\\n          enumerable: false\\x2C\\n          configurable: true\\x2C\\n          value: 'console'\\n        }\\n      });\\n    }\\n  }\\x2C\\n  [kWriteToConsole]: {\\n    ...consolePropAttributes\\x2C\\n    value: function(streamSymbol\\x2C string) {\\n      const ignoreErrors = this._ignoreErrors;\\n      const groupIndent = this[kGroupIndent];\\n\\n      const useStdout = streamSymbol === kUseStdout;\\n      const stream = useStdout ? this._stdout : this._stderr;\\n      const errorHandler = useStdout ?\\n        this._stdoutErrorHandler : this._stderrErrorHandler;\\n\\n      if (groupIndent.length !== 0) {\\n        if (StringPrototypeIncludes(string\\x2C '\\\\n')) {\\n          string = StringPrototypeReplace(string\\x2C /\\\\n/g\\x2C `\\\\n${groupIndent}`);\\n        }\\n        string = groupIndent + string;\\n      }\\n      string += '\\\\n';\\n\\n      if (ignoreErrors === false) return stream.write(string);\\n\\n      // There may be an error occurring synchronously (e.g. for files or TTYs\\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems)\\x2C so\\n      // handle both situations.\\n      try {\\n        // Add and later remove a noop error handler to catch synchronous\\n        // errors.\\n        if (stream.listenerCount('error') === 0)\\n          stream.once('error'\\x2C noop);\\n\\n        stream.write(string\\x2C errorHandler);\\n      } catch (e) {\\n        // Console is a debugging utility\\x2C so it swallowing errors is not\\n        // desirable even in edge cases such as low stack space.\\n        if (isStackOverflowError(e))\\n          throw e;\\n        // Sorry\\x2C there's no proper way to pass along the error here.\\n      } finally {\\n        stream.removeListener('error'\\x2C noop);\\n      }\\n    }\\n  }\\x2C\\n  [kGetInspectOptions]: {\\n    ...consolePropAttributes\\x2C\\n    value: function(stream) {\\n      let color = this[kColorMode];\\n      if (color === 'auto') {\\n        color = stream.isTTY && (\\n          typeof stream.getColorDepth === 'function' ?\\n            stream.getColorDepth() > 2 : true);\\n      }\\n\\n      const options = optionsMap.get(this);\\n      if (options) {\\n        if (options.colors === undefined) {\\n          options.colors = color;\\n        }\\n        return options;\\n      }\\n\\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\\n    }\\n  }\\x2C\\n  [kFormatForStdout]: {\\n    ...consolePropAttributes\\x2C\\n    value: function(args) {\\n      const opts = this[kGetInspectOptions](this._stdout);\\n      ArrayPrototypeUnshift(args\\x2C opts);\\n      return ReflectApply(formatWithOptions\\x2C null\\x2C args);\\n    }\\n  }\\x2C\\n  [kFormatForStderr]: {\\n    ...consolePropAttributes\\x2C\\n    value: function(args) {\\n      const opts = this[kGetInspectOptions](this._stderr);\\n      ArrayPrototypeUnshift(args\\x2C opts);\\n      return ReflectApply(formatWithOptions\\x2C null\\x2C args);\\n    }\\n  }\\x2C\\n});\\n\\n// Make a function that can serve as the callback passed to `stream.write()`.\\nfunction createWriteErrorHandler(instance\\x2C streamSymbol) {\\n  return (err) => {\\n    // This conditional evaluates to true if and only if there was an error\\n    // that was not already emitted (which happens when the _write callback\\n    // is invoked asynchronously).\\n    const stream = streamSymbol === kUseStdout ?\\n      instance._stdout : instance._stderr;\\n    if (err !== null && !stream._writableState.errorEmitted) {\\n      // If there was an error\\x2C it will be emitted on `stream` as\\n      // an `error` event. Adding a `once` listener will keep that error\\n      // from becoming an uncaught exception\\x2C but since the handler is\\n      // removed after the event\\x2C non-console.* writes won't be affected.\\n      // we are only adding noop if there is no one else listening for 'error'\\n      if (stream.listenerCount('error') === 0) {\\n        stream.once('error'\\x2C noop);\\n      }\\n    }\\n  };\\n}\\n\\nconst consoleMethods = {\\n  log(...args) {\\n    this[kWriteToConsole](kUseStdout\\x2C this[kFormatForStdout](args));\\n  }\\x2C\\n\\n\\n  warn(...args) {\\n    this[kWriteToConsole](kUseStderr\\x2C this[kFormatForStderr](args));\\n  }\\x2C\\n\\n\\n  dir(object\\x2C options) {\\n    this[kWriteToConsole](kUseStdout\\x2C inspect(object\\x2C {\\n      customInspect: false\\x2C\\n      ...this[kGetInspectOptions](this._stdout)\\x2C\\n      ...options\\n    }));\\n  }\\x2C\\n\\n  time(label = 'default') {\\n    // Coerces everything other than Symbol to a string\\n    label = `${label}`;\\n    if (this._times.has(label)) {\\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\\n      return;\\n    }\\n    trace(kTraceBegin\\x2C kTraceConsoleCategory\\x2C `time::${label}`\\x2C 0);\\n    this._times.set(label\\x2C process.hrtime());\\n  }\\x2C\\n\\n  timeEnd(label = 'default') {\\n    // Coerces everything other than Symbol to a string\\n    label = `${label}`;\\n    const found = timeLogImpl(this\\x2C 'timeEnd'\\x2C label);\\n    trace(kTraceEnd\\x2C kTraceConsoleCategory\\x2C `time::${label}`\\x2C 0);\\n    if (found) {\\n      this._times.delete(label);\\n    }\\n  }\\x2C\\n\\n  timeLog(label = 'default'\\x2C ...data) {\\n    // Coerces everything other than Symbol to a string\\n    label = `${label}`;\\n    timeLogImpl(this\\x2C 'timeLog'\\x2C label\\x2C data);\\n    trace(kTraceInstant\\x2C kTraceConsoleCategory\\x2C `time::${label}`\\x2C 0);\\n  }\\x2C\\n\\n  trace: function trace(...args) {\\n    const err = {\\n      name: 'Trace'\\x2C\\n      message: this[kFormatForStderr](args)\\n    };\\n    ErrorCaptureStackTrace(err\\x2C trace);\\n    this.error(err.stack);\\n  }\\x2C\\n\\n  assert(expression\\x2C ...args) {\\n    if (!expression) {\\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\\n      // The arguments will be formatted in warn() again\\n      ReflectApply(this.warn\\x2C this\\x2C args);\\n    }\\n  }\\x2C\\n\\n  // Defined by: https://console.spec.whatwg.org/#clear\\n  clear() {\\n    // It only makes sense to clear if _stdout is a TTY.\\n    // Otherwise\\x2C do nothing.\\n    if (this._stdout.isTTY && process.env.TERM !== 'dumb') {\\n      // The require is here intentionally to avoid readline being\\n      // required too early when console is first loaded.\\n      const {\\n        cursorTo\\x2C\\n        clearScreenDown\\x2C\\n      } = require('internal/readline/callbacks');\\n      cursorTo(this._stdout\\x2C 0\\x2C 0);\\n      clearScreenDown(this._stdout);\\n    }\\n  }\\x2C\\n\\n  // Defined by: https://console.spec.whatwg.org/#count\\n  count(label = 'default') {\\n    // Ensures that label is a string\\x2C and only things that can be\\n    // coerced to strings. e.g. Symbol is not allowed\\n    label = `${label}`;\\n    const counts = this[kCounts];\\n    let count = counts.get(label);\\n    if (count === undefined)\\n      count = 1;\\n    else\\n      count++;\\n    counts.set(label\\x2C count);\\n    trace(kTraceCount\\x2C kTraceConsoleCategory\\x2C `count::${label}`\\x2C 0\\x2C count);\\n    this.log(`${label}: ${count}`);\\n  }\\x2C\\n\\n  // Defined by: https://console.spec.whatwg.org/#countreset\\n  countReset(label = 'default') {\\n    const counts = this[kCounts];\\n    if (!counts.has(label)) {\\n      process.emitWarning(`Count for '${label}' does not exist`);\\n      return;\\n    }\\n    trace(kTraceCount\\x2C kTraceConsoleCategory\\x2C `count::${label}`\\x2C 0\\x2C 0);\\n    counts.delete(`${label}`);\\n  }\\x2C\\n\\n  group(...data) {\\n    if (data.length > 0) {\\n      ReflectApply(this.log\\x2C this\\x2C data);\\n    }\\n    this[kGroupIndent] +=\\n      StringPrototypeRepeat(' '\\x2C this[kGroupIndentationWidth]);\\n  }\\x2C\\n\\n  groupEnd() {\\n    this[kGroupIndent] = StringPrototypeSlice(\\n      this[kGroupIndent]\\x2C\\n      0\\x2C\\n      this[kGroupIndent].length - this[kGroupIndentationWidth]\\n    );\\n  }\\x2C\\n\\n  // https://console.spec.whatwg.org/#table\\n  table(tabularData\\x2C properties) {\\n    if (properties !== undefined)\\n      validateArray(properties\\x2C 'properties');\\n\\n    if (tabularData === null || typeof tabularData !== 'object')\\n      return this.log(tabularData);\\n\\n    if (cliTable === undefined) cliTable = require('internal/cli_table');\\n    const final = (k\\x2C v) => this.log(cliTable(k\\x2C v));\\n\\n    const _inspect = (v) => {\\n      const depth = v !== null &&\\n                    typeof v === 'object' &&\\n                    !isArray(v) &&\\n                    ObjectKeys(v).length > 2 ? -1 : 0;\\n      const opt = {\\n        depth\\x2C\\n        maxArrayLength: 3\\x2C\\n        breakLength: Infinity\\x2C\\n        ...this[kGetInspectOptions](this._stdout)\\n      };\\n      return inspect(v\\x2C opt);\\n    };\\n    const getIndexArray = (length) => ArrayFrom(\\n      { length }\\x2C (_\\x2C i) => _inspect(i));\\n\\n    const mapIter = isMapIterator(tabularData);\\n    let isKeyValue = false;\\n    let i = 0;\\n    if (mapIter) {\\n      const res = previewEntries(tabularData\\x2C true);\\n      tabularData = res[0];\\n      isKeyValue = res[1];\\n    }\\n\\n    if (isKeyValue || isMap(tabularData)) {\\n      const keys = [];\\n      const values = [];\\n      let length = 0;\\n      if (mapIter) {\\n        for (; i < tabularData.length / 2; ++i) {\\n          ArrayPrototypePush(keys\\x2C _inspect(tabularData[i * 2]));\\n          ArrayPrototypePush(values\\x2C _inspect(tabularData[i * 2 + 1]));\\n          len" at the file end is broken
(node:2250) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2250) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.0/tick-processor.log is broken
"script-source,52,node:internal/streams/pipeline,// Ported from https://github.com/mafintosh/pump with\\n// permission from the author\\x2C Mathias Buus (@mafintosh).\\n\\n'use strict';\\n\\nconst {\\n  ArrayIsArray\\x2C\\n  Promise\\x2C\\n  SymbolAsyncIterator\\x2C\\n} = primordials;\\n\\nconst eos = require('internal/streams/end-of-stream');\\nconst { once } = require('internal/util');\\nconst destroyImpl = require('internal/streams/destroy');\\nconst Duplex = require('internal/streams/duplex');\\nconst {\\n  aggregateTwoErrors\\x2C\\n  codes: {\\n    ERR_INVALID_ARG_TYPE\\x2C\\n    ERR_INVALID_RETURN_VALUE\\x2C\\n    ERR_MISSING_ARGS\\x2C\\n    ERR_STREAM_DESTROYED\\x2C\\n  }\\x2C\\n  AbortError\\x2C\\n} = require('internal/errors');\\n\\nconst {\\n  validateCallback\\x2C\\n  validateAbortSignal\\n} = require('internal/validators');\\n\\nconst {\\n  isIterable\\x2C\\n  isReadableNodeStream\\x2C\\n  isNodeStream\\x2C\\n  isReadableFinished\\x2C\\n} = require('internal/streams/utils');\\nconst { AbortController } = require('internal/abort_controller');\\n\\nlet PassThrough;\\nlet Readable;\\n\\nfunction destroyer(stream\\x2C reading\\x2C writing\\x2C callback) {\\n  callback = once(callback);\\n\\n  let finished = false;\\n  stream.on('close'\\x2C () => {\\n    finished = true;\\n  });\\n\\n  eos(stream\\x2C { readable: reading\\x2C writable: writing }\\x2C (err) => {\\n    finished = !err;\\n\\n    const rState = stream._readableState;\\n    if (\\n      err &&\\n      err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\\n      reading &&\\n      (rState && rState.ended && !rState.errored && !rState.errorEmitted)\\n    ) {\\n      // Some readable streams will emit 'close' before 'end'. However\\x2C since\\n      // this is on the readable side 'end' should still be emitted if the\\n      // stream has been ended and no error emitted. This should be allowed in\\n      // favor of backwards compatibility. Since the stream is piped to a\\n      // destination this should not result in any observable difference.\\n      // We don't need to check if this is a writable premature close since\\n      // eos will only fail with premature close on the reading side for\\n      // duplex streams.\\n      stream\\n        .once('end'\\x2C callback)\\n        .once('error'\\x2C callback);\\n    } else {\\n      callback(err);\\n    }\\n  });\\n\\n  return (err) => {\\n    if (finished) return;\\n    finished = true;\\n    destroyImpl.destroyer(stream\\x2C err);\\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\\n  };\\n}\\n\\nfunction popCallback(streams) {\\n  // Streams should never be an empty array. It should always contain at least\\n  // a single stream. Therefore optimize for the average case instead of\\n  // checking for length === 0 as well.\\n  validateCallback(streams[streams.length - 1]);\\n  return streams.pop();\\n}\\n\\nfunction makeAsyncIterable(val) {\\n  if (isIterable(val)) {\\n    return val;\\n  } else if (isReadableNodeStream(val)) {\\n    // Legacy streams are not Iterable.\\n    return fromReadable(val);\\n  }\\n  throw new ERR_INVALID_ARG_TYPE(\\n    'val'\\x2C ['Readable'\\x2C 'Iterable'\\x2C 'AsyncIterable']\\x2C val);\\n}\\n\\nasync function* fromReadable(val) {\\n  if (!Readable) {\\n    Readable = require('internal/streams/readable');\\n  }\\n\\n  yield* Readable.prototype[SymbolAsyncIterator].call(val);\\n}\\n\\nasync function pump(iterable\\x2C writable\\x2C finish\\x2C opts) {\\n  let error;\\n  let onresolve = null;\\n\\n" at the file end is broken
(node:2306) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2306) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.0/tick-processor.log is broken
"tick,0x3fbf2f1c70,66066735,1,0x3fbe9c7550,3,0x0," at the file end is broken
(node:2362) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2362) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.0/tick-processor.log is broken
"tick,0x3fbd6d6e9c,81940109,1," at the file end is broken
(node:2418) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
Command: out/Release/node /root/rpmbuild/BUILD/node-v16.14.2/test/tick-processor/test-tick-processor-builtin.js
--- TIMEOUT ---
=== release test-tick-processor-cpp-core ===                   
Path: tick-processor/test-tick-processor-cpp-core
(node:2487) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
(node:2496) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
(node:2496) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.1/tick-processor.log is broken
"tick,0x3fd2910d44,3127625,0," at the file end is broken
(node:2553) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2553) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.1/tick-processor.log is broken
"script-source,11,node:internal/errors,/* eslint node-core/documented-errors: \"error\" */\\n/* eslint node-core/alphabetize-errors: \"error\" */\\n/* eslint node-core/prefer-util-format-errors: \"error\" */\\n\\n'use strict';\\n\\n// The whole point behind this internal module is to allow Node.js to no\\n// longer be forced to treat every error message change as a semver-major\\n// change. The NodeError classes here all expose a `code` property whose\\n// value statically and permanently identifies the error. While the error\\n// message may change\\x2C the code should not.\\n\\nconst {\\n  AggregateError\\x2C\\n  ArrayFrom\\x2C\\n  ArrayIsArray\\x2C\\n  ArrayPrototypeFilter\\x2C\\n  ArrayPrototypeIncludes\\x2C\\n  ArrayPrototypeIndexOf\\x2C\\n  ArrayPrototypeJoin\\x2C\\n  ArrayPrototypeMap\\x2C\\n  ArrayPrototypePop\\x2C\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypeSlice\\x2C\\n  ArrayPrototypeSplice\\x2C\\n  ArrayPrototypeUnshift\\x2C\\n  Error\\x2C\\n  ErrorCaptureStackTrace\\x2C\\n  ErrorPrototypeToString\\x2C\\n  JSONStringify\\x2C\\n  MapPrototypeGet\\x2C\\n  MathAbs\\x2C\\n  MathMax\\x2C\\n  Number\\x2C\\n  NumberIsInteger\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectDefineProperties\\x2C\\n  ObjectIsExtensible\\x2C\\n  ObjectGetOwnPropertyDescriptor\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  RangeError\\x2C\\n  ReflectApply\\x2C\\n  RegExpPrototypeTest\\x2C\\n  SafeArrayIterator\\x2C\\n  SafeMap\\x2C\\n  SafeWeakMap\\x2C\\n  String\\x2C\\n  StringPrototypeEndsWith\\x2C\\n  StringPrototypeIncludes\\x2C\\n  StringPrototypeMatch\\x2C\\n  StringPrototypeSlice\\x2C\\n  StringPrototypeSplit\\x2C\\n  StringPrototypeStartsWith\\x2C\\n  StringPrototypeToLowerCase\\x2C\\n  Symbol\\x2C\\n  SymbolFor\\x2C\\n  SyntaxError\\x2C\\n  TypeError\\x2C\\n  URIError\\x2C\\n} = primordials;\\n\\nconst kIsNodeError = Symbol('kIsNodeError');\\n\\nconst isWindows = process.platform === 'win32';\\n\\nconst messages = new SafeMap();\\nconst codes = {};\\n\\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\\n// Sorted by a rough estimate on most frequently used entries.\\nconst kTypes = [\\n  'string'\\x2C\\n  'function'\\x2C\\n  'number'\\x2C\\n  'object'\\x2C\\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\\n  'Function'\\x2C\\n  'Object'\\x2C\\n  'boolean'\\x2C\\n  'bigint'\\x2C\\n  'symbol'\\x2C\\n];\\n\\nconst MainContextError = Error;\\nconst overrideStackTrace = new SafeWeakMap();\\nconst kNoOverride = Symbol('kNoOverride');\\nlet userStackTraceLimit;\\nconst nodeInternalPrefix = '__node_internal_';\\nconst prepareStackTrace = (globalThis\\x2C error\\x2C trace) => {\\n  // API for node internals to override error stack formatting\\n  // without interfering with userland code.\\n  if (overrideStackTrace.has(error)) {\\n    const f = overrideStackTrace.get(error);\\n    overrideStackTrace.delete(error);\\n    return f(error\\x2C trace);\\n  }\\n\\n  const firstFrame = trace[0]?.getFunctionName();\\n  if (firstFrame && StringPrototypeStartsWith(firstFrame\\x2C nodeInternalPrefix)) {\\n    for (let l = trace.length - 1; l >= 0; l--) {\\n      const fn = trace[l]?.getFunctionName();\\n      if (fn && StringPrototypeStartsWith(fn\\x2C nodeInternalPrefix)) {\\n        ArrayPrototypeSplice(trace\\x2C 0\\x2C l + 1);\\n        break;\\n      }\\n    }\\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`\\x2C\\n    // it is updated at every new exception in `captureLargerStackTrace`.\\n    if (trace.length > userStackTraceLimit)\\n      ArrayPrototypeSplice(trace\\x2C userStackTraceLimit);\\n  }\\n\\n  const globalOverride =\\n    maybeOverridePrepareStackTrace(globalThis\\x2C error\\x2C trace);\\n  if (globalOverride !== kNoOverride) return globalOverride;\\n\\n  // Normal error formatting:\\n  //\\n  // Error: Message\\n  //     at function (file)\\n  //     at file\\n  let errorString;\\n  if (kIsNodeError in error) {\\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\\n  } else {\\n    errorString = ErrorPrototypeToString(error);\\n  }\\n  if (trace.length === 0) {\\n    return errorString;\\n  }\\n  return `${errorString}\\\\n    at ${ArrayPrototypeJoin(trace\\x2C '\\\\n    at ')}`;\\n};\\n\\nconst maybeOverridePrepareStackTrace = (globalThis\\x2C error\\x2C trace) => {\\n  // Polyfill of V8's Error.prepareStackTrace API.\\n  // https://crbug.com/v8/7848\\n  // `globalThis` is the global that contains the constructor which\\n  // created `error`.\\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\\n    return globalThis.Error.prepareStackTrace(error\\x2C trace);\\n  }\\n  // We still have legacy usage that depends on the main context's `Error`\\n  // being used\\x2C even when the error is from a different context.\\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\\n  if (typeof MainContextError.prepareStackTrace === 'function') {\\n    return MainContextError.prepareStackTrace(error\\x2C trace);\\n  }\\n\\n  return kNoOverride;\\n};\\n\\nconst aggregateTwoErrors = hideStackFrames((innerError\\x2C outerError) => {\\n  if (innerError && outerError) {\\n    if (ArrayIsArray(outerError.errors)) {\\n      // If `outerError` is already an `AggregateError`.\\n      ArrayPrototypePush(outerError.errors\\x2C innerError);\\n      return outerError;\\n    }\\n    // eslint-disable-next-line no-restricted-syntax\\n    const err = new AggregateError(new SafeArrayIterator([\\n      outerError\\x2C\\n      innerError\\x2C\\n    ])\\x2C outerError.message);\\n    err.code = outerError.code;\\n    return err;\\n  }\\n  return innerError || outerError;\\n});\\n\\n// Lazily loaded\\nlet util;\\nlet assert;\\n\\nlet internalUtil = null;\\nfunction lazyInternalUtil() {\\n  if (!internalUtil) {\\n    internalUtil = require('internal/util');\\n  }\\n  return internalUtil;\\n}\\n\\nlet internalUtilInspect = null;\\nfunction lazyInternalUtilInspect() {\\n  if (!internalUtilInspect) {\\n    internalUtilInspect = require('internal/util/inspect');\\n  }\\n  return internalUtilInspect;\\n}\\n\\nlet buffer;\\nfunction lazyBuffer() {\\n  if (buffer === undefined)\\n    buffer = require('buffer').Buffer;\\n  return buffer;\\n}\\n\\nfunction isErrorStackTraceLimitWritable() {\\n  const desc = ObjectGetOwnPropertyDescriptor(Error\\x2C 'stackTraceLimit');\\n  if (desc === undefined) {\\n    return ObjectIsExtensible(Error);\\n  }\\n\\n  return ObjectPrototypeHasOwnProperty(desc\\x2C 'writable') ?\\n    desc.writable :\\n    desc.set !== undefined;\\n}\\n\\n// A specialized Error that includes an additional info property with\\n// additional information about the error condition.\\n// It has the properties present in a UVException but with a custom error\\n// message followed by the uv error code and uv error message.\\n// It also has its own error code with the original uv error context put into\\n// `err.info`.\\n// The context passed into this error must have .code\\x2C .syscall and .message\\x2C\\n// and may have .path and .dest.\\nclass SystemError extends Error {\\n  constructor(key\\x2C context) {\\n    const limit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    super();\\n    // Reset the limit and setting the name property.\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\\n    const prefix = getMessage(key\\x2C []\\x2C this);\\n    let message = `${prefix}: ${context.syscall} returned ` +\\n                  `${context.code} (${context.message})`;\\n\\n    if (context.path !== undefined)\\n      message += ` ${context.path}`;\\n    if (context.dest !== undefined)\\n      message += ` => ${context.dest}`;\\n\\n    captureLargerStackTrace(this);\\n\\n    this.code = key;\\n\\n    ObjectDefineProperties(this\\x2C {\\n      [kIsNodeError]: {\\n        value: true\\x2C\\n        enumerable: false\\x2C\\n        writable: false\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      name: {\\n        value: 'SystemError'\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      message: {\\n        value: message\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      info: {\\n        value: context\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n        writable: false\\x2C\\n      }\\x2C\\n      errno: {\\n        get() {\\n          return context.errno;\\n        }\\x2C\\n        set: (value) => {\\n          context.errno = value;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      syscall: {\\n        get() {\\n          return context.syscall;\\n        }\\x2C\\n        set: (value) => {\\n          context.syscall = value;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n    });\\n\\n    if (context.path !== undefined) {\\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\\n      // introduced. The `path` and `dest` properties in the context seem to\\n      // always be of type string. We should probably just remove the\\n      // `.toString()` and `Buffer.from()` operations and set the value on the\\n      // context as the user did.\\n      ObjectDefineProperty(this\\x2C 'path'\\x2C {\\n        get() {\\n          return context.path != null ?\\n            context.path.toString() : context.path;\\n        }\\x2C\\n        set: (value) => {\\n          context.path = value ?\\n            lazyBuffer().from(value.toString()) : undefined;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\n      });\\n    }\\n\\n    if (context.dest !== undefined) {\\n      ObjectDefineProperty(this\\x2C 'dest'\\x2C {\\n        get() {\\n          return context.dest != null ?\\n            context.dest.toString() : context.dest;\\n        }\\x2C\\n        set: (value) => {\\n          context.dest = value ?\\n            lazyBuffer().from(value.toString()) : undefined;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\n      });\\n    }\\n  }\\n\\n  toString() {\\n    return `${this.name} [${this.code}]: ${this.message}`;\\n  }\\n\\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes\\x2C ctx) {\\n    return lazyInternalUtilInspect().inspect(this\\x2C {\\n      ...ctx\\x2C\\n      getters: true\\x2C\\n      customInspect: false\\n    });\\n  }\\n}\\n\\nfunction makeSystemErrorWithCode(key) {\\n  return class NodeError extends SystemError {\\n    constructor(ctx) {\\n      super(key\\x2C ctx);\\n    }\\n  };\\n}\\n\\nfunction makeNodeErrorWithCode(Base\\x2C key) {\\n  return function NodeError(...args) {\\n    const limit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    const error = new Base();\\n    // Reset the limit and setting the name property.\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\\n    const message = getMessage(key\\x2C args\\x2C error);\\n    ObjectDefineProperties(error\\x2C {\\n      [kIsNodeError]: {\\n        value: true\\x2C\\n        enumerable: false\\x2C\\n        writable: false\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      message: {\\n        value: message\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      toString: {\\n        value() {\\n          return `${this.name} [${key}]: ${this.message}`;\\n        }\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n    });\\n    captureLargerStackTrace(error);\\n    error.code = key;\\n    return error;\\n  };\\n}\\n\\n/**\\n * This function removes unnecessary frames from Node.js core errors.\\n * @template {(...args: any[]) => any} T\\n * @type {(fn: T) => T}\\n */\\nfunction hideStackFrames(fn) {\\n  // We rename the functions that will be hidden to cut off the stacktrace\\n  // at the outermost one\\n  const hidden = nodeInternalPrefix + fn.name;\\n  ObjectDefineProperty(fn\\x2C 'name'\\x2C { value: hidden });\\n  return fn;\\n}\\n\\n// Utility function for registering the error codes. Only used here. Exported\\n// *only* to allow for testing.\\nfunction E(sym\\x2C val\\x2C def\\x2C ...otherClasses) {\\n  // Special case for SystemError that formats the error message differently\\n  // The SystemErrors only have SystemError as their base classes.\\n  messages.set(sym\\x2C val);\\n  if (def === SystemError) {\\n    def = makeSystemErrorWithCode(sym);\\n  } else {\\n    def = makeNodeErrorWithCode(def\\x2C sym);\\n  }\\n\\n  if (otherClasses.length !== 0) {\\n    otherClasses.forEach((clazz) => {\\n      def[clazz.name] = makeNodeErrorWithCode(clazz\\x2C sym);\\n    });\\n  }\\n  codes[sym] = def;\\n}\\n\\nfunction getMessage(key\\x2C args\\x2C self) {\\n  const msg = messages.get(key);\\n\\n  if (assert === undefined) assert = require('internal/assert');\\n\\n  if (typeof msg === 'function') {\\n    assert(\\n      msg.length <= args.length\\x2C // Default options do not count.\\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\\n        `match the required ones (${msg.length}).`\\n    );\\n    return ReflectApply(msg\\x2C self\\x2C args);\\n  }\\n\\n  const expectedLength =\\n    (StringPrototypeMatch(msg\\x2C /%[dfijoOs]/g) || []).length;\\n  assert(\\n    expectedLength === args.length\\x2C\\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\\n      `match the required ones (${expectedLength}).`\\n  );\\n  if (args.length === 0)\\n    return msg;\\n\\n  ArrayPrototypeUnshift(args\\x2C msg);\\n  return ReflectApply(lazyInternalUtilInspect().format\\x2C null\\x2C args);\\n}\\n\\nlet uvBinding;\\n\\nfunction lazyUv() {\\n  if (!uvBinding) {\\n    uvBinding = internalBinding('uv');\\n  }\\n  return uvBinding;\\n}\\n\\nconst uvUnmappedError = ['UNKNOWN'\\x2C 'unknown error'];\\n\\nfunction uvErrmapGet(name) {\\n  uvBinding = lazyUv();\\n  if (!uvBinding.errmap) {\\n    uvBinding.errmap = uvBinding.getErrorMap();\\n  }\\n  return MapPrototypeGet(uvBinding.errmap\\x2C name);\\n}\\n\\nconst captureLargerStackTrace = hideStackFrames(\\n  function captureLargerStackTrace(err) {\\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\\n    if (stackTraceLimitIsWritable) {\\n      userStackTraceLimit = Error.stackTraceLimit;\\n      Error.stackTraceLimit = Infinity;\\n    }\\n    ErrorCaptureStackTrace(err);\\n    // Reset the limit\\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\\n\\n    return err;\\n  });\\n\\n/**\\n * This creates an error compatible with errors produced in the C++\\n * function UVException using a context object with data assembled in C++.\\n * The goal is to migrate them to ERR_* errors later when compatibility is\\n * not a concern.\\n *\\n * @param {object} ctx\\n * @returns {Error}\\n */\\nconst uvException = hideStackFrames(function uvException(ctx) {\\n  const { 0: code\\x2C 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\\n  let message = `${code}: ${ctx.message || uvmsg}\\x2C ${ctx.syscall}`;\\n\\n  let path;\\n  let dest;\\n  if (ctx.path) {\\n    path = ctx.path.toString();\\n    message += ` '${path}'`;\\n  }\\n  if (ctx.dest) {\\n    dest = ctx.dest.toString();\\n    message += ` -> '${dest}'`;\\n  }\\n\\n  // Reducing the limit improves the performance significantly. We do not lose\\n  // the stack frames due to the `captureStackTrace()` function that is called\\n  // later.\\n  const tmpLimit = Error.stackTraceLimit;\\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n  // Pass the message to the constructor instead of setting it on the object\\n  // to make sure it is the same as the one created in C++\\n  // eslint-disable-next-line no-restricted-syntax\\n  const err = new Error(message);\\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n\\n  for (const prop of ObjectKeys(ctx)) {\\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\\n      continue;\\n    }\\n    err[prop] = ctx[prop];\\n  }\\n\\n  err.code = code;\\n  if (path) {\\n    err.path = path;\\n  }\\n  if (dest) {\\n    err.dest = dest;\\n  }\\n\\n  return captureLargerStackTrace(err);\\n});\\n\\n/**\\n * This creates an error compatible with errors produced in the C++\\n * This function should replace the deprecated\\n * `exceptionWithHostPort()` function.\\n *\\n * @param {number} err - A libuv error number\\n * @param {string} syscall\\n * @param {string} address\\n * @param {number} [port]\\n * @returns {Error}\\n */\\nconst uvExceptionWithHostPort = hideStackFrames(\\n  function uvExceptionWithHostPort(err\\x2C syscall\\x2C address\\x2C port) {\\n    const { 0: code\\x2C 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\\n    const message = `${syscall} ${code}: ${uvmsg}`;\\n    let details = '';\\n\\n    if (port && port > 0) {\\n      details = ` ${address}:${port}`;\\n    } else if (address) {\\n      details = ` ${address}`;\\n    }\\n\\n    // Reducing the limit improves the performance significantly. We do not\\n    // lose the stack frames due to the `captureStackTrace()` function that\\n    // is called later.\\n    const tmpLimit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    // eslint-disable-next-line no-restricted-syntax\\n    const ex = new Error(`${message}${details}`);\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n    ex.code = code;\\n    ex.errno = err;\\n    ex.syscall = syscall;\\n    ex.address = address;\\n    if (port) {\\n      ex.port = port;\\n    }\\n\\n    return captureLargerStackTrace(ex);\\n  });\\n\\n/**\\n * This used to be util._errnoException().\\n *\\n * @param {number} err - A libuv error number\\n * @param {string} syscall\\n * @param {string} [original]\\n * @returns {Error}\\n */\\nconst errnoException = hideStackFrames(\\n  function errnoException(err\\x2C syscall\\x2C original) {\\n    // TODO(joyeecheung): We have to use the type-checked\\n    // getSystemErrorName(err) to guard against invalid arguments from users.\\n    // This can be replaced with [ code ] = errmap.get(err) when this method\\n    // is no longer exposed to user land.\\n    if (util === undefined) util = require('util');\\n    const code = util.getSystemErrorName(err);\\n    const message = original ?\\n      `${syscall} ${code} ${original}` : `${syscall} ${code}`;\\n\\n    const tmpLimit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    // eslint-disable-next-line no-restricted-syntax\\n    const ex = new Error(message);\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n    ex.errno = err;\\n    ex.code = code;\\n    ex.syscall = syscall;\\n\\n    return captureLargerStackTrace(ex);\\n  });\\n\\n/**\\n * Deprecated\\x2C new function is `uvExceptionWithHostPort()`\\n * New function added the error description directly\\n * from C++. this method for backwards compatibility\\n * @param {number} err - A libuv error number\\n * @param {string} syscall\\n * @param {string} address\\n * @param {number} [port]\\n * @param {string} [additional]\\n * @returns {Error}\\n */\\nconst exceptionWithHostPort = hideStackFrames(\\n  function exceptionWithHostPort(err\\x2C syscall\\x2C address\\x2C port\\x2C additional) {\\n    // TODO(joyeecheung): We have to use the type-checked\\n    // getSystemErrorName(err) to guard against invalid arguments from users.\\n    // This can be replaced with [ code ] = errmap.get(err) when this method\\n    // is no longer exposed to user land.\\n    if (util === undefined) util = require('util');\\n    const code = util.getSystemErrorName(err);\\n    let details = '';\\n    if (port && port > 0) {\\n      details = ` ${address}:${port}`;\\n    } else if (address) {\\n      details = ` ${address}`;\\n    }\\n    if (additional) {\\n      details += ` - Local (${additional})`;\\n    }\\n\\n    // Reducing the limit improves the performance significantly. We do not\\n    // lose the stack frames due to the `captureStackTrace()` function that\\n    // is called later.\\n    const tmpLimit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    // eslint-disable-next-line no-restricted-syntax\\n    const ex = new Error(`${syscall} ${code}${details}`);\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n    ex.errno = err;\\n    ex.code = code;\\n    ex.syscall = syscall;\\n    ex.address = address;\\n    if (port) {\\n      ex.port = port;\\n    }\\n\\n    return captureLargerStackTrace(ex);\\n  });\\n\\n/**\\n * @param {number|string} code - A libuv error number or a c-ares error code\\n * @param {string} syscall\\n * @param {string} [hostname]\\n * @returns {Error}\\n */\\nconst dnsException = hideStackFrames(function(code\\x2C syscall\\x2C hostname) {\\n  let errno;\\n  // If `code` is of type number\\x2C it is a libuv error number\\x2C else it is a\\n  // c-ares error code.\\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\\n  // make them available in a property that's not error.errno (since they\\n  // can be in conflict with libuv error codes). Also make sure\\n  // util.getSystemErrorName() can understand them when an being informed that\\n  // the number is a c-ares error code.\\n  if (typeof code === 'number') {\\n    errno = code;\\n    // ENOTFOUND is not a proper POSIX error\\x2C but this error has been in place\\n    // long enough that it's not practical to remove it.\\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\\n      code = 'ENOTFOUND'; // Fabricated error name.\\n    } else {\\n      code = lazyInternalUtil().getSystemErrorName(code);\\n    }\\n  }\\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\\n  // Reducing the limit improves the performance significantly. We do not lose\\n  // the stack frames due to the `captureStackTrace()` function that is called\\n  // later.\\n  const tmpLimit = Error.stackTraceLimit;\\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n  // eslint-disable-next-line no-restricted-syntax\\n  const ex = new Error(message);\\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\\n  ex.errno = errno;\\n  ex.code = code;\\n  ex.syscall = syscall;\\n  if (hostname) {\\n    ex.hostname = hostname;\\n  }\\n\\n  return captureLargerStackTrace(ex);\\n});\\n\\nfunction connResetException(msg) {\\n  // eslint-disable-next-line no-restricted-syntax\\n  const ex = new Error(msg);\\n  ex.code = 'ECONNRESET';\\n  return ex;\\n}\\n\\nlet maxStack_ErrorName;\\nlet maxStack_ErrorMessage;\\n/**\\n * Returns true if `err.name` and `err.message` are equal to engine-specific\\n * values indicating max call stack size has been exceeded.\\n * \"Maximum call stack size exceeded\" in V8.\\n *\\n * @param {Error} err\\n * @returns {boolean}\\n */\\nfunction isStackOverflowError(err) {\\n  if (maxStack_ErrorMessage === undefined) {\\n    try {\\n      function overflowStack() { overflowStack(); }\\n      overflowStack();\\n    } catch (err) {\\n      maxStack_ErrorMessage = err.message;\\n      maxStack_ErrorName = err.name;\\n    }\\n  }\\n\\n  return err && err.name === maxStack_ErrorName &&\\n         err.message === maxStack_ErrorMessage;\\n}\\n\\n// Only use this for integers! Decimal numbers do not work with this function.\\nfunction addNumericalSeparator(val) {\\n  let res = '';\\n  let i = val.length;\\n  const start = val[0] === '-' ? 1 : 0;\\n  for (; i >= start + 4; i -= 3) {\\n    res = `_${StringPrototypeSlice(val\\x2C i - 3\\x2C i)}${res}`;\\n  }\\n  return `${StringPrototypeSlice(val\\x2C 0\\x2C i)}${res}`;\\n}\\n\\n// Used to enhance the stack that will be picked up by the inspector\\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\\n\\n// These are supposed to be called only on fatal exceptions before\\n// the process exits.\\nconst fatalExceptionStackEnhancers = {\\n  beforeInspector(error) {\\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\\n      return error.stack;\\n    }\\n\\n    try {\\n      // Set the error.stack here so it gets picked up by the\\n      // inspector.\\n      error.stack = error[kEnhanceStackBeforeInspector]();\\n    } catch {\\n      // We are just enhancing the error. If it fails\\x2C ignore it.\\n    }\\n    return error.stack;\\n  }\\x2C\\n  afterInspector(error) {\\n    const originalStack = error.stack;\\n    let useColors = true;\\n    // Some consoles do not convert ANSI escape sequences to colors\\x2C\\n    // rather display them directly to the stdout. On those consoles\\x2C\\n    // libuv emulates colors by intercepting stdout stream and calling\\n    // corresponding Windows API functions for setting console colors.\\n    // However\\x2C fatal error are handled differently and we cannot easily\\n    // highlight them. On Windows\\x2C detecting whether a console supports\\n    // ANSI escape sequences is not reliable.\\n    if (process.platform === 'win32') {\\n      const info = internalBinding('os').getOSInformation();\\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2]\\x2C '.')\\x2C\\n                                    Number);\\n      if (ver[0] !== 10 || ver[2] < 14393) {\\n        useColors = false;\\n      }\\n    }\\n    const {\\n      inspect\\x2C\\n      inspectDefaultOptions: {\\n        colors: defaultColors\\n      }\\n    } = lazyInternalUtilInspect();\\n    const colors = useColors &&\\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\\n                   require('internal/tty').hasColors()) ||\\n                   defaultColors);\\n    try {\\n      return inspect(error\\x2C {\\n        colors\\x2C\\n        customInspect: false\\x2C\\n        depth: MathMax(inspect.defaultOptions.depth\\x2C 5)\\n      });\\n    } catch {\\n      return originalStack;\\n    }\\n  }\\n};\\n\\n// Ensures the printed error line is from user code.\\nlet _kArrowMessagePrivateSymbol\\x2C _setHiddenValue;\\nfunction setArrowMessage(err\\x2C arrowMessage) {\\n  if (!_kArrowMessagePrivateSymbol) {\\n    ({\\n      arrow_message_private_symbol: _kArrowMessagePrivateSymbol\\x2C\\n      setHiddenValue: _setHiddenValue\\x2C\\n    } = internalBinding('util'));\\n  }\\n  _setHiddenValue(err\\x2C _kArrowMessagePrivateSymbol\\x2C arrowMessage);\\n}\\n\\n// Hide stack lines before the first user code line.\\nfunction hideInternalStackFrames(error) {\\n  overrideStackTrace.set(error\\x2C (error\\x2C stackFrames) => {\\n    let frames = stackFrames;\\n    if (typeof stackFrames === 'object') {\\n      frames = ArrayPrototypeFilter(\\n        stackFrames\\x2C\\n        (frm) => !StringPrototypeStartsWith(frm.getFileName() || ''\\x2C\\n                                            'node:internal')\\n      );\\n    }\\n    ArrayPrototypeUnshift(frames\\x2C error);\\n    return ArrayPrototypeJoin(frames\\x2C '\\\\n    at ');\\n  });\\n}\\n\\n// Node uses an AbortError that isn't exactly the same as the DOMException\\n// to make usage of the error in userland and readable-stream easier.\\n// It is a regular error with `.code` and `.name`.\\nclass AbortError extends Error {\\n  constructor() {\\n    super('The operation was aborted');\\n    this.code = 'ABORT_ERR';\\n    this.name = 'AbortError';\\n  }\\n}\\nmodule.exports = {\\n  aggregateTwoErrors\\x2C\\n  codes\\x2C\\n  dnsException\\x2C\\n  errnoException\\x2C\\n  exceptionWithHostPort\\x2C\\n  getMessage\\x2C\\n  hideStackFrames\\x2C\\n  hideInternalStackFrames\\x2C\\n  isErrorStackTraceLimitWritable\\x2C\\n  isStackOverflowError\\x2C\\n  setArrowMessage\\x2C\\n  connResetException\\x2C\\n  uvErrmapGet\\x2C\\n  uvException\\x2C\\n  uvExceptionWithHostPort\\x2C\\n  SystemError\\x2C\\n  AbortError\\x2C\\n  // This is exported only to facilitate testing.\\n  E\\x2C\\n  kNoOverride\\x2C\\n  prepareStackTrace\\x2C\\n  maybeOverridePrepareStackTrace\\x2C\\n  overrideStackTrace\\x2C\\n  kEnhanceStackBeforeInspector\\x2C\\n  fatalExceptionStackEnhancers\\x2C\\n  kIsNodeError\\x2C\\n  captureLargerStackTrace\\x2C\\n};\\n\\n// To declare an error message\\x2C use the E(sym\\x2C val\\x2C def) function above. The sym\\n// must be an upper case string. The val can be either a function or a string.\\n// The def must be an error class.\\n// The return value of the function must be a string.\\n// Examples:\\n// E('EXAMPLE_KEY1'\\x2C 'This is the error value'\\x2C Error);\\n// E('EXAMPLE_KEY2'\\x2C (a\\x2C b) => return `${a} ${b}`\\x2C RangeError);\\n//\\n// Once an error code has been assigned\\x2C the code itself MUST NOT change and\\n// any given error code must never be reused to identify a different error.\\n//\\n// Any error code added here should also be added to the documentation\\n//\\n// Note: Please try to keep these in alphabetical order\\n//\\n// Note: Node.js specific errors must begin with the prefix ERR_\\n\\nE('ERR_AMBIGUOUS_ARGUMENT'\\x2C 'The \"%s\" argument is ambiguous. %s'\\x2C TypeError);\\nE('ERR_ARG_NOT_ITERABLE'\\x2C '%s must be iterable'\\x2C TypeError);\\nE('ERR_ASSERTION'\\x2C '%s'\\x2C Error);\\nE('ERR_ASYNC_CALLBACK'\\x2C '%s must be a function'\\x2C TypeError);\\nE('ERR_ASYNC_TYPE'\\x2C 'Invalid name for async \"type\": %s'\\x2C TypeError);\\nE('ERR_BROTLI_INVALID_PARAM'\\x2C '%s is not a valid Brotli parameter'\\x2C RangeError);\\nE('ERR_BUFFER_OUT_OF_BOUNDS'\\x2C\\n  // Using a default argument here is important so the argument is not counted\\n  // towards `Function#length`.\\n  (name = undefined) => {\\n    if (name) {\\n      return `\"${name}\" is outside of buffer bounds`;\\n    }\\n    return 'Attempt to access memory outside buffer bounds';\\n  }\\x2C RangeError);\\nE('ERR_BUFFER_TOO_LARGE'\\x2C\\n  'Cannot create a Buffer larger than %s bytes'\\x2C\\n  RangeError);\\nE('ERR_CANNOT_WATCH_SIGINT'\\x2C 'Cannot watch for SIGINT signals'\\x2C Error);\\nE('ERR_CHILD_CLOSED_BEFORE_REPLY'\\x2C\\n  'Child closed before reply received'\\x2C Error);\\nE('ERR_CHILD_PROCESS_IPC_REQUIRED'\\x2C\\n  \"Forked processes must have an IPC channel\\x2C missing value 'ipc' in %s\"\\x2C\\n  Error);\\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER'\\x2C '%s maxBuffer length exceeded'\\x2C\\n  RangeError);\\nE('ERR_CONSOLE_WRITABLE_STREAM'\\x2C\\n  'Console expects a writable stream instance for %s'\\x2C TypeError);\\nE('ERR_CONTEXT_NOT_INITIALIZED'\\x2C 'context used is not initialized'\\x2C Error);\\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED'\\x2C\\n  'Custom engines not supported by this OpenSSL'\\x2C Error);\\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT'\\x2C 'Invalid ECDH format: %s'\\x2C TypeError);\\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY'\\x2C\\n  'Public key is not valid for specified curve'\\x2C Error);\\nE('ERR_CRYPTO_ENGINE_UNKNOWN'\\x2C 'Engine \"%s\" was not found'\\x2C Error);\\nE('ERR_CRYPTO_FIPS_FORCED'\\x2C\\n  'Cannot set FIPS mode\\x2C it was forced with --force-fips at startup.'\\x2C Error);\\nE('ERR_CRYPTO_FIPS_UNAVAILABLE'\\x2C 'Cannot set FIPS mode in a non-FIPS build.'\\x2C\\n  Error);\\nE('ERR_CRYPTO_HASH_FINALIZED'\\x2C 'Digest already called'\\x2C Error);\\nE('ERR_CRYPTO_HASH_UPDATE_FAILED'\\x2C 'Hash update failed'\\x2C Error);\\nE('ERR_CRYPTO_INCOMPATIBLE_KEY'\\x2C 'Incompatible %s: %s'\\x2C Error);\\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'\\x2C 'The selected key encoding %s %s.'\\x2C\\n  Error);\\nE('ERR_CRYPTO_INVALID_DIGEST'\\x2C 'Invalid digest: %s'\\x2C TypeError);\\nE('ERR_CRYPTO_INVALID_JWK'\\x2C 'Invalid JWK data'\\x2C TypeError);\\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE'\\x2C\\n  'Invalid key object type %s\\x2C expected %s.'\\x2C TypeError);\\nE('ERR_CRYPTO_INVALID_STATE'\\x2C 'Invalid state for operation %s'\\x2C Error);\\nE('ERR_CRYPTO_PBKDF2_ERROR'\\x2C 'PBKDF2 error'\\x2C Error);\\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER'\\x2C 'Invalid scrypt parameter'\\x2C Error);\\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED'\\x2C 'Scrypt algorithm not supported'\\x2C Error);\\n// Switch to TypeError. The current implementation does not seem right.\\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED'\\x2C 'No key provided to sign'\\x2C Error);\\nE('ERR_DEBUGGER_ERROR'\\x2C '%s'\\x2C Error);\\nE('ERR_DEBUGGER_STARTUP_ERROR'\\x2C '%s'\\x2C Error);\\nE('ERR_DIR_CLOSED'\\x2C 'Directory handle was closed'\\x2C Error);\\nE('ERR_DIR_CONCURRENT_OPERATION'\\x2C\\n  'Cannot do synchronous work on directory handle with concurrent ' +\\n  'asynchronous operations'\\x2C Error);\\nE('ERR_DNS_SET_SERVERS_FAILED'\\x2C 'c-ares failed to set servers: \"%s\" [%s]'\\x2C\\n  Error);\\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE'\\x2C\\n  'A callback was registered through ' +\\n     'process.setUncaughtExceptionCaptureCallback()\\x2C which is mutually ' +\\n     'exclusive with using the `domain` module'\\x2C\\n  Error);\\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE'\\x2C\\n  'The `domain` module is in use\\x2C which is mutually exclusive with calling ' +\\n     'process.setUncaughtExceptionCaptureCallback()'\\x2C\\n  Error);\\nE('ERR_ENCODING_INVALID_ENCODED_DATA'\\x2C function(encoding\\x2C ret) {\\n  this.errno = ret;\\n  return `The encoded data was not valid for encoding ${encoding}`;\\n}\\x2C TypeError);\\nE('ERR_ENCODING_NOT_SUPPORTED'\\x2C 'The \"%s\" encoding is not supported'\\x2C\\n  RangeError);\\nE('ERR_EVAL_ESM_CANNOT_PRINT'\\x2C '--print cannot be used with ESM input'\\x2C Error);\\nE('ERR_EVENT_RECURSION'\\x2C 'The event \"%s\" is already being dispatched'\\x2C Error);\\nE('ERR_FALSY_VALUE_REJECTION'\\x2C function(reason) {\\n  this.reason = reason;\\n  return 'Promise was rejected with falsy value';\\n}\\x2C Error);\\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM'\\x2C\\n  'The feature %s is unavailable on the current platform' +\\n  '\\x2C which is being used to run Node.js'\\x2C\\n  TypeError);\\nE('ERR_FS_CP_DIR_TO_NON_DIR'\\x2C\\n  'Cannot overwrite directory with non-directory'\\x2C SystemError);\\nE('ERR_FS_CP_EEXIST'\\x2C 'Target already exists'\\x2C SystemError);\\nE('ERR_FS_CP_EINVAL'\\x2C 'Invalid src or dest'\\x2C SystemError);\\nE('ERR_FS_CP_FIFO_PIPE'\\x2C 'Cannot copy a FIFO pipe'\\x2C SystemError);\\nE('ERR_FS_CP_NON_DIR_TO_DIR'\\x2C\\n  'Cannot overwrite non-directory with directory'\\x2C SystemError);\\nE('ERR_FS_CP_SOCKET'\\x2C 'Cannot copy a socket file'\\x2C SystemError);\\nE('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY'\\x2C\\n  'Cannot overwrite symlink in subdirectory of self'\\x2C SystemError);\\nE('ERR_FS_CP_UNKNOWN'\\x2C 'Cannot copy an unknown file type'\\x2C SystemError);\\nE('ERR_FS_EISDIR'\\x2C 'Path is a directory'\\x2C SystemError);\\nE('ERR_FS_FILE_TOO_LARGE'\\x2C 'File size (%s) is greater than 2 GB'\\x2C RangeError);\\nE('ERR_FS_INVALID_SYMLINK_TYPE'\\x2C\\n  'Symlink type must be one of \"dir\"\\x2C \"file\"\\x2C or \"junction\". Received \"%s\"'\\x2C\\n  Error); // Swit" at the file end is broken
(node:2609) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2609) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.1/tick-processor.log is broken
"script-source,20,node:internal/util/inspect,'use strict';\\n\\nconst {\\n  Array\\x2C\\n  ArrayIsArray\\x2C\\n  ArrayPrototypeFilter\\x2C\\n  ArrayPrototypeForEach\\x2C\\n  ArrayPrototypePop\\x2C\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypePushApply\\x2C\\n  ArrayPrototypeSort\\x2C\\n  ArrayPrototypeUnshift\\x2C\\n  BigIntPrototypeValueOf\\x2C\\n  BooleanPrototypeValueOf\\x2C\\n  DatePrototypeGetTime\\x2C\\n  DatePrototypeToISOString\\x2C\\n  DatePrototypeToString\\x2C\\n  ErrorPrototypeToString\\x2C\\n  FunctionPrototypeCall\\x2C\\n  FunctionPrototypeToString\\x2C\\n  JSONStringify\\x2C\\n  MapPrototypeGetSize\\x2C\\n  MapPrototypeEntries\\x2C\\n  MathFloor\\x2C\\n  MathMax\\x2C\\n  MathMin\\x2C\\n  MathRound\\x2C\\n  MathSqrt\\x2C\\n  MathTrunc\\x2C\\n  Number\\x2C\\n  NumberIsFinite\\x2C\\n  NumberIsNaN\\x2C\\n  NumberParseFloat\\x2C\\n  NumberParseInt\\x2C\\n  NumberPrototypeValueOf\\x2C\\n  Object\\x2C\\n  ObjectAssign\\x2C\\n  ObjectCreate\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectGetOwnPropertyDescriptor\\x2C\\n  ObjectGetOwnPropertyNames\\x2C\\n  ObjectGetOwnPropertySymbols\\x2C\\n  ObjectGetPrototypeOf\\x2C\\n  ObjectIs\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  ObjectPrototypePropertyIsEnumerable\\x2C\\n  ObjectSeal\\x2C\\n  ObjectSetPrototypeOf\\x2C\\n  ReflectOwnKeys\\x2C\\n  RegExp\\x2C\\n  RegExpPrototypeTest\\x2C\\n  RegExpPrototypeToString\\x2C\\n  SafeStringIterator\\x2C\\n  SafeMap\\x2C\\n  SafeSet\\x2C\\n  SetPrototypeGetSize\\x2C\\n  SetPrototypeValues\\x2C\\n  String\\x2C\\n  StringPrototypeCharCodeAt\\x2C\\n  StringPrototypeCodePointAt\\x2C\\n  StringPrototypeIncludes\\x2C\\n  StringPrototypeNormalize\\x2C\\n  StringPrototypePadEnd\\x2C\\n  StringPrototypePadStart\\x2C\\n  StringPrototypeRepeat\\x2C\\n  StringPrototypeReplace\\x2C\\n  StringPrototypeSlice\\x2C\\n  StringPrototypeSplit\\x2C\\n  StringPrototypeToLowerCase\\x2C\\n  StringPrototypeTrim\\x2C\\n  StringPrototypeValueOf\\x2C\\n  SymbolPrototypeToString\\x2C\\n  SymbolPrototypeValueOf\\x2C\\n  SymbolIterator\\x2C\\n  SymbolToStringTag\\x2C\\n  TypedArrayPrototypeGetLength\\x2C\\n  TypedArrayPrototypeGetSymbolToStringTag\\x2C\\n  Uint8Array\\x2C\\n  globalThis\\x2C\\n  uncurryThis\\x2C\\n} = primordials;\\n\\nconst {\\n  getOwnNonIndexProperties\\x2C\\n  getPromiseDetails\\x2C\\n  getProxyDetails\\x2C\\n  kPending\\x2C\\n  kRejected\\x2C\\n  previewEntries\\x2C\\n  getConstructorName: internalGetConstructorName\\x2C\\n  getExternalValue\\x2C\\n  propertyFilter: {\\n    ALL_PROPERTIES\\x2C\\n    ONLY_ENUMERABLE\\n  }\\n} = internalBinding('util');\\n\\nconst {\\n  customInspectSymbol\\x2C\\n  isError\\x2C\\n  join\\x2C\\n  removeColors\\n} = require('internal/util');\\n\\nconst {\\n  codes: {\\n    ERR_INVALID_ARG_TYPE\\n  }\\x2C\\n  isStackOverflowError\\n} = require('internal/errors');\\n\\nconst {\\n  isAsyncFunction\\x2C\\n  isGeneratorFunction\\x2C\\n  isAnyArrayBuffer\\x2C\\n  isArrayBuffer\\x2C\\n  isArgumentsObject\\x2C\\n  isBoxedPrimitive\\x2C\\n  isDataView\\x2C\\n  isExternal\\x2C\\n  isMap\\x2C\\n  isMapIterator\\x2C\\n  isModuleNamespaceObject\\x2C\\n  isNativeError\\x2C\\n  isPromise\\x2C\\n  isSet\\x2C\\n  isSetIterator\\x2C\\n  isWeakMap\\x2C\\n  isWeakSet\\x2C\\n  isRegExp\\x2C\\n  isDate\\x2C\\n  isTypedArray\\x2C\\n  isStringObject\\x2C\\n  isNumberObject\\x2C\\n  isBooleanObject\\x2C\\n  isBigIntObject\\x2C\\n} = require('internal/util/types');\\n\\nconst assert = require('internal/assert');\\n\\nconst { NativeModule } = require('internal/bootstrap/loaders');\\nconst {\\n  validateObject\\x2C\\n  validateString\\x2C\\n} = require('internal/validators');\\n\\nlet hexSlice;\\n\\nconst builtInObjects = new SafeSet(\\n  ArrayPrototypeFilter(\\n    ObjectGetOwnPropertyNames(globalThis)\\x2C\\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/\\x2C e)\\n  )\\n);\\n\\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\\n\\n// These options must stay in sync with `getUserOptions`. So if any option will\\n// be added or removed\\x2C `getUserOptions` must also be updated accordingly.\\nconst inspectDefaultOptions = ObjectSeal({\\n  showHidden: false\\x2C\\n  depth: 2\\x2C\\n  colors: false\\x2C\\n  customInspect: true\\x2C\\n  showProxy: false\\x2C\\n  maxArrayLength: 100\\x2C\\n  maxStringLength: 10000\\x2C\\n  breakLength: 80\\x2C\\n  compact: 3\\x2C\\n  sorted: false\\x2C\\n  getters: false\\x2C\\n  numericSeparator: false\\x2C\\n});\\n\\nconst kObjectType = 0;\\nconst kArrayType = 1;\\nconst kArrayExtrasType = 2;\\n\\n/* eslint-disable no-control-regex */\\nconst strEscapeSequencesRegExp = /[\\\\x00-\\\\x1f\\\\x27\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/;\\nconst strEscapeSequencesReplacer = /[\\\\x00-\\\\x1f\\\\x27\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/g;\\nconst strEscapeSequencesRegExpSingle = /[\\\\x00-\\\\x1f\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/;\\nconst strEscapeSequencesReplacerSingle = /[\\\\x00-\\\\x1f\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/g;\\n/* eslint-enable no-control-regex */\\n\\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\\n\\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\\\\\(]+ \\\\(|)node:(.+):\\\\d+:\\\\d+\\\\)?$/;\\nconst nodeModulesRegExp = /[/\\\\\\\\]node_modules[/\\\\\\\\](.+?)(?=[/\\\\\\\\])/g;\\n\\nconst classRegExp = /^(\\\\s+[^(]*?)\\\\s*{/;\\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\\nconst stripCommentsRegExp = /(\\\\/\\\\/.*?\\\\n)|(\\\\/\\\\*(.|\\\\n)*?\\\\*\\\\/)/g;\\n\\nconst kMinLineLength = 16;\\n\\n// Constants to map the iterator state.\\nconst kWeak = 0;\\nconst kIterator = 1;\\nconst kMapEntries = 2;\\n\\n// Escaped control characters (plus the single quote and the backslash). Use\\n// empty strings to fill up unused entries.\\nconst meta = [\\n  '\\\\\\\\x00'\\x2C '\\\\\\\\x01'\\x2C '\\\\\\\\x02'\\x2C '\\\\\\\\x03'\\x2C '\\\\\\\\x04'\\x2C '\\\\\\\\x05'\\x2C '\\\\\\\\x06'\\x2C '\\\\\\\\x07'\\x2C // x07\\n  '\\\\\\\\b'\\x2C '\\\\\\\\t'\\x2C '\\\\\\\\n'\\x2C '\\\\\\\\x0B'\\x2C '\\\\\\\\f'\\x2C '\\\\\\\\r'\\x2C '\\\\\\\\x0E'\\x2C '\\\\\\\\x0F'\\x2C           // x0F\\n  '\\\\\\\\x10'\\x2C '\\\\\\\\x11'\\x2C '\\\\\\\\x12'\\x2C '\\\\\\\\x13'\\x2C '\\\\\\\\x14'\\x2C '\\\\\\\\x15'\\x2C '\\\\\\\\x16'\\x2C '\\\\\\\\x17'\\x2C // x17\\n  '\\\\\\\\x18'\\x2C '\\\\\\\\x19'\\x2C '\\\\\\\\x1A'\\x2C '\\\\\\\\x1B'\\x2C '\\\\\\\\x1C'\\x2C '\\\\\\\\x1D'\\x2C '\\\\\\\\x1E'\\x2C '\\\\\\\\x1F'\\x2C // x1F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C \"\\\\\\\\'\"\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C      // x2F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x3F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x4F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C '\\\\\\\\\\\\\\\\'\\x2C ''\\x2C ''\\x2C ''\\x2C     // x5F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x6F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C '\\\\\\\\x7F'\\x2C    // x7F\\n  '\\\\\\\\x80'\\x2C '\\\\\\\\x81'\\x2C '\\\\\\\\x82'\\x2C '\\\\\\\\x83'\\x2C '\\\\\\\\x84'\\x2C '\\\\\\\\x85'\\x2C '\\\\\\\\x86'\\x2C '\\\\\\\\x87'\\x2C // x87\\n  '\\\\\\\\x88'\\x2C '\\\\\\\\x89'\\x2C '\\\\\\\\x8A'\\x2C '\\\\\\\\x8B'\\x2C '\\\\\\\\x8C'\\x2C '\\\\\\\\x8D'\\x2C '\\\\\\\\x8E'\\x2C '\\\\\\\\x8F'\\x2C // x8F\\n  '\\\\\\\\x90'\\x2C '\\\\\\\\x91'\\x2C '\\\\\\\\x92'\\x2C '\\\\\\\\x93'\\x2C '\\\\\\\\x94'\\x2C '\\\\\\\\x95'\\x2C '\\\\\\\\x96'\\x2C '\\\\\\\\x97'\\x2C // x97\\n  '\\\\\\\\x98'\\x2C '\\\\\\\\x99'\\x2C '\\\\\\\\x9A'\\x2C '\\\\\\\\x9B'\\x2C '\\\\\\\\x9C'\\x2C '\\\\\\\\x9D'\\x2C '\\\\\\\\x9E'\\x2C '\\\\\\\\x9F'\\x2C // x9F\\n];\\n\\n// Regex used for ansi escape code splitting\\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\\n// License: MIT\\x2C authors: @sindresorhus\\x2C Qix-\\x2C arjunmehta and LitoMore\\n// Matches all ansi escape code sequences in a string\\nconst ansiPattern = '[\\\\\\\\u001B\\\\\\\\u009B][[\\\\\\\\]()#;?]*' +\\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\\\\\d\\\\\\\\/#&.:=?%@~_]+)*' +\\n  '|[a-zA-Z\\\\\\\\d]+(?:;[-a-zA-Z\\\\\\\\d\\\\\\\\/#&.:=?%@~_]*)*)?\\\\\\\\u0007)' +\\n  '|(?:(?:\\\\\\\\d{1\\x2C4}(?:;\\\\\\\\d{0\\x2C4})*)?[\\\\\\\\dA-PR-TZcf-ntqry=><~]))';\\nconst ansi = new RegExp(ansiPattern\\x2C 'g');\\n\\nlet getStringWidth;\\n\\nfunction getUserOptions(ctx\\x2C isCrossContext) {\\n  const ret = {\\n    stylize: ctx.stylize\\x2C\\n    showHidden: ctx.showHidden\\x2C\\n    depth: ctx.depth\\x2C\\n    colors: ctx.colors\\x2C\\n    customInspect: ctx.customInspect\\x2C\\n    showProxy: ctx.showProxy\\x2C\\n    maxArrayLength: ctx.maxArrayLength\\x2C\\n    maxStringLength: ctx.maxStringLength\\x2C\\n    breakLength: ctx.breakLength\\x2C\\n    compact: ctx.compact\\x2C\\n    sorted: ctx.sorted\\x2C\\n    getters: ctx.getters\\x2C\\n    numericSeparator: ctx.numericSeparator\\x2C\\n    ...ctx.userOptions\\n  };\\n\\n  // Typically\\x2C the target value will be an instance of `Object`. If that is\\n  // *not* the case\\x2C the object may come from another vm.Context\\x2C and we want\\n  // to avoid passing it objects from this Context in that case\\x2C so we remove\\n  // the prototype from the returned object itself + the `stylize()` function\\x2C\\n  // and remove all other non-primitives\\x2C including non-primitive user options.\\n  if (isCrossContext) {\\n    ObjectSetPrototypeOf(ret\\x2C null);\\n    for (const key of ObjectKeys(ret)) {\\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\\n          ret[key] !== null) {\\n        delete ret[key];\\n      }\\n    }\\n    ret.stylize = ObjectSetPrototypeOf((value\\x2C flavour) => {\\n      let stylized;\\n      try {\\n        stylized = `${ctx.stylize(value\\x2C flavour)}`;\\n      } catch {\\n        // Continue regardless of error.\\n      }\\n\\n      if (typeof stylized !== 'string') return value;\\n      // `stylized` is a string as it should be\\x2C which is safe to pass along.\\n      return stylized;\\n    }\\x2C null);\\n  }\\n\\n  return ret;\\n}\\n\\n/**\\n * Echos the value of any input. Tries to print the value out\\n * in the best way possible given the different types.\\n *\\n * @param {any} value The value to print out.\\n * @param {object} opts Optional options object that alters the output.\\n */\\n/* Legacy: value\\x2C showHidden\\x2C depth\\x2C colors */\\nfunction inspect(value\\x2C opts) {\\n  // Default options\\n  const ctx = {\\n    budget: {}\\x2C\\n    indentationLvl: 0\\x2C\\n    seen: []\\x2C\\n    currentDepth: 0\\x2C\\n    stylize: stylizeNoColor\\x2C\\n    showHidden: inspectDefaultOptions.showHidden\\x2C\\n    depth: inspectDefaultOptions.depth\\x2C\\n    colors: inspectDefaultOptions.colors\\x2C\\n    customInspect: inspectDefaultOptions.customInspect\\x2C\\n    showProxy: inspectDefaultOptions.showProxy\\x2C\\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\\x2C\\n    maxStringLength: inspectDefaultOptions.maxStringLength\\x2C\\n    breakLength: inspectDefaultOptions.breakLength\\x2C\\n    compact: inspectDefaultOptions.compact\\x2C\\n    sorted: inspectDefaultOptions.sorted\\x2C\\n    getters: inspectDefaultOptions.getters\\x2C\\n    numericSeparator: inspectDefaultOptions.numericSeparator\\x2C\\n  };\\n  if (arguments.length > 1) {\\n    // Legacy...\\n    if (arguments.length > 2) {\\n      if (arguments[2] !== undefined) {\\n        ctx.depth = arguments[2];\\n      }\\n      if (arguments.length > 3 && arguments[3] !== undefined) {\\n        ctx.colors = arguments[3];\\n      }\\n    }\\n    // Set user-specified options\\n    if (typeof opts === 'boolean') {\\n      ctx.showHidden = opts;\\n    } else if (opts) {\\n      const optKeys = ObjectKeys(opts);\\n      for (let i = 0; i < optKeys.length; ++i) {\\n        const key = optKeys[i];\\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\\n        // this function public or add a new API with a similar or better\\n        // functionality.\\n        if (\\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\\x2C key) ||\\n          key === 'stylize') {\\n          ctx[key] = opts[key];\\n        } else if (ctx.userOptions === undefined) {\\n          // This is required to pass through the actual user input.\\n          ctx.userOptions = opts;\\n        }\\n      }\\n    }\\n  }\\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\\n  return formatValue(ctx\\x2C value\\x2C 0);\\n}\\ninspect.custom = customInspectSymbol;\\n\\nObjectDefineProperty(inspect\\x2C 'defaultOptions'\\x2C {\\n  get() {\\n    return inspectDefaultOptions;\\n  }\\x2C\\n  set(options) {\\n    validateObject(options\\x2C 'options');\\n    return ObjectAssign(inspectDefaultOptions\\x2C options);\\n  }\\n});\\n\\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\\n// Each color consists of an array with the color code as first entry and the\\n// reset code as second entry.\\nconst defaultFG = 39;\\nconst defaultBG = 49;\\ninspect.colors = ObjectAssign(ObjectCreate(null)\\x2C {\\n  reset: [0\\x2C 0]\\x2C\\n  bold: [1\\x2C 22]\\x2C\\n  dim: [2\\x2C 22]\\x2C // Alias: faint\\n  italic: [3\\x2C 23]\\x2C\\n  underline: [4\\x2C 24]\\x2C\\n  blink: [5\\x2C 25]\\x2C\\n  // Swap foreground and background colors\\n  inverse: [7\\x2C 27]\\x2C // Alias: swapcolors\\x2C swapColors\\n  hidden: [8\\x2C 28]\\x2C // Alias: conceal\\n  strikethrough: [9\\x2C 29]\\x2C // Alias: strikeThrough\\x2C crossedout\\x2C crossedOut\\n  doubleunderline: [21\\x2C 24]\\x2C // Alias: doubleUnderline\\n  black: [30\\x2C defaultFG]\\x2C\\n  red: [31\\x2C defaultFG]\\x2C\\n  green: [32\\x2C defaultFG]\\x2C\\n  yellow: [33\\x2C defaultFG]\\x2C\\n  blue: [34\\x2C defaultFG]\\x2C\\n  magenta: [35\\x2C defaultFG]\\x2C\\n  cyan: [36\\x2C defaultFG]\\x2C\\n  white: [37\\x2C defaultFG]\\x2C\\n  bgBlack: [40\\x2C defaultBG]\\x2C\\n  bgRed: [41\\x2C defaultBG]\\x2C\\n  bgGreen: [42\\x2C defaultBG]\\x2C\\n  bgYellow: [43\\x2C defaultBG]\\x2C\\n  bgBlue: [44\\x2C defaultBG]\\x2C\\n  bgMagenta: [45\\x2C defaultBG]\\x2C\\n  bgCyan: [46\\x2C defaultBG]\\x2C\\n  bgWhite: [47\\x2C defaultBG]\\x2C\\n  framed: [51\\x2C 54]\\x2C\\n  overlined: [53\\x2C 55]\\x2C\\n  gray: [90\\x2C defaultFG]\\x2C // Alias: grey\\x2C blackBright\\n  redBright: [91\\x2C defaultFG]\\x2C\\n  greenBright: [92\\x2C defaultFG]\\x2C\\n  yellowBright: [93\\x2C defaultFG]\\x2C\\n  blueBright: [94\\x2C defaultFG]\\x2C\\n  magentaBright: [95\\x2C defaultFG]\\x2C\\n  cyanBright: [96\\x2C defaultFG]\\x2C\\n  whiteBright: [97\\x2C defaultFG]\\x2C\\n  bgGray: [100\\x2C defaultBG]\\x2C // Alias: bgGrey\\x2C bgBlackBright\\n  bgRedBright: [101\\x2C defaultBG]\\x2C\\n  bgGreenBright: [102\\x2C defaultBG]\\x2C\\n  bgYellowBright: [103\\x2C defaultBG]\\x2C\\n  bgBlueBright: [104\\x2C defaultBG]\\x2C\\n  bgMagentaBright: [105\\x2C defaultBG]\\x2C\\n  bgCyanBright: [106\\x2C defaultBG]\\x2C\\n  bgWhiteBright: [107\\x2C defaultBG]\\x2C\\n});\\n\\nfunction defineColorAlias(target\\x2C alias) {\\n  ObjectDefineProperty(inspect.colors\\x2C alias\\x2C {\\n    get() {\\n      return this[target];\\n    }\\x2C\\n    set(value) {\\n      this[target] = value;\\n    }\\x2C\\n    configurable: true\\x2C\\n    enumerable: false\\n  });\\n}\\n\\ndefineColorAlias('gray'\\x2C 'grey');\\ndefineColorAlias('gray'\\x2C 'blackBright');\\ndefineColorAlias('bgGray'\\x2C 'bgGrey');\\ndefineColorAlias('bgGray'\\x2C 'bgBlackBright');\\ndefineColorAlias('dim'\\x2C 'faint');\\ndefineColorAlias('strikethrough'\\x2C 'crossedout');\\ndefineColorAlias('strikethrough'\\x2C 'strikeThrough');\\ndefineColorAlias('strikethrough'\\x2C 'crossedOut');\\ndefineColorAlias('hidden'\\x2C 'conceal');\\ndefineColorAlias('inverse'\\x2C 'swapColors');\\ndefineColorAlias('inverse'\\x2C 'swapcolors');\\ndefineColorAlias('doubleunderline'\\x2C 'doubleUnderline');\\n\\n// TODO(BridgeAR): Add function style support for more complex styles.\\n// Don't use 'blue' not visible on cmd.exe\\ninspect.styles = ObjectAssign(ObjectCreate(null)\\x2C {\\n  special: 'cyan'\\x2C\\n  number: 'yellow'\\x2C\\n  bigint: 'yellow'\\x2C\\n  boolean: 'yellow'\\x2C\\n  undefined: 'grey'\\x2C\\n  null: 'bold'\\x2C\\n  string: 'green'\\x2C\\n  symbol: 'green'\\x2C\\n  date: 'magenta'\\x2C\\n  // \"name\": intentionally not styling\\n  // TODO(BridgeAR): Highlight regular expressions properly.\\n  regexp: 'red'\\x2C\\n  module: 'underline'\\n});\\n\\nfunction addQuotes(str\\x2C quotes) {\\n  if (quotes === -1) {\\n    return `\"${str}\"`;\\n  }\\n  if (quotes === -2) {\\n    return `\\\\`${str}\\\\``;\\n  }\\n  return `'${str}'`;\\n}\\n\\nfunction escapeFn(str) {\\n  const charCode = StringPrototypeCharCodeAt(str);\\n  return meta.length > charCode ? meta[charCode] : `\\\\\\\\u${charCode.toString(16)}`;\\n}\\n\\n// Escape control characters\\x2C single quotes and the backslash.\\n// This is similar to JSON stringify escaping.\\nfunction strEscape(str) {\\n  let escapeTest = strEscapeSequencesRegExp;\\n  let escapeReplace = strEscapeSequencesReplacer;\\n  let singleQuote = 39;\\n\\n  // Check for double quotes. If not present\\x2C do not escape single quotes and\\n  // instead wrap the text in double quotes. If double quotes exist\\x2C check for\\n  // backticks. If they do not exist\\x2C use those as fallback instead of the\\n  // double quotes.\\n  if (StringPrototypeIncludes(str\\x2C \"'\")) {\\n    // This invalidates the charCode and therefore can not be matched for\\n    // anymore.\\n    if (!StringPrototypeIncludes(str\\x2C '\"')) {\\n      singleQuote = -1;\\n    } else if (!StringPrototypeIncludes(str\\x2C '`') &&\\n               !StringPrototypeIncludes(str\\x2C '${')) {\\n      singleQuote = -2;\\n    }\\n    if (singleQuote !== 39) {\\n      escapeTest = strEscapeSequencesRegExpSingle;\\n      escapeReplace = strEscapeSequencesReplacerSingle;\\n    }\\n  }\\n\\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\\n  if (str.length < 5000 && !RegExpPrototypeTest(escapeTest\\x2C str))\\n    return addQuotes(str\\x2C singleQuote);\\n  if (str.length > 100) {\\n    str = StringPrototypeReplace(str\\x2C escapeReplace\\x2C escapeFn);\\n    return addQuotes(str\\x2C singleQuote);\\n  }\\n\\n  let result = '';\\n  let last = 0;\\n  for (let i = 0; i < str.length; i++) {\\n    const point = StringPrototypeCharCodeAt(str\\x2C i);\\n    if (point === singleQuote ||\\n        point === 92 ||\\n        point < 32 ||\\n        (point > 126 && point < 160)) {\\n      if (last === i) {\\n        result += meta[point];\\n      } else {\\n        result += `${StringPrototypeSlice(str\\x2C last\\x2C i)}${meta[point]}`;\\n      }\\n      last = i + 1;\\n    } else if (point >= 0xd800 && point <= 0xdfff) {\\n      if (point <= 0xdbff && i + 1 < str.length) {\\n        const point = StringPrototypeCharCodeAt(str\\x2C i + 1);\\n        if (point >= 0xdc00 && point <= 0xdfff) {\\n          i++;\\n          continue;\\n        }\\n      }\\n      result += `${StringPrototypeSlice(str\\x2C last\\x2C i)}${`\\\\\\\\u${point.toString(16)}`}`;\\n      last = i + 1;\\n    }\\n  }\\n\\n  if (last !== str.length) {\\n    result += StringPrototypeSlice(str\\x2C last);\\n  }\\n  return addQuotes(result\\x2C singleQuote);\\n}\\n\\nfunction stylizeWithColor(str\\x2C styleType) {\\n  const style = inspect.styles[styleType];\\n  if (style !== undefined) {\\n    const color = inspect.colors[style];\\n    if (color !== undefined)\\n      return `\\\\u001b[${color[0]}m${str}\\\\u001b[${color[1]}m`;\\n  }\\n  return str;\\n}\\n\\nfunction stylizeNoColor(str) {\\n  return str;\\n}\\n\\n// Return a new empty array to push in the results of the default formatter.\\nfunction getEmptyFormatArray() {\\n  return [];\\n}\\n\\nfunction isInstanceof(object\\x2C proto) {\\n  try {\\n    return object instanceof proto;\\n  } catch {\\n    return false;\\n  }\\n}\\n\\nfunction getConstructorName(obj\\x2C ctx\\x2C recurseTimes\\x2C protoProps) {\\n  let firstProto;\\n  const tmp = obj;\\n  while (obj || isUndetectableObject(obj)) {\\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\\x2C 'constructor');\\n    if (descriptor !== undefined &&\\n        typeof descriptor.value === 'function' &&\\n        descriptor.value.name !== '' &&\\n        isInstanceof(tmp\\x2C descriptor.value)) {\\n      if (protoProps !== undefined &&\\n         (firstProto !== obj ||\\n         !builtInObjects.has(descriptor.value.name))) {\\n        addPrototypeProperties(\\n          ctx\\x2C tmp\\x2C firstProto || tmp\\x2C recurseTimes\\x2C protoProps);\\n      }\\n      return descriptor.value.name;\\n    }\\n\\n    obj = ObjectGetPrototypeOf(obj);\\n    if (firstProto === undefined) {\\n      firstProto = obj;\\n    }\\n  }\\n\\n  if (firstProto === null) {\\n    return null;\\n  }\\n\\n  const res = internalGetConstructorName(tmp);\\n\\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\\n    return `${res} <Complex prototype>`;\\n  }\\n\\n  const protoConstr = getConstructorName(\\n    firstProto\\x2C ctx\\x2C recurseTimes + 1\\x2C protoProps);\\n\\n  if (protoConstr === null) {\\n    return `${res} <${inspect(firstProto\\x2C {\\n      ...ctx\\x2C\\n      customInspect: false\\x2C\\n      depth: -1\\n    })}>`;\\n  }\\n\\n  return `${res} <${protoConstr}>`;\\n}\\n\\n// This function has the side effect of adding prototype properties to the\\n// `output` argument (which is an array). This is intended to highlight user\\n// defined prototype properties.\\nfunction addPrototypeProperties(ctx\\x2C main\\x2C obj\\x2C recurseTimes\\x2C output) {\\n  let depth = 0;\\n  let keys;\\n  let keySet;\\n  do {\\n    if (depth !== 0 || main === obj) {\\n      obj = ObjectGetPrototypeOf(obj);\\n      // Stop as soon as a null prototype is encountered.\\n      if (obj === null) {\\n        return;\\n      }\\n      // Stop as soon as a built-in object type is detected.\\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\\x2C 'constructor');\\n      if (descriptor !== undefined &&\\n          typeof descriptor.value === 'function' &&\\n          builtInObjects.has(descriptor.value.name)) {\\n        return;\\n      }\\n    }\\n\\n    if (depth === 0) {\\n      keySet = new SafeSet();\\n    } else {\\n      ArrayPrototypeForEach(keys\\x2C (key) => keySet.add(key));\\n    }\\n    // Get all own property names and symbols.\\n    keys = ReflectOwnKeys(obj);\\n    ArrayPrototypePush(ctx.seen\\x2C main);\\n    for (const key of keys) {\\n      // Ignore the `constructor` property and keys that exist on layers above.\\n      if (key === 'constructor' ||\\n          ObjectPrototypeHasOwnProperty(main\\x2C key) ||\\n          (depth !== 0 && keySet.has(key))) {\\n        continue;\\n      }\\n      const desc = ObjectGetOwnPropertyDescriptor(obj\\x2C key);\\n      if (typeof desc.value === 'function') {\\n        continue;\\n      }\\n      const value = formatProperty(\\n        ctx\\x2C obj\\x2C recurseTimes\\x2C key\\x2C kObjectType\\x2C desc\\x2C main);\\n      if (ctx.colors) {\\n        // Faint!\\n        ArrayPrototypePush(output\\x2C `\\\\u001b[2m${value}\\\\u001b[22m`);\\n      } else {\\n        ArrayPrototypePush(output\\x2C value);\\n      }\\n    }\\n    ArrayPrototypePop(ctx.seen);\\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\\n  // is not a good choice here\\x2C because it's as if the properties are declared\\n  // on the current object from the users perspective.\\n  } while (++depth !== 3);\\n}\\n\\nfunction getPrefix(constructor\\x2C tag\\x2C fallback\\x2C size = '') {\\n  if (constructor === null) {\\n    if (tag !== '' && fallback !== tag) {\\n      return `[${fallback}${size}: null prototype] [${tag}] `;\\n    }\\n    return `[${fallback}${size}: null prototype] `;\\n  }\\n\\n  if (tag !== '' && constructor !== tag) {\\n    return `${constructor}${size} [${tag}] `;\\n  }\\n  return `${constructor}${size} `;\\n}\\n\\n// Look up the keys of the object.\\nfunction getKeys(value\\x2C showHidden) {\\n  let keys;\\n  const symbols = ObjectGetOwnPropertySymbols(value);\\n  if (showHidden) {\\n    keys = ObjectGetOwnPropertyNames(value);\\n    if (symbols.length !== 0)\\n      ArrayPrototypePushApply(keys\\x2C symbols);\\n  } else {\\n    // This might throw if `value` is a Module Namespace Object from an\\n    // unevaluated module\\x2C but we don't want to perform the actual type\\n    // check because it's expensive.\\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\\n    // and modify this logic as needed.\\n    try {\\n      keys = ObjectKeys(value);\\n    } catch (err) {\\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\\n             isModuleNamespaceObject(value));\\n      keys = ObjectGetOwnPropertyNames(value);\\n    }\\n    if (symbols.length !== 0) {\\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\\x2C key);\\n      ArrayPrototypePushApply(keys\\x2C ArrayPrototypeFilter(symbols\\x2C filter));\\n    }\\n  }\\n  return keys;\\n}\\n\\nfunction getCtxStyle(value\\x2C constructor\\x2C tag) {\\n  let fallback = '';\\n  if (constructor === null) {\\n    fallback = internalGetConstructorName(value);\\n    if (fallback === tag) {\\n      fallback = 'Object';\\n    }\\n  }\\n  return getPrefix(constructor\\x2C tag\\x2C fallback);\\n}\\n\\nfunction formatProxy(ctx\\x2C proxy\\x2C recurseTimes) {\\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\\n    return ctx.stylize('Proxy [Array]'\\x2C 'special');\\n  }\\n  recurseTimes += 1;\\n  ctx.indentationLvl += 2;\\n  const res = [\\n    formatValue(ctx\\x2C proxy[0]\\x2C recurseTimes)\\x2C\\n    formatValue(ctx\\x2C proxy[1]\\x2C recurseTimes)\\x2C\\n  ];\\n  ctx.indentationLvl -= 2;\\n  return reduceToSingleString(\\n    ctx\\x2C res\\x2C ''\\x2C ['Proxy ['\\x2C ']']\\x2C kArrayExtrasType\\x2C recurseTimes);\\n}\\n\\n// Note: using `formatValue` directly requires the indentation level to be\\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\\n// value afterwards again.\\nfunction formatValue(ctx\\x2C value\\x2C recurseTimes\\x2C typedArray) {\\n  // Primitive types cannot have properties.\\n  if (typeof value !== 'object' &&\\n      typeof value !== 'function' &&\\n      !isUndetectableObject(value)) {\\n    return formatPrimitive(ctx.stylize\\x2C value\\x2C ctx);\\n  }\\n  if (value === null) {\\n    return ctx.stylize('null'\\x2C 'null');\\n  }\\n\\n  // Memorize the context for custom inspection on proxies.\\n  const context = value;\\n  // Always check for proxies to prevent side effects and to prevent triggering\\n  // any proxy handlers.\\n  const proxy = getProxyDetails(value\\x2C !!ctx.showProxy);\\n  if (proxy !== undefined) {\\n    if (ctx.showProxy) {\\n      return formatProxy(ctx\\x2C proxy\\x2C recurseTimes);\\n    }\\n    value = proxy;\\n  }\\n\\n  // Provide a hook for user-specified inspect functions.\\n  // Check that value is an object with an inspect function on it.\\n  if (ctx.customInspect) {\\n    const maybeCustom = value[customInspectSymbol];\\n    if (typeof maybeCustom === 'function' &&\\n        // Filter out the util module\\x2C its inspect function is special.\\n        maybeCustom !== inspect &&\\n        // Also filter out any prototype objects using the circular check.\\n        !(value.constructor && value.constructor.prototype === value)) {\\n      // This makes sure the recurseTimes are reported as before while using\\n      // a counter internally.\\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\\n      const isCrossContext =\\n        proxy !== undefined || !(context instanceof Object);\\n      const ret = FunctionPrototypeCall(\\n        maybeCustom\\x2C\\n        context\\x2C\\n        depth\\x2C\\n        getUserOptions(ctx\\x2C isCrossContext)\\x2C\\n        inspect\\n      );\\n      // If the custom inspection method returned `this`\\x2C don't go into\\n      // infinite recursion.\\n      if (ret !== context) {\\n        if (typeof ret !== 'string') {\\n          return formatValue(ctx\\x2C ret\\x2C recurseTimes);\\n        }\\n        return ret.replace(/\\\\n/g\\x2C `\\\\n${' '.repeat(ctx.indentationLvl)}`);\\n      }\\n    }\\n  }\\n\\n  // Using an array here is actually better for the average case than using\\n  // a Set. `seen` will only check for the depth and will never grow too large.\\n  if (ctx.seen.includes(value)) {\\n    let index = 1;\\n    if (ctx.circular === undefined) {\\n      ctx.circular = new SafeMap();\\n      ctx.circular.set(value\\x2C index);\\n    } else {\\n      index = ctx.circular.get(value);\\n      if (index === undefined) {\\n        index = ctx.circular.size + 1;\\n        ctx.circular.set(value\\x2C index);\\n      }\\n    }\\n    return ctx.stylize(`[Circular *${index}]`\\x2C 'special');\\n  }\\n\\n  return formatRaw(ctx\\x2C value\\x2C recurseTimes\\x2C typedArray);\\n}\\n\\nfunction formatRaw(ctx\\x2C value\\x2C recurseTimes\\x2C typedArray) {\\n  let keys;\\n  let protoProps;\\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\\n    protoProps = [];\\n  }\\n\\n  const constructor = getConstructorName(value\\x2C ctx\\x2C recurseTimes\\x2C protoProps);\\n  // Reset the variable to check for this later on.\\n  if (protoProps !== undefined && protoProps.length === 0) {\\n    protoProps = undefined;\\n  }\\n\\n  let tag = value[SymbolToStringTag];\\n  // Only list the tag in case it's non-enumerable / not an own property.\\n  // Otherwise we'd print this twice.\\n  if (typeof tag !== 'string' ||\\n      (tag !== '' &&\\n      (ctx.showHidden ?\\n        ObjectPrototypeHasOwnProperty :\\n        ObjectPrototypePropertyIsEnumerable)(\\n        value\\x2C SymbolToStringTag\\n      ))) {\\n    tag = '';\\n  }\\n  let base = '';\\n  let formatter = getEmptyFormatArray;\\n  let braces;\\n  let noIterator = true;\\n  let i = 0;\\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\\n\\n  let extrasType = kObjectType;\\n\\n  // Iterators and the rest are split to reduce checks.\\n  // We have to check all values in case the constructor is set to null.\\n  // Otherwise it would not possible to identify all types properly.\\n  if (value[SymbolIterator] || constructor === null) {\\n    noIterator = false;\\n    if (ArrayIsArray(value)) {\\n      // Only set the constructor for non ordinary (\"Array [...]\") arrays.\\n      const prefix = (constructor !== 'Array' || tag !== '') ?\\n        getPrefix(constructor\\x2C tag\\x2C 'Array'\\x2C `(${value.length})`) :\\n        '';\\n      keys = getOwnNonIndexProperties(value\\x2C filter);\\n      braces = [`${prefix}[`\\x2C ']'];\\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\\n        return `${braces[0]}]`;\\n      extrasType = kArrayExtrasType;\\n      formatter = formatArray;\\n    } else if (isSet(value)) {\\n      const size = SetPrototypeGetSize(value);\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C 'Set'\\x2C `(${size})`);\\n      keys = getKeys(value\\x2C ctx.showHidden);\\n      formatter = constructor !== null ?\\n        formatSet.bind(null\\x2C value) :\\n        formatSet.bind(null\\x2C SetPrototypeValues(value));\\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\\n        return `${prefix}{}`;\\n      braces = [`${prefix}{`\\x2C '}'];\\n    } else if (isMap(value)) {\\n      const size = MapPrototypeGetSize(value);\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C 'Map'\\x2C `(${size})`);\\n      keys = getKeys(value\\x2C ctx.showHidden);\\n      formatter = constructor !== null ?\\n        formatMap.bind(null\\x2C value) :\\n        formatMap.bind(null\\x2C MapPrototypeEntries(value));\\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\\n        return `${prefix}{}`;\\n      braces = [`${prefix}{`\\x2C '}'];\\n    } else if (isTypedArray(value)) {\\n      keys = getOwnNonIndexProperties(value\\x2C filter);\\n      let bound = value;\\n      let fallback = '';\\n      if (constructor === null) {\\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\\n        // Reconstruct the array information.\\n        bound = new primordials[fallback](value);\\n      }\\n      const size = TypedArrayPrototypeGetLength(value);\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C fallback\\x2C `(${size})`);\\n      braces = [`${prefix}[`\\x2C ']'];\\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\\n        return `${braces[0]}]`;\\n      // Special handle the value. The original value is required below. The\\n      // bound function is required to reconstruct missing information.\\n      formatter = formatTypedArray.bind(null\\x2C bound\\x2C size);\\n      extrasType = kArrayExtrasType;\\n    } else if (isMapIterator(value)) {\\n      keys = getKeys(value\\x2C ctx.showHidden);\\n      braces = getIteratorBraces('Map'\\x2C tag);\\n      // Add braces to the formatter parameters.\\n      formatter = formatIterator.bind(null\\x2C braces);\\n    } else if (isSetIterator(value)) {\\n      keys = getKeys(value\\x2C ctx.showHidden);\\n      braces = getIteratorBraces('Set'\\x2C tag);\\n      // Add braces to the formatter parameters.\\n      formatter = formatIterator.bind(null\\x2C braces);\\n    } else {\\n      noIterator = true;\\n    }\\n  }\\n  if (noIterator) {\\n    keys = getKeys(value\\x2C ctx.showHidden);\\n    braces = ['{'\\x2C '}'];\\n    if (constructor === 'Object') {\\n      if (isArgumentsObject(value)) {\\n        braces[0] = '[Arguments] {';\\n      } else if (tag !== '') {\\n        braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'Object')}{`;\\n      }\\n      if (keys.length === 0 && protoProps === undefined) {\\n        return `${braces[0]}}`;\\n      }\\n    } else if (typeof value === 'function') {\\n      base = getFunctionBase(value\\x2C constructor\\x2C tag);\\n      if (keys.length === 0 && protoProps === undefined)\\n        return ctx.stylize(base\\x2C 'special');\\n    } else if (isRegExp(value)) {\\n      // Make RegExps say that they are RegExps\\n      base = RegExpPrototypeToString(\\n        constructor !== null ? value : new RegExp(value)\\n      );\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C 'RegExp');\\n      if (prefix !== 'RegExp ')\\n        base = `${prefix}${base}`;\\n      if ((keys.length === 0 && protoProps === undefined) ||\\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\\n        return ctx.stylize(base\\x2C 'regexp');\\n      }\\n    } else if (isDate(value)) {\\n      // Make dates with properties first say the date\\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\\n        DatePrototypeToString(value) :\\n        DatePrototypeToISOString(value);\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C 'Date');\\n      if (prefix !== 'Date ')\\n        base = `${prefix}${base}`;\\n      if (keys.length === 0 && protoProps === undefined) {\\n        return ctx.stylize(base\\x2C 'date');\\n      }\\n    } else if (isError(value)) {\\n      base = formatError(value\\x2C constructor\\x2C tag\\x2C ctx\\x2C keys);\\n      if (keys.length === 0 && protoProps === undefined)\\n        return base;\\n    } else if (isAnyArrayBuffer(value)) {\\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\\n      // Can't do the same for DataView because it has a non-primitive\\n      // .buffer property that we need to recurse for.\\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\\n        'SharedArrayBuffer';\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C arrayType);\\n      if (typedArray === undefined) {\\n        formatter = formatArrayBuffer;\\n      } else if (keys.length === 0 && protoProps === undefined) {\\n        return prefix +\\n              `{ byteLength: ${formatNumber(ctx.stylize\\x2C value.byteLength\\x2C false)} }`;\\n      }\\n      braces[0] = `${prefix}{`;\\n      ArrayPrototypeUnshift(keys\\x2C 'byteLength');\\n    } else if (isDataView(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'DataView')}{`;\\n      // .buffer goes last\\x2C it's not a primitive like the others.\\n      ArrayPrototypeUnshift(keys\\x2C 'byteLength'\\x2C 'byteOffset'\\x2C 'buffer');\\n    } else if (isPromise(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'Promise')}{`;\\n      formatter = formatPromise;\\n    } else if (isWeakSet(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'WeakSet')}{`;\\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\\n    } else if (isWeakMap(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'WeakMap')}{`;\\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\\n    } else if (isModuleNamespaceObject(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'Module')}{`;\\n      // Special handle keys for namespace objects.\\n      formatter = formatNamespaceObject.bind(null\\x2C keys);\\n    } else if (isBoxedPrimitive(value)) {\\n      base = getBoxedBase(value\\x2C ctx\\x2C keys\\x2C constructor\\x2C tag);\\n      if (keys.length === 0 && protoProps === undefined) {\\n        return base;\\n      }\\n    } else {\\n      if (keys.length === 0 && protoProps === undefined) {\\n        if (isExternal(value)) {\\n          const address = getExternalValue(value).toString(16);\\n          return ctx.stylize(`[External: ${address}]`\\x2C 'special');\\n        }\\n        return `${getCtxStyle(value\\x2C constructor\\x2C tag)}{}`;\\n      }\\n      braces[0] = `${getCtxStyle(value\\x2C constructor\\x2C tag)}{`;\\n    }\\n  }\\n\\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\\n    let constructorName = getCtxStyle(value\\x2C constructor\\x2C tag).slice(0\\x2C -1);\\n    if (constructor !== null)\\n      constructorName = `[${constructorName}]`;\\n    return ctx.stylize(constructorName\\x2C 'special');\\n  }\\n  recurseTimes += 1;\\n\\n  ctx.seen.push(value);\\n  ctx.currentDepth = recurseTimes;\\n  let output;\\n  const indentationLvl = ctx.indentationLvl;\\n  try {\\n    output = formatter(ctx\\x2C value\\x2C recurseTimes);\\n    for (i = 0; i < keys.length; i++) {\\n      output.push(\\n        formatProperty(ctx\\x2C value\\x2C recurseTimes\\x2C keys[i]\\x2C extrasType));\\n    }\\n    if (protoProps !== undefined) {\\n      output.push(...protoProps);\\n    }\\n  } catch (err) {\\n    const constructorName = getCtxStyle(value\\x2C constructor\\x2C tag).slice(0\\x2C -1);\\n    return handleMaxCallStackSize(ctx\\x2C err\\x2C constructorName\\x2C indentationLvl);\\n  }\\n  if (ctx.circular !== undefined) {\\n    const index = ctx.circular.get(value);\\n    if (index !== undefined) {\\n      const reference = ctx.stylize(`<ref *${index}>`\\x2C 'special');\\n      // Add reference always to the very beginning of the output.\\n      if (ctx.compact !== true) {\\n        base = base === '' ? reference : `${reference} ${base}`;\\n      } else {\\n        braces[0] = `${reference} ${braces[0]}`;\\n      }\\n    }\\n  }\\n  ctx.seen.pop();\\n\\n  if (ctx.sorted) {\\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\\n    if (extrasType === kObjectType) {\\n      output = output.sort(comparator);\\n    } else if (keys.length > 1) {\\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\\n      output.splice(output.length - keys.length\\x2C keys.length\\x2C ...sorted);\\n    }\\n  }\\n\\n  const res = reduceToSingleString(\\n    ctx\\x2C output\\x2C base\\x2C braces\\x2C extrasType\\x2C recurseTimes\\x2C value);\\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\\n  const newLength = budget + res.length;\\n  ctx.budget[ctx.indentationLvl] = newLength;\\n  // If any indentationLvl exceeds this limit\\x2C limit further inspecting to the\\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\\n  // This limit also makes sure that huge objects don't block the event loop\\n  // significantly.\\n  if (newLength > 2 ** 27) {\\n    ctx.depth = -1;\\n  }\\n  return res;\\n}\\n\\nfunction getIteratorBraces(type\\x2C tag) {\\n  if (tag !== `${type} Iterator`) {\\n    if (tag !== '')\\n      tag += '] [';\\n    tag += `${type} Iterator`;\\n  }\\n  return [`[${tag}] {`\\x2C '}'];\\n}\\n\\nfunction getBoxedBase(value\\x2C ctx\\x2C keys\\x2C constructor\\x2C tag) {\\n  let fn;\\n  let type;\\n  if (isNumberObject(value)) {\\n    fn = NumberPrototypeValueOf;\\n    type = 'Number';\\n  } else if (isStringObject(value)) {\\n    fn = StringPrototypeValueOf;\\n    type = 'String';\\n    // For boxed Strings\\x2C we have to remove the 0-n indexed entries\\x2C\\n    // since they just noisy up the output and are redundant\\n    // Make boxed primitive Strings look like such\\n    keys.splice(0\\x2C value.length);\\n  } else if (isBooleanObject(value)) {\\n    fn = BooleanPrototypeValueOf;\\n    type = 'Boolean';\\n  } else if (isBigIntObject(value)) {\\n    fn = BigIntPrototypeValueOf;\\n    type = 'BigInt';\\n  } else {\\n    fn = SymbolPrototypeValueOf;\\n    type = 'Symbol';\\n  }\\n  let base = `[${type}`;\\n  if (type !== constructor) {\\n    if (constructor === null) {\\n      base += ' (null prototype)';\\n    } else {\\n      base += ` (${constructor})`;\\n    }\\n  }\\n  base += `: ${formatPrimitive(stylizeNoColor\\x2C fn(value)\\x2C ctx)}]`;\\n  if (tag !== '' && tag !== constructor) {\\n    base += ` [${tag}]`;\\n  }\\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\\n    return base;\\n  return ctx.stylize(base\\x2C StringPrototypeToLowerCase(type));\\n}\\n\\nfunction getClassBase(value\\x2C constructor\\x2C tag) {\\n  const hasName = ObjectPrototypeHasOwnProperty(value\\x2C 'name');\\n  const name = (hasName && value.name) || '(anonymous)';\\n  let base = `class ${name}`;\\n  if (constructor !== 'Function' && constructor !== null) {\\n    base += ` [${constructor}]`;\\n  }\\n  if (tag !== '' && constructor !== tag) {\\n    base += ` [${tag}]`;\\n  }\\n  if (constructor !== null) {\\n    const superName = ObjectGetPrototypeOf(value).name;\\n    if (superName) {\\n      base += ` extends ${superName}`;\\n    }\\n  } else {\\n    base += ' extends [null prototype]';\\n  }\\n  return `[${base}]`;\\n}\\n\\nfunction getFunctionBase(value\\x2C constructor\\x2C tag) {\\n  const stringified = FunctionPrototypeToString(value);\\n  if (stringified.startsWith('class') && stringified.endsWith('}')) {\\n    const slice = stringified.slice(5\\x2C -1);\\n    const bracketIndex = slice.indexOf('{');\\n    if (bracketIndex !== -1 &&\\n        (!slice.slice(0\\x2C bracketIndex).includes('(') ||\\n          // Slow path to guarantee that it's indeed a class.\\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\\n      return getClassBase(value\\x2C constructor\\x2C tag);\\n    }\\n  }\\n  let type = 'Function';\\n  if (isGeneratorFunction(value)) {\\n    type = `Generator${type}`;\\n  }\\n  if (isAsyncFunction(value)) {\\n    type = `Async${type}`;\\n  }\\n  let base = `[${type}`;\\n  if (constructor === null) {\\n    base += ' (null prototype)';\\n  }\\n  if (value.name === '') {\\n    base += ' (anonymous)';\\n  } else {\\n    base += `: ${value.name}`;\\n  }\\n  base += ']';\\n  if (constructor !== type && constructor !== null) {\\n    base += ` ${constructor}`;\\n  }\\n  if (tag !== '' && constructor !== tag) {\\n    base += ` [${tag}]`;\\n  }\\n  return base;\\n}\\n\\nfunction identicalSequenceRange(a\\x2C b) {\\n  for (let i = 0; i < a.length - 3; i++) {\\n    // Find the first entry of b that matches the current entry of a.\\n    const pos = b.indexOf(a[i]);\\n    if (pos !== -1) {\\n      const rest = b.length - pos;\\n      if (rest > 3) {\\n        let len = 1;\\n        const maxLen = MathMin(a.length - i\\x2C rest);\\n        // Count the number of consecutive entries.\\n        while (maxLen > len && a[i + len] === b[pos + len]) {\\n          len++;\\n        }\\n        if (len > 3) {\\n          return { len\\x2C offset: i };\\n        }\\n      }\\n    }\\n  }\\n\\n  return { len: 0\\x2C offset: 0 };\\n}\\n\\nfunction getStackString(error) {\\n  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);\\n}\\n\\nfunction getStackFrames(ctx\\x2C err\\x2C stack) {\\n  const frames = stack.split('\\\\n');\\n\\n  // Remove stack frames identical to frames in cause.\\n  if (err.cause && isError(err.cause)) {\\n    const causeStack = getStackString(err.cause);\\n    const causeStackStart = causeStack.indexOf('\\\\n    at');\\n    if (causeStackStart !== -1) {\\n      const causeFrames = causeStack.slice(causeStackStart + 1).split('\\\\n');\\n      const { len\\x2C offset } = identicalSequenceRange(frames\\x2C causeFrames);\\n      if (len > 0) {\\n        const skipped = len - 2;\\n        const msg = `    ... ${skipped} lines matching cause stack trace ...`;\\n        frames.splice(offset + 1\\x2C skipped\\x2C ctx.stylize(msg\\x2C 'undefined'));\\n      }\\n    }\\n  }\\n  return frames;\\n}\\n\\nfunction improveStack(stack\\x2C constructor\\x2C name\\x2C tag) {\\n  // A stack trace may contain arbitrary data. Only manipulate the output\\n  // for \"regular errors\" (errors that \"look normal\") for now.\\n  let len = name.length;\\n\\n  if (constructor === null ||\\n      (name.endsWith('Error') &&\\n      stack.startsWith(name) &&\\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\\\n'))) {\\n    let fallback = 'Error';\\n    if (constructor === null) {\\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\\\]()-]+)(?::|\\\\n {4}at)/) ||\\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\\n      fallback = (start && start[1]) || '';\\n      len = fallback.length;\\n      fallback = fallback || 'Error';\\n    }\\n    const prefix = getPrefix(constructor\\x2C tag\\x2C fallback).slice(0\\x2C -1);\\n    if (name !== prefix) {\\n      if (prefix.includes(name)) {\\n        if (len === 0) {\\n          stack = `${prefix}: ${stack}`;\\n        } else {\\n          stack = `${prefix}${stack.slice(len)}`;\\n        }\\n      } else {\\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\\n      }\\n    }\\n  }\\n  return stack;\\n}\\n\\nfunction removeDuplicateErrorKeys(ctx\\x2C keys\\x2C err\\x2C stack) {\\n  if (!ctx.showHidden && keys.length !== 0) {\\n    for (const name of ['name'\\x2C 'message'\\x2C 'stack']) {\\n      const index = keys.indexOf(name);\\n      // Only hide the property in case it's part of the original stack\\n      if (index !== -1 && stack.includes(err[name])) {\\n        keys.splice(index\\x2C 1);\\n      }\\n    }\\n  }\\n}\\n\\nfunction formatError(err\\x2C constructor\\x2C tag\\x2C ctx\\x2C keys) {\\n  const name = err.name != null ? String(err.name) : 'Error';\\n  let stack = getStackString(err);\\n\\n  removeDuplicateErrorKeys(ctx\\x2C keys\\x2C err\\x2C stack);\\n\\n  if ('cause' in err &&\\n      (keys.length === 0 || !keys.includes('cause'))) {\\n    keys.push('cause');\\n  }\\n\\n  stack = improveStack(stack\\x2C constructor\\x2C name\\x2C tag);\\n\\n  // Ignore the error message if it's contained in the stack.\\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\\n  if (pos !== -1)\\n    pos += err.message.length;\\n  // Wrap the error in brackets in case it has no stack trace.\\n  const stackStart = stack.indexOf('\\\\n    at'\\x2C pos);\\n  if (stackStart === -1) {\\n    stack = `[${stack}]`;\\n  } else {\\n    let newStack = stack.slice(0\\x2C stackStart);\\n    const lines = getStackFrames(ctx\\x2C err\\x2C stack.slice(stackStart + 1));\\n    if (ctx.colors) {\\n      // Highlight userland code and node modules.\\n      for (const line of lines) {\\n        const core = line.match(coreModuleRegExp);\\n        if (core !== null && NativeModule.exists(core[1])) {\\n          newStack += `\\\\n${ctx.stylize(line\\x2C 'undefined')}`;\\n        } else {\\n          // This adds underscores to all node_modules to quickly identify them.\\n          let nodeModule;\\n          newStack += '\\\\n';\\n          let pos = 0;\\n          while ((nodeModule = nodeModulesRegExp.exec(line)) !== null) {\\n            // '/node_modules/'.length === 14\\n            newStack += line.slice(pos\\x2C nodeModule.index + 14);\\n            newStack += ctx.stylize(nodeModule[1]\\x2C 'module');\\n            pos = nodeModule.index + nodeModule[0].length;\\n          }\\n          newStack += pos === 0 ? line : line.slice(pos);\\n        }\\n      }\\n    } else {\\n      newStack += `\\\\n${lines.join('\\\\n')}`;\\n    }\\n    stack = newStack;\\n  }\\n  // The message and the stack have to be indented as well!\\n  if (ctx.indentationLvl !== 0) {\\n    const indentation = ' '.repeat(ctx.indentationLvl);\\n    stack = stack.replace(/\\\\n/g\\x2C `\\\\n${indentation}`);\\n  }\\n  return stack;\\n}\\n\\nfunction groupArrayElements(ctx\\x2C output\\x2C value) {\\n  let totalLength = 0;\\n  let maxLength = 0;\\n  let i = 0;\\n  let outputLength = output.length;\\n  if (ctx.maxArrayLength < output.length) {\\n    // This makes sure the \"... n more items\" part is not taken into account.\\n    outputLength--;\\n  }\\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\\n  const dataLen = new Array(outputLength);\\n  // Calculate the total length of all output entries and the individual max\\n  // entries length of all output entries. We have to remove colors first\\x2C\\n  // otherwise the length would not be calculated properly.\\n  for (; i < outputLength; i++) {\\n    const len = getStringWidth(output[i]\\x2C ctx.colors);\\n    dataLen[i] = len;\\n    totalLength += len + separatorSpace;\\n    if (maxLength < len)\\n      maxLength = len;\\n  }\\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\\n  // in-between two entries.\\n  const actualMax = maxLength + separatorSpace;\\n  // Check if at least three entries fit next to each other and prevent grouping\\n  // of arrays that contains entries of very different length (i.e.\\x2C if a single\\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\\n  // space in-between small entries would be enormous.\\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\\n\\n    const approxCharHeights = 2.5;\\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\\n    const biasedMax = MathMax(actualMax - 3 - averageBias\\x2C 1);\\n    // Dynamically check how many columns seem possible.\\n    const columns = MathMin(\\n      // Ideally a square should be drawn. We expect a character to be about 2.5\\n      // times as high as wide. This is the area formula to calculate a square\\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\\n      // Divide that by `actualMax` to receive the correct number of columns.\\n      // The added bias increases the columns for short entries.\\n      MathRound(\\n        MathSqrt(\\n          approxCharHeights * biasedMax * outputLength\\n        ) / biasedMax\\n      )\\x2C\\n      // Do not exceed the breakLength.\\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax)\\x2C\\n      // Limit array grouping for small `compact` modes as the user requested\\n      // minimal grouping.\\n      ctx.compact * 4\\x2C\\n      // Limit the columns to a maximum of fifteen.\\n      15\\n    );\\n    // Return with the original output if no grouping should happen.\\n    if (columns <= 1) {\\n      return output;\\n    }\\n    const tmp = [];\\n    const maxLineLength = [];\\n    for (let i = 0; i < columns; i++) {\\n      let lineMaxLength = 0;\\n      for (let j = i; j < output.length; j += columns) {\\n        if (dataLen[j] > lineMaxLength)\\n          lineMaxLength = dataLen[j];\\n      }\\n      lineMaxLength += separatorSpace;\\n      maxLineLength[i] = lineMaxLength;\\n    }\\n    let order = StringPrototypePadStart;\\n    if (value !== undefined) {\\n      for (let i = 0; i < output.length; i++) {\\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\\n          order = StringPrototypePadEnd;\\n          break;\\n        }\\n      }\\n    }\\n    // Each iteration creates a single line of grouped entries.\\n    for (let i = 0; i < outputLength; i += columns) {\\n      // The last lines may contain less entries than columns.\\n      const max = MathMin(i + columns\\x2C outputLength);\\n      let str = '';\\n      let j = i;\\n      for (; j < max - 1; j++) {\\n        // Calculate extra color padding in case it's active. This has to be\\n        // done line by line as some lines might contain more colors than\\n        // others.\\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\\n        str += order(`${output[j]}\\x2C `\\x2C padding\\x2C ' ');\\n      }\\n      if (order === StringPrototypePadStart) {\\n        const padding = maxLineLength[j - i] +\\n                        output[j].length -\\n                        dataLen[j] -\\n                        separatorSpace;\\n        str += StringPrototypePadStart(output[j]\\x2C padding\\x2C ' ');\\n      } else {\\n        str += output[j];\\n      }\\n      ArrayPrototypePush(tmp\\x2C str);\\n    }\\n    if (ctx.maxArrayLength < output.length) {\\n      ArrayPrototypePush(tmp\\x2C output[outputLength]);\\n    }\\n    output = tmp;\\n  }\\n  return output;\\n}\\n\\nfunction handleMaxCallStackSize(ctx\\x2C err\\x2C constructorName\\x2C indentationLvl) {\\n  if (isStackOverflowError(err)) {\\n    ctx.seen.pop();\\n    ctx.indentationLvl = indentationLvl;\\n    return ctx.stylize(\\n      `[${constructorName}: Inspection interrupted ` +\\n        'prematurely. Maximum call stack size exceeded.]'\\x2C\\n      'special'\\n    );\\n  }\\n  /* c8 ignore next */\\n  assert.fail(err.stack);\\n}\\n\\nfunction addNumericSeparator(integerString) {\\n  let result = '';\\n  let i = integerString.length;\\n  const start = integerString.startsWith('-') ? 1 : 0;\\n  for (; i >= start + 4; i -= 3) {\\n    result = `_${integerString.slice(i - 3\\x2C i)}${result}`;\\n  }\\n  return i === integerString.length ?\\n    integerString :\\n    `${integerString.slice(0\\x2C i)}${result}`;\\n}\\n\\nfunction addNumericSeparatorEnd(integerString) {\\n  let result = '';\\n  let i = 0;\\n  for (; i < integerString.length - 3; i += 3) {\\n    result += `${integerString.slice(i\\x2C i + 3)}_`;\\n  }\\n  return i === 0 ?\\n    integerString :\\n    `${result}${integerString.slice(i)}`;\\n}\\n\\nfunction formatNumber(fn\\x2C number\\x2C numericSeparator) {\\n  if (!numericSeparator) {\\n    // Format -0 as '-0'. Checking `number === -0` won't distinguish 0 from -0.\\n    if (ObjectIs(number\\x2C -0)) {\\n      return fn('-0'\\x2C 'number');\\n    }\\n    return fn(`${number}`\\x2C 'number');\\n  }\\n  const integer = MathTrunc(number);\\n  const string = String(integer);\\n  if (integer === number) {\\n    if (!NumberIsFinite(number) || string.includes('e')) {\\n      return fn(string\\x2C 'number');\\n    }\\n    return fn(`${addNumericSeparator(string)}`\\x2C 'number');\\n  }\\n  if (NumberIsNaN(number)) {\\n    return fn(string\\x2C 'number');\\n  }\\n  return fn(`${\\n    addNumericSeparator(string)\\n  }.${\\n    addNumericSeparatorEnd(String(number).slice(string.length + 1))\\n  }`\\x2C 'number');\\n}\\n\\nfunction formatBigInt(fn\\x2C bigint\\x2C numericSeparator) {\\n  const string = String(bigint);\\n  if (!numericSeparator) {\\n    return fn(`${string}n`\\x2C 'bigint');\\n  }\\n  return fn(`${addNumericSeparator(string)}n`\\x2C 'bigint');\\n}\\n\\nfunction formatPrimitive(fn\\x2C value\\x2C ctx) {\\n  if (typeof value === 'string') {\\n    let trailer = '';\\n    if (value.length > ctx.maxStringLength) {\\n      const remaining = value.length - ctx.maxStringLength;\\n      value = value.slice(0\\x2C ctx.maxStringLength);\\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\\n    }\\n    if (ctx.compact !== true &&\\n        // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\\n        // function.\\n        value.length > kMinLineLength &&\\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\\n      return value\\n        .split(/(?<=\\\\n)/)\\n        .map((line) => fn(strEscape(line)\\x2C 'string'))\\n        .join(` +\\\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\\n    }\\n    return fn(strEscape(value)\\x2C 'string') + trailer;\\n  }\\n  if (typeof value === 'number')\\n    return formatNumber(fn\\x2C value\\x2C ctx.numericSeparator);\\n  if (typeof value === 'bigint')\\n    return formatBigInt(fn\\x2C value\\x2C ctx.numericSeparator);\\n  if (typeof value === 'boolean')\\n    return fn(`${value}`\\x2C 'boolean');\\n  if (typeof value === 'undefined')\\n    return fn('undefined'\\x2C 'undefined');\\n  // es6 symbol primitive\\n  return fn(SymbolPrototypeToString(value)\\x2C 'symbol');\\n}\\n\\nfunction formatNamespaceObject(keys\\x2C ctx\\x2C value\\x2C recurseTimes) {\\n  const output = new Array(keys.length);\\n  for (let i = 0; i < keys.length; i++) {\\n    try {\\n      output[i] = formatProperty(ctx\\x2C value\\x2C recurseTimes\\x2C keys[i]\\x2C\\n                                 kObjectType);\\n    } catch (err) {\\n      assert(isNativeError(err) && err.name === 'ReferenceError');\\n      // Use the existing functionality. This makes sure the indentation and\\n      // line breaks are always correct. Otherwise it is very difficult to keep\\n      // this aligned\\x2C even though this is a hacky way of dealing with this.\\n      const tmp = { [keys[i]]: '' };\\n      output[i] = formatProperty(ctx\\x2C tmp\\x2C recurseTimes\\x2C keys[i]\\x2C kObjectType);\\n      const pos = output[i].lastIndexOf(' ');\\n      // We have to find the last whitespace and have to replace that value as\\n      // it will be visualized as a regular string.\\n      output[i] = output[i].slice(0\\x2C pos + 1) +\\n                  ctx.stylize('<uninitialized>'\\x2C 'special');\\n    }\\n  }\\n  // Reset the keys to an empty array. This prevents duplicated inspection.\\n  keys.length = 0;\\n  return output;\\n}\\n\\n// The array is sparse and/or has extra keys\\nfunction formatSpecialArray(ctx\\x2C value\\x2C recurseTimes\\x2C maxLength\\x2C output\\x2C i) {\\n  const keys = ObjectKeys(value);\\n  let index = i;\\n  for (; i < keys.length && output.length < maxLength; i++) {\\n    const key = keys[i];\\n    const tmp = +key;\\n    // Arrays can only have up to 2^32 - 1 entries\\n    if (tmp > 2 ** 32 - 2) {\\n      break;\\n    }\\n    if (`${index}` !== key) {\\n      if (!numberRegExp.test(key)) {\\n        break;\\n      }\\n      const emptyItems = tmp - index;\\n      const ending = emptyItems > 1 ? 's' : '';\\n      const message = `<${emptyItems} empty item${ending}>`;\\n      output.push(ctx.stylize(message\\x2C 'undefined'));\\n      index = tmp;\\n      if (output.length === maxLength) {\\n        break;\\n      }\\n    }\\n    output.push(formatProperty(ctx\\x2C value\\x2C recurseTimes\\x2C key\\x2C kArrayType));\\n    index++;\\n  }\\n  const remaining = value.length - index;\\n  if (output.length !== maxLength) {\\n    if (remaining > 0) {\\n      const ending = remaining > 1 ? 's' : '';\\n      const message = `<${remaining} empty item${ending}>`;\\n      output.push(ctx.stylize(message\\x2C 'undefined'));\\n    }\\n  } else if (remaining > 0) {\\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\\n  }\\n  return output;\\n}\\n\\nfunction formatArrayBuffer(ctx\\x2C value) {\\n  let buffer;\\n  try {\\n    buffer = new Uint8Array(value);\\n  } catch {\\n    return [ctx.stylize('(detached)'\\x2C 'special')];\\n  }\\n  if (hexSlice === undefined)\\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\\n  let str = StringPrototypeTrim(StringPrototypeReplace(\\n    hexSlice(buffer\\x2C 0\\x2C MathMin(ctx.maxArrayLength\\x2C buffer.length))\\x2C\\n    /(.{2})/g\\x2C '$1 '));\\n  const remaining = buffer.length - ctx.maxArrayLength;\\n  if (remaining > 0)\\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\\n  return [`${ctx.stylize('[Uint8Contents]'\\x2C 'special')}: <${str}>`];\\n}\\n\\nfunction formatArray(ctx\\x2C value\\x2C recurseTimes) {\\n  const valLen = value.length;\\n  const len = MathMin(MathMax(0\\x2C ctx.maxArrayLength)\\x2C valLen);\\n\\n  const remaining = valLen - len;\\n  const output = [];\\n  for (let i = 0; i < len; i++) {\\n    // Special handle sparse arrays.\\n    if (!ObjectPrototypeHasOwnProperty(value\\x2C i)) {\\n      return formatSpecialArray(ctx\\x2C value\\x2C recurseTimes\\x2C len\\x2C output\\x2C i);\\n    }\\n    output.push(formatProperty(ctx\\x2C value\\x2C recurseTimes\\x2C i\\x2C kArrayType));\\n  }\\n  if (remaining > 0)\\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\\n  return output;\\n}\\n\\nfunction formatTypedArray(value\\x2C length\\x2C ctx\\x2C ignored\\x2C recurseTimes) {\\n  const maxLength = MathMin(MathMax(0\\x2C ctx.maxArrayLength)\\x2C length);\\n  const remaining = value.length - maxLength;\\n  const output = new Array(maxLength);\\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\\n    formatNumber :\\n    formatBigInt;\\n  for (let i = 0; i < maxLength; ++i) {\\n    output[i] = elementFormatter(ctx.stylize\\x2C value[i]\\x2C ctx.numericSeparator);\\n  }\\n  if (remaining > 0) {\\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\\n  }\\n  if (ctx.showHidden) {\\n    // .buffer goes last\\x2C it's not a primitive like the others.\\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\\n    ctx.indentationLvl += 2;\\n    for (const key of [\\n      'BYTES_PER_ELEMENT'\\x2C\\n      'length'\\x2C\\n      'byteLength'\\x2C\\n      'byteOffset'\\x2C\\n      'buffer'\\x2C\\n    ]) {\\n      const str = formatValue(ctx\\x2C value[key]\\x2C recurseTimes\\x2C true);\\n      ArrayPrototypePush(output\\x2C `[${key}]: ${str}`);\\n    }\\n    ctx.indentationLvl -= 2;\\n  }\\n  return output;\\n}\\n\\nfunction formatSet(value\\x2C ctx\\x2C ignored\\x2C recurseTimes) {\\n  const output = [];\\n  ctx.indentationLvl += 2;\\n  for (const v of value) {\\n    ArrayPrototypePush(output\\x2C formatValue(ctx\\x2C v\\x2C recurseTimes));\\n  }\\n  ctx.indentationLvl -= 2;\\n  return output;\\n}\\n\\nfunction formatMap(value\\x2C ctx\\x2C ignored\\x2C recurseTimes) {\\n  const output = [];\\n  ctx.indentationLvl += 2;\\n  for (const { 0: k\\x2C 1: v } of value) {\\n    output.push(\\n      `${formatValue(ctx\\x2C k\\x2C recurseTimes)} => ${formatValue(ctx\\x2C v\\x2C recurseTimes)}`\\n    );\\n  }\\n  ctx.indentationLvl -= 2;\\n  return output;\\n}\\n\\nfunction formatSetIterInner(ctx\\x2C recurseTimes\\x2C entries\\x2C state) {\\n  const maxArrayLength = MathMax(ctx.maxArrayLength\\x2C 0);\\n  const maxLength = MathMin(maxArrayLength\\x2C entries.length);\\n  const output = new Array(maxLength);\\n  ctx.indentationLvl += 2;\\n  for (let i = 0; i < maxLength; i++) {\\n    output[i] = formatValue(ctx\\x2C entries[i]\\x2C recurseTimes);\\n  }\\n  ctx.indentationLvl -= 2;\\n  if (state === kWeak && !ctx.sorted) {\\n    // Sort all entries to have a halfway reliable output (if more entries than\\n    // retrieved ones exist\\x2C we can not reliably return the same output) if the\\n    // output is not sorted anyway.\\n    ArrayPrototypeSort(output);\\n  }\\n  const remaining = entries.length - maxLength;\\n  if (remaining > 0) {\\n    ArrayPrototypePush(output\\x2C\\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\\n  }\\n  return output;\\n}\\n\\nfunction formatMapIterInner(ctx\\x2C recurseTimes\\x2C entries\\x2C state) {\\n  const maxArrayLength = MathMax(ctx.maxArrayLength\\x2C 0);\\n  // Entries exist as [key1\\x2C val1\\x2C key2\\x2C val2\\x2C ...]\\n  const len = entries.length / 2;\\n  const remaining = len - maxArrayLength;\\n  const maxLength = MathMin(maxArrayLength\\x2C len);\\n  let output = new Array(maxLength);\\n  let i = 0;\\n  ctx.indentationLvl += 2;\\n  if (state === kWeak) {\\n    for (; i < maxLength; i++) {\\n      const pos = i * 2;\\n      output[i] =\\n        `${formatValue(ctx\\x2C entries[pos]\\x2C recurseTimes)} => ${formatValue(ctx\\x2C entries[pos + 1]\\x2C recurseTimes)}`;\\n    }\\n    // Sort all entries to have a halfway reliable output (if more entries than\\n    // retrieved ones exist\\x2C we can not reliably return the same output) if the\\n    // output is not sorted anyway.\\n    if (!ctx.sorted)\\n      output = output.sort();\\n  } else {\\n    for (; i < maxLength; i++) {\\n      const pos = i * 2;\\n      const res = [\\n        formatValue(ctx\\x2C entries[pos]\\x2C recurseTimes)\\x2C\\n        formatValue(ctx\\x2C entries[pos + 1]\\x2C recurseTimes)\\x2C\\n      ];\\n      output[i] = reduceToSingleString(\\n        ctx\\x2C res\\x2C ''\\x2C ['['\\x2C ']']\\x2C kArrayExtrasType\\x2C recurseTimes);\\n    }\\n  }\\n  ctx.indentationLvl -= 2;\\n  if (remaining > 0) {\\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\\n  }\\n  return output;\\n}\\n\\nfunction formatWeakCollection(ctx) {\\n  return [ctx.stylize('<items unknown>'\\x2C 'special')];\\n}\\n\\nfunction formatWeakSet(ctx\\x2C value\\x2C recurseTimes) {\\n  const entries = previewEntries(value);\\n  return formatSetIterInner(ctx\\x2C recurseTimes\\x2C entries\\x2C kWeak);\\n}\\n\\nfunction formatWeakMap(ctx\\x2C value\\x2C recurseTimes) {\\n  const entries = previewEntries(value);\\n  return formatMapIterInner(ctx\\x2C recurseTimes\\x2C entries\\x2C kWeak);\\n}\\n\\nfunction formatIterator(braces\\x2C ctx\\x2C value\\x2C recurseTimes) {\\n  const { 0: entries\\x2C 1: isKeyValue } = previewEntries(value\\x2C true);\\n  if (isKeyValue) {\\n    // Mark entry iterators as such.\\n    braces[0] = braces[0].replace(/ Iterator] {$/\\x2C ' Entries] {');\\n    return formatMapIterInner(ctx\\x2C recurseTimes\\x2C entries\\x2C kMapEntries);\\n  }\\n\\n  return formatSetIterInner(ctx\\x2C recurseTimes\\x2C entries\\x2C kIterator);\\n}\\n\\nfunction formatPromise(ctx\\x2C value\\x2C recurseTimes) {\\n  let output;\\n  const { 0: state\\x2C 1: result } = getPromiseDetails(value);\\n  if (state === kPending) {\\n    output = [ctx.stylize('<pending>'\\x2C 'special')];\\n  } else {\\n    ctx.indentationLvl += 2;\\n    const str = formatValue(ctx\\x2C result\\x2C recurseTimes);\\n    ctx.indentationLvl -= 2;\\n    output = [\\n      state === kRejected ?\\n        `${ctx.stylize('<rejected>'\\x2C 'special')} ${str}` :\\n        str\\x2C\\n    ];\\n  }\\n  return output;\\n}\\n\\nfunction formatProperty(ctx\\x2C value\\x2C recurseTimes\\x2C key\\x2C type\\x2C desc\\x2C\\n                        original = value) {\\n  let name\\x2C str;\\n  let extra = ' ';\\n  desc = desc || ObjectGetOwnPropertyDescriptor(value\\x2C key) ||\\n    { value: value[key]\\x2C enumerable: true };\\n  if (desc.value !== undefined) {\\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\\n    ctx.indentationLvl += diff;\\n    str = formatValue(ctx\\x2C desc.value\\x2C recurseTimes);\\n    if (diff === 3 && ctx.breakLength < getStringWidth(str\\x2C ctx.colors)) {\\n      extra = `\\\\n${' '.repeat(ctx.indentationLvl)}`;\\n    }\\n    ctx.indentationLvl -= diff;\\n  } else if (desc.get !== undefined) {\\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\\n    const s = ctx.stylize;\\n    const sp = 'special';\\n    if (ctx.getters && (ctx.getters === true ||\\n          (ctx.getters === 'get' && desc.set === undefined) ||\\n          (ctx.getters === 'set' && desc.set !== undefined))) {\\n      try {\\n        const tmp = FunctionPrototypeCall(desc.get\\x2C original);\\n        ctx.indentationLvl += 2;\\n        if (tmp === null) {\\n          str = `${s(`[${label}:`\\x2C sp)} ${s('null'\\x2C 'null')}${s(']'\\x2C sp)}`;\\n        } else if (typeof tmp === 'object') {\\n          str = `${s(`[${label}]`\\x2C sp)} ${formatValue(ctx\\x2C tmp\\x2C recurseTimes)}`;\\n        } else {\\n          const primitive = formatPrimitive(s\\x2C tmp\\x2C ctx);\\n          str = `${s(`[${label}:`\\x2C sp)} ${primitive}${s(']'\\x2C sp)}`;\\n        }\\n        ctx.indentationLvl -= 2;\\n      } catch (err) {\\n        const message = `<Inspection threw (${err.message})>`;\\n        str = `${s(`[${label}:`\\x2C sp)} ${message}${s" at the file end is broken
(node:2666) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2666) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.1/tick-processor.log is broken
"script-source,33,node:internal/process/promises,'use strict';\\n\\nconst {\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypeShift\\x2C\\n  Error\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  SafeWeakMap\\x2C\\n} = primordials;\\n\\nconst {\\n  tickInfo\\x2C\\n  promiseRejectEvents: {\\n    kPromiseRejectWithNoHandler\\x2C\\n    kPromiseHandlerAddedAfterReject\\x2C\\n    kPromiseResolveAfterResolved\\x2C\\n    kPromiseRejectAfterResolved\\n  }\\x2C\\n  setPromiseRejectCallback\\n} = internalBinding('task_queue');\\n\\nconst {\\n  noSideEffectsToString\\x2C\\n  triggerUncaughtException\\n} = internalBinding('errors');\\n\\nconst {\\n  pushAsyncContext\\x2C\\n  popAsyncContext\\x2C\\n  symbols: {\\n    async_id_symbol: kAsyncIdSymbol\\x2C\\n    trigger_async_id_symbol: kTriggerAsyncIdSymbol\\n  }\\n} = require('internal/async_hooks');\\nconst { isErrorStackTra" at the file end is broken
(node:2722) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2722) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.1/tick-processor.log is broken
"script-source,45,node:util,// Copyright Joyent\\x2C Inc. and other Node contributors.\\n//\\n// Permission is hereby granted\\x2C free of charge\\x2C to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \"Software\")\\x2C to deal in the Software without restriction\\x2C including\\n// without limitation the rights to use\\x2C copy\\x2C modify\\x2C merge\\x2C publish\\x2C\\n// distribute\\x2C sublicense\\x2C and/or sell copies of the Software\\x2C and to permit\\n// persons to whom the Software is furnished to do so\\x2C subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\"\\x2C WITHOUT WARRANTY OF ANY KIND\\x2C EXPRESS\\n// OR IMPLIED\\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY\\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\\x2C\\n// DAMAGES OR OTHER LIABILITY\\x2C WHETHER IN AN ACTION OF CONTRACT\\x2C TORT OR\\n// OTHERWISE\\x2C ARISING FROM\\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n'use strict';\\n\\nconst {\\n  ArrayIsArray\\x2C\\n  ArrayPrototypeJoin\\x2C\\n  ArrayPrototypePop\\x2C\\n  Date\\x2C\\n  DatePrototypeGetDate\\x2C\\n  DatePrototypeGetHours\\x2C\\n  DatePrototypeGetMinutes\\x2C\\n  DatePrototypeGetMonth\\x2C\\n  DatePrototypeGetSeconds\\x2C\\n  Error\\x2C\\n  FunctionPrototypeBind\\x2C\\n  NumberIsSafeInteger\\x2C\\n  ObjectDefineProperties\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectGetOwnPropertyDescriptors\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeToString\\x2C\\n  ObjectSetPrototypeOf\\x2C\\n  ReflectApply\\x2C\\n  StringPrototypePadStart\\x2C\\n} = primordials;\\n\\nconst {\\n  codes: {\\n    ERR_FALSY_VALUE_REJECTION\\x2C\\n    ERR_INVALID_ARG_TYPE\\x2C\\n    ERR_OUT_OF_RANGE\\n  }\\x2C\\n  errnoException\\x2C\\n  exceptionWithHostPort\\x2C\\n  hideStackFrames\\n} = require('internal/errors');\\nconst {\\n  format\\x2C\\n  formatWithOptions\\x2C\\n  inspect\\x2C\\n  stripVTControlCharacters\\x2C\\n} = require('internal/util/inspect');\\nconst { debuglog } = require('internal/util/debuglog');\\nconst {\\n  validateFunction\\x2C\\n  validateNumber\\x2C\\n} = require('internal/validators');\\nconst { TextDecoder\\x2C TextEncoder } = require('internal/encoding');\\nconst { isBuffer } = require('buffer').Buffer;\\nconst types = require('internal/util/types');\\n\\nconst {\\n  deprecate\\x2C\\n  getSystemErrorMap\\x2C\\n  getSystemErrorName: internalErrorName\\x2C\\n  promisify\\x2C\\n  toUSVString\\x2C\\n} = require('internal/util');\\n\\nlet internalDeepEqual;\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {arg is boolean}\\n */\\nfunction isBoolean(arg) {\\n  return typeof arg === 'boolean';\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {arg is null}\\n */\\nfunction isNull(arg) {\\n  return arg === null;\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {arg is (null | undefined)}\\n */\\nfunction isNullOrUndefined(arg) {\\n  return arg === null || arg === undefined;\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {arg is number}\\n */\\nfunction isNumber(arg) {\\n  return typeof arg === 'number';\\n}\\n\\n/**\\n * @param {any} arg\\n * @returns {arg is string}\\n */\\nfunction isString(arg) {\\n  return typeof arg === 'string';\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {arg is symbol}\\n */\\nfunction isSymbol(arg) {\\n  return typeof arg === 'symbol';\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {arg is undefined}\\n */\\nfunction isUndefined(arg) {\\n  return arg === undefined;\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {a is NonNullable<object>}\\n */\\nfunction isObject(arg) {\\n  return arg !== null && typeof arg === 'object';\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} e\\n * @returns {arg is Error}\\n */\\nfunction isError(e) {\\n  return ObjectPrototypeToString(e) === '[object Error]' || e instanceof Error;\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {arg is Function}\\n */\\nfunction isFunction(arg) {\\n  return typeof arg === 'function';\\n}\\n\\n/**\\n * @deprecated since v4.0.0\\n * @param {any} arg\\n * @returns {arg is (boolean | null | number | string | symbol | undefined)}\\n */\\nfunction isPrimitive(arg) {\\n  return arg === null ||\\n         (typeof arg !== 'object' && typeof arg !== 'function');\\n}\\n\\n/**\\n * @param {number} n\\n * @returns {string}\\n */\\nfunction pad(n) {\\n  return StringPrototypePadStart(n.toString()\\x2C 2\\x2C '0');\\n}\\n\\nconst months = ['Jan'\\x2C 'Feb'\\x2C 'Mar'\\x2C 'Apr'\\x2C 'May'\\x2C 'Jun'\\x2C 'Jul'\\x2C 'Aug'\\x2C 'Sep'\\x2C\\n                'Oct'\\x2C 'Nov'\\x2C 'Dec'];\\n\\n/**\\n * @returns {string}  26 Feb 16:19:34\\n */\\nfunction timestamp() {\\n  const d = new Date();\\n  const t = ArrayPrototypeJoin([\\n    pad(DatePrototypeGetHours(d))\\x2C\\n    pad(DatePrototypeGetMinutes(d))\\x2C\\n    pad(DatePrototypeGetSeconds(d))\\x2C\\n  ]\\x2C ':');\\n  return `${DatePrototypeGetDate(d)} ${months[DatePrototypeGetMonth(d)]} ${t}`;\\n}\\n\\nlet console;\\n/**\\n * Log is just a thin wrapper to console.log that prepends a timestamp\\n * @deprecated since v6.0.0\\n * @type {(...args: any[]) => void}\\n */\\nfunction log(...args) {\\n  if (!console) {\\n    console = require('internal/console/global');\\n  }\\n  console.log('%s - %s'\\x2C timestamp()\\x2C format(...args));\\n}\\n\\n/**\\n * Inherit the prototype methods from one constructor into another.\\n *\\n * The Function.prototype.inherits from lang.js rewritten as a standalone\\n * function (not on Function.prototype). NOTE: If this file is to be loaded\\n * during bootstrapping this function needs to be rewritten using some native\\n * functions as prototype setup using normal JavaScript does not work as\\n * expected during bootstrapping (see mirror.js in r114903).\\n *\\n * @param {Function} ctor Constructor function which needs to inherit the\\n *     prototype.\\n * @param {Function} superCtor Constructor function to inherit prototype from.\\n * @throws {TypeError} Will error if either constructor is null\\x2C or if\\n *     the super constructor lacks a prototype.\\n */\\nfunction inherits(ctor\\x2C superCtor) {\\n\\n  if (ctor === undefined || ctor === null)\\n    throw new ERR_INVALID_ARG_TYPE('ctor'\\x2C 'Function'\\x2C ctor);\\n\\n  if (superCtor === undefined || superCtor === null)\\n    throw new ERR_INVALID_ARG_TYPE('superCtor'\\x2C 'Function'\\x2C superCtor);\\n\\n  if (superCtor.prototype === undefined) {\\n    throw new ERR_INVALID_ARG_TYPE('superCtor.prototype'\\x2C\\n                                   'Object'\\x2C superCtor.prototype);\\n  }\\n  ObjectDefineProperty(ctor\\x2C 'super_'\\x2C {\\n    value: superCtor\\x2C\\n    writable: true\\x2C\\n    configurable: true\\n  });\\n  ObjectSetPrototypeOf(ctor.prototype\\x2C superCtor.prototype);\\n}\\n\\n/**\\n * @deprecated since v6.0.0\\n * @template T\\n * @template S\\n * @param {T} target\\n * @param {S} source\\n * @returns {S extends null ? T : (T & S)}\\n */\\nfunction _extend(target\\x2C source) {\\n  // Don't do anything if source isn't an object\\n  if (source === null || typeof source !== 'object') return target;\\n\\n  const keys = ObjectKeys(source);\\n  let i = keys.length;\\n  while (i--) {\\n    target[keys[i]] = source[keys[i]];\\n  }\\n  return target;\\n}\\n\\nconst callbackifyOnRejected = hideStackFrames((reason\\x2C cb) => {\\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\\n  // Because `null` is a special error value in callbacks which means \"no error\\n  // occurred\"\\x2C we error-wrap so the callback consumer can distinguish between\\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\\n  if (!reason) {\\n    reason = new ERR_FALSY_VALUE_REJECTION(reason);\\n  }\\n  return cb(reason);\\n});\\n\\n/**\\n * @template {(...args: any[]) => Promise<any>} T\\n * @param {T} original\\n * @returns {T extends (...args: infer TArgs) => Promise<infer TReturn> ?\\n *   ((...params: [...TArgs\\x2C ((err: Error\\x2C ret: TReturn) => any)]) => void) :\\n *   never\\n * }\\n */\\nfunction callbackify(original) {\\n  validateFunction(original\\x2C 'original');\\n\\n  // We DO NOT return the promise as it gives the user a false sense that\\n  // the promise is actually somehow related to the callback's execution\\n  // and that the callback throwing will reject the promise.\\n  function callbackified(...args) {\\n    const maybeCb = ArrayPrototypePop(args);\\n    validateFunction(maybeCb\\x2" at the file end is broken
(node:2778) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2778) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.1/tick-processor.log is broken
"tick,0x3fd2910d40,85036671,1,0x3fd3c5e550,3,0x0,0x3fbc04efdc,0x3fbc04f990,0x3fd00a43d5,0x3fbc04f130,0x3fbc04f990,0x3fd00a0536,0x3fbc04f130,0x3fbc04f990,0x3fd009c437,0x3fbc04f130,0x3fbc04f990,0x3fd009b0bc,0x" at the file end is broken
(node:2838) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
Command: out/Release/node /root/rpmbuild/BUILD/node-v16.14.2/test/tick-processor/test-tick-processor-cpp-core.js
--- TIMEOUT ---
=== release test-tick-processor-preprocess-flag ===                       
Path: tick-processor/test-tick-processor-preprocess-flag
(node:2917) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
(node:2931) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
(node:2931) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.3/tick-processor.log is broken
"tick,0x3fd6496e9c,3902221" at the file end is broken
(node:2988) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:2988) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.3/tick-processor.log is broken
"script-source,11,node:internal/errors,/* eslint node-core/documented-errors: \"error\" */\\n/* eslint node-core/alphabetize-errors: \"error\" */\\n/* eslint node-core/prefer-util-format-errors: \"error\" */\\n\\n'use strict';\\n\\n// The whole point behind this internal module is to allow Node.js to no\\n// longer be forced to treat every error message change as a semver-major\\n// change. The NodeError classes here all expose a `code` property whose\\n// value statically and permanently identifies the error. While the error\\n// message may change\\x2C the code should not.\\n\\nconst {\\n  AggregateError\\x2C\\n  ArrayFrom\\x2C\\n  ArrayIsArray\\x2C\\n  ArrayPrototypeFilter\\x2C\\n  ArrayPrototypeIncludes\\x2C\\n  ArrayPrototypeIndexOf\\x2C\\n  ArrayPrototypeJoin\\x2C\\n  ArrayPrototypeMap\\x2C\\n  ArrayPrototypePop\\x2C\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypeSlice\\x2C\\n  ArrayPrototypeSplice\\x2C\\n  ArrayPrototypeUnshift\\x2C\\n  Error\\x2C\\n  ErrorCaptureStackTrace\\x2C\\n  ErrorPrototypeToString\\x2C\\n  JSONStringify\\x2C\\n  MapPrototypeGet\\x2C\\n  MathAbs\\x2C\\n  MathMax\\x2C\\n  Number\\x2C\\n  NumberIsInteger\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectDefineProperties\\x2C\\n  ObjectIsExtensible\\x2C\\n  ObjectGetOwnPropertyDescriptor\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  RangeError\\x2C\\n  ReflectApply\\x2C\\n  RegExpPrototypeTest\\x2C\\n  SafeArrayIterator\\x2C\\n  SafeMap\\x2C\\n  SafeWeakMap\\x2C\\n  String\\x2C\\n  StringPrototypeEndsWith\\x2C\\n  StringPrototypeIncludes\\x2C\\n  StringPrototypeMatch\\x2C\\n  StringPrototypeSlice\\x2C\\n  StringPrototypeSplit\\x2C\\n  StringPrototypeStartsWith\\x2C\\n  StringPrototypeToLowerCase\\x2C\\n  Symbol\\x2C\\n  SymbolFor\\x2C\\n  SyntaxError\\x2C\\n  TypeError\\x2C\\n  URIError\\x2C\\n} = primordials;\\n\\nconst kIsNodeError = Symbol('kIsNodeError');\\n\\nconst isWindows = process.platform === 'win32';\\n\\nconst messages = new SafeMap();\\nconst codes = {};\\n\\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\\n// Sorted by a rough estimate on most frequently used entries.\\nconst kTypes = [\\n  'string'\\x2C\\n  'function'\\x2C\\n  'number'\\x2C\\n  'object'\\x2C\\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\\n  'Function'\\x2C\\n  'Object'\\x2C\\n  'boolean'\\x2C\\n  'bigint'\\x2C\\n  'symbol'\\x2C\\n];\\n\\nconst MainContextError = Error;\\nconst overrideStackTrace = new SafeWeakMap();\\nconst kNoOverride = Symbol('kNoOverride');\\nlet userStackTraceLimit;\\nconst nodeInternalPrefix = '__node_internal_';\\nconst prepareStackTrace = (globalThis\\x2C error\\x2C trace) => {\\n  // API for node internals to override error stack formatting\\n  // without interfering with userland code.\\n  if (overrideStackTrace.has(error)) {\\n    const f = overrideStackTrace.get(error);\\n    overrideStackTrace.delete(error);\\n    return f(error\\x2C trace);\\n  }\\n\\n  const firstFrame = trace[0]?.getFunctionName();\\n  if (firstFrame && StringPrototypeStartsWith(firstFrame\\x2C nodeInternalPrefix)) {\\n    for (let l = trace.length - 1; l >= 0; l--) {\\n      const fn = trace[l]?.getFunctionName();\\n      if (fn && StringPrototypeStartsWith(fn\\x2C nodeInternalPrefix)) {\\n        ArrayPrototypeSplice(trace\\x2C 0\\x2C l + 1);\\n        break;\\n      }\\n    }\\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`\\x2C\\n    // it is updated at every new exception in `captureLargerStackTrace`.\\n    if (trace.length > userStackTraceLimit)\\n      ArrayPrototypeSplice(trace\\x2C userStackTraceLimit);\\n  }\\n\\n  const globalOverride =\\n    maybeOverridePrepareStackTrace(globalThis\\x2C error\\x2C trace);\\n  if (globalOverride !== kNoOverride) return globalOverride;\\n\\n  // Normal error formatting:\\n  //\\n  // Error: Message\\n  //     at function (file)\\n  //     at file\\n  let errorString;\\n  if (kIsNodeError in error) {\\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\\n  } else {\\n    errorString = ErrorPrototypeToString(error);\\n  }\\n  if (trace.length === 0) {\\n    return errorString;\\n  }\\n  return `${errorString}\\\\n    at ${ArrayPrototypeJoin(trace\\x2C '\\\\n    at ')}`;\\n};\\n\\nconst maybeOverridePrepareStackTrace = (globalThis\\x2C error\\x2C trace) => {\\n  // Polyfill of V8's Error.prepareStackTrace API.\\n  // https://crbug.com/v8/7848\\n  // `globalThis` is the global that contains the constructor which\\n  // created `error`.\\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\\n    return globalThis.Error.prepareStackTrace(error\\x2C trace);\\n  }\\n  // We still have legacy usage that depends on the main context's `Error`\\n  // being used\\x2C even when the error is from a different context.\\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\\n  if (typeof MainContextError.prepareStackTrace === 'function') {\\n    return MainContextError.prepareStackTrace(error\\x2C trace);\\n  }\\n\\n  return kNoOverride;\\n};\\n\\nconst aggregateTwoErrors = hideStackFrames((innerError\\x2C outerError) => {\\n  if (innerError && outerError) {\\n    if (ArrayIsArray(outerError.errors)) {\\n      // If `outerError` is already an `AggregateError`.\\n      ArrayPrototypePush(outerError.errors\\x2C innerError);\\n      return outerError;\\n    }\\n    // eslint-disable-next-line no-restricted-syntax\\n    const err = new AggregateError(new SafeArrayIterator([\\n      outerError\\x2C\\n      innerError\\x2C\\n    ])\\x2C outerError.message);\\n    err.code = outerError.code;\\n    return err;\\n  }\\n  return innerError || outerError;\\n});\\n\\n// Lazily loaded\\nlet util;\\nlet assert;\\n\\nlet internalUtil = null;\\nfunction lazyInternalUtil() {\\n  if (!internalUtil) {\\n    internalUtil = require('internal/util');\\n  }\\n  return internalUtil;\\n}\\n\\nlet internalUtilInspect = null;\\nfunction lazyInternalUtilInspect() {\\n  if (!internalUtilInspect) {\\n    internalUtilInspect = require('internal/util/inspect');\\n  }\\n  return internalUtilInspect;\\n}\\n\\nlet buffer;\\nfunction lazyBuffer() {\\n  if (buffer === undefined)\\n    buffer = require('buffer').Buffer;\\n  return buffer;\\n}\\n\\nfunction isErrorStackTraceLimitWritable() {\\n  const desc = ObjectGetOwnPropertyDescriptor(Error\\x2C 'stackTraceLimit');\\n  if (desc === undefined) {\\n    return ObjectIsExtensible(Error);\\n  }\\n\\n  return ObjectPrototypeHasOwnProperty(desc\\x2C 'writable') ?\\n    desc.writable :\\n    desc.set !== undefined;\\n}\\n\\n// A specialized Error that includes an additional info property with\\n// additional information about the error condition.\\n// It has the properties present in a UVException but with a custom error\\n// message followed by the uv error code and uv error message.\\n// It also has its own error code with the original uv error context put into\\n// `err.info`.\\n// The context passed into this error must have .code\\x2C .syscall and .message\\x2C\\n// and may have .path and .dest.\\nclass SystemError extends Error {\\n  constructor(key\\x2C context) {\\n    const limit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    super();\\n    // Reset the limit and setting the name property.\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\\n    const prefix = getMessage(key\\x2C []\\x2C this);\\n    let message = `${prefix}: ${context.syscall} returned ` +\\n                  `${context.code} (${context.message})`;\\n\\n    if (context.path !== undefined)\\n      message += ` ${context.path}`;\\n    if (context.dest !== undefined)\\n      message += ` => ${context.dest}`;\\n\\n    captureLargerStackTrace(this);\\n\\n    this.code = key;\\n\\n    ObjectDefineProperties(this\\x2C {\\n      [kIsNodeError]: {\\n        value: true\\x2C\\n        enumerable: false\\x2C\\n        writable: false\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      name: {\\n        value: 'SystemError'\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      message: {\\n        value: message\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      info: {\\n        value: context\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n        writable: false\\x2C\\n      }\\x2C\\n      errno: {\\n        get() {\\n          return context.errno;\\n        }\\x2C\\n        set: (value) => {\\n          context.errno = value;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      syscall: {\\n        get() {\\n          return context.syscall;\\n        }\\x2C\\n        set: (value) => {\\n          context.syscall = value;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n    });\\n\\n    if (context.path !== undefined) {\\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\\n      // introduced. The `path` and `dest` properties in the context seem to\\n      // always be of type string. We should probably just remove the\\n      // `.toString()` and `Buffer.from()` operations and set the value on the\\n      // context as the user did.\\n      ObjectDefineProperty(this\\x2C 'path'\\x2C {\\n        get() {\\n          return context.path != null ?\\n            context.path.toString() : context.path;\\n        }\\x2C\\n        set: (value) => {\\n          context.path = value ?\\n            lazyBuffer().from(value.toString()) : undefined;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\n      });\\n    }\\n\\n    if (context.dest !== undefined) {\\n      ObjectDefineProperty(this\\x2C 'dest'\\x2C {\\n        get() {\\n          return context.dest != null ?\\n            context.dest.toString() : context.dest;\\n        }\\x2C\\n        set: (value) => {\\n          context.dest = value ?\\n            lazyBuffer().from(value.toString()) : undefined;\\n        }\\x2C\\n        enumerable: true\\x2C\\n        configurable: true\\n      });\\n    }\\n  }\\n\\n  toString() {\\n    return `${this.name} [${this.code}]: ${this.message}`;\\n  }\\n\\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes\\x2C ctx) {\\n    return lazyInternalUtilInspect().inspect(this\\x2C {\\n      ...ctx\\x2C\\n      getters: true\\x2C\\n      customInspect: false\\n    });\\n  }\\n}\\n\\nfunction makeSystemErrorWithCode(key) {\\n  return class NodeError extends SystemError {\\n    constructor(ctx) {\\n      super(key\\x2C ctx);\\n    }\\n  };\\n}\\n\\nfunction makeNodeErrorWithCode(Base\\x2C key) {\\n  return function NodeError(...args) {\\n    const limit = Error.stackTraceLimit;\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\\n    const error = new Base();\\n    // Reset the limit and setting the name property.\\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\\n    const message = getMessage(key\\x2C args\\x2C error);\\n    ObjectDefineProperties(error\\x2C {\\n      [kIsNodeError]: {\\n        value: true\\x2C\\n        enumerable: false\\x2C\\n        writable: false\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      message: {\\n        value: message\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n      toString: {\\n        value() {\\n          return `${this.name} [${key}]: ${this.message}`;\\n        }\\x2C\\n        enumerable: false\\x2C\\n        writable: true\\x2C\\n        configurable: true\\x2C\\n      }\\x2C\\n    });\\n    captureLargerStackTrace(error);\\n    error.code = key;\\n    return error;\\n  };\\n}\\n\\n/**\\n * This function removes unnecessary frames from Node.js core errors.\\n * @template {(...args: any[]) => any} T\\n * @type {(fn: T) => T}\\n */\\nfunction hideStackFrames(fn) {\\n  // We rename the functions that will be hidden to cut off the stacktrace\\n  // at the outermost one\\n  const hidden = nodeInternalPrefix + fn.name;\\n  ObjectDefineProperty(fn\\x2C 'name'\\x2C { value: hidden });\\n  return fn;\\n}\\n\\n// Utility function for registering the error codes. Only used here. Exported\\n// *only* to allow for testing.\\nfunction E(sym\\x2C val\\x2C def\\x2C ...otherClasses) {\\n  // Special case for SystemError that formats the error message differently\\n  // The SystemErrors only have SystemError as their base classes.\\n  messages.set(sym\\x2C val);\\n  if (def === SystemError) {\\n    def = makeSystemErrorWithCode(sym);\\n  } else {\\n    def = makeNodeErrorWithCode(def\\x2C sym);\\n  }\\n\\n  if (otherClasses.length !== 0) {\\n    otherClasses.forEach((clazz) => {\\n      def[clazz.name] = makeNodeErrorWithCode(clazz\\x2C sym);\\n    });\\n  }\\n  codes[sym] = def;\\n}\\n\\nfunction getMessage(key\\x2C args\\x2C self) {\\n  const msg = messages.get(key);\\n\\n  if (assert === undefined) assert = require('internal/assert');\\n\\n  if (typeof msg === 'function') {\\n    assert(\\n      msg.length <= args.length\\x2C // Default options do not count.\\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\\n        `match the required ones (${msg.length}).`\\n    );\\n    return ReflectApply(msg\\x2C self\\x2C args);\\n  }\\n\\n  const expectedLength =\\n    (StringPrototypeMatch(msg\\x2C /%[dfijoOs]/g) || []).length;\\n  assert(\\n    expectedLength === args.length\\x2C\\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\\n      `match the required ones (${expectedLength}).`\\n  );\\n  if (args.length === 0)\\n    return msg;\\n\\n  ArrayPrototypeUnshift(args\\x2C msg);\\n  return ReflectApply(lazyInternalUtilInspect().format\\x2C null\\x2C args);\\n}\\n\\nlet uvBinding;\\n\\nfunction lazyUv() {\\n  if (!uvBinding) {\\n    uvBinding = internalBinding('uv');\\n  }\\n  return uvBinding;\\n}\\n\\nconst uvUnmappedError = ['UNKNOWN'\\x2C 'unknown error'];\\n\\nfunction uvErrmapGet(name) {\\n  uvBinding = lazyUv();\\n  if (!uvBinding.errmap) {\\n    uvBinding.errmap = uvBinding.getErrorMap();\\n  }\\n  return MapPrototype" at the file end is broken
(node:3044) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:3044) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.3/tick-processor.log is broken
"script-source,20,node:internal/util/inspect,'use strict';\\n\\nconst {\\n  Array\\x2C\\n  ArrayIsArray\\x2C\\n  ArrayPrototypeFilter\\x2C\\n  ArrayPrototypeForEach\\x2C\\n  ArrayPrototypePop\\x2C\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypePushApply\\x2C\\n  ArrayPrototypeSort\\x2C\\n  ArrayPrototypeUnshift\\x2C\\n  BigIntPrototypeValueOf\\x2C\\n  BooleanPrototypeValueOf\\x2C\\n  DatePrototypeGetTime\\x2C\\n  DatePrototypeToISOString\\x2C\\n  DatePrototypeToString\\x2C\\n  ErrorPrototypeToString\\x2C\\n  FunctionPrototypeCall\\x2C\\n  FunctionPrototypeToString\\x2C\\n  JSONStringify\\x2C\\n  MapPrototypeGetSize\\x2C\\n  MapPrototypeEntries\\x2C\\n  MathFloor\\x2C\\n  MathMax\\x2C\\n  MathMin\\x2C\\n  MathRound\\x2C\\n  MathSqrt\\x2C\\n  MathTrunc\\x2C\\n  Number\\x2C\\n  NumberIsFinite\\x2C\\n  NumberIsNaN\\x2C\\n  NumberParseFloat\\x2C\\n  NumberParseInt\\x2C\\n  NumberPrototypeValueOf\\x2C\\n  Object\\x2C\\n  ObjectAssign\\x2C\\n  ObjectCreate\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectGetOwnPropertyDescriptor\\x2C\\n  ObjectGetOwnPropertyNames\\x2C\\n  ObjectGetOwnPropertySymbols\\x2C\\n  ObjectGetPrototypeOf\\x2C\\n  ObjectIs\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  ObjectPrototypePropertyIsEnumerable\\x2C\\n  ObjectSeal\\x2C\\n  ObjectSetPrototypeOf\\x2C\\n  ReflectOwnKeys\\x2C\\n  RegExp\\x2C\\n  RegExpPrototypeTest\\x2C\\n  RegExpPrototypeToString\\x2C\\n  SafeStringIterator\\x2C\\n  SafeMap\\x2C\\n  SafeSet\\x2C\\n  SetPrototypeGetSize\\x2C\\n  SetPrototypeValues\\x2C\\n  String\\x2C\\n  StringPrototypeCharCodeAt\\x2C\\n  StringPrototypeCodePointAt\\x2C\\n  StringPrototypeIncludes\\x2C\\n  StringPrototypeNormalize\\x2C\\n  StringPrototypePadEnd\\x2C\\n  StringPrototypePadStart\\x2C\\n  StringPrototypeRepeat\\x2C\\n  StringPrototypeReplace\\x2C\\n  StringPrototypeSlice\\x2C\\n  StringPrototypeSplit\\x2C\\n  StringPrototypeToLowerCase\\x2C\\n  StringPrototypeTrim\\x2C\\n  StringPrototypeValueOf\\x2C\\n  SymbolPrototypeToString\\x2C\\n  SymbolPrototypeValueOf\\x2C\\n  SymbolIterator\\x2C\\n  SymbolToStringTag\\x2C\\n  TypedArrayPrototypeGetLength\\x2C\\n  TypedArrayPrototypeGetSymbolToStringTag\\x2C\\n  Uint8Array\\x2C\\n  globalThis\\x2C\\n  uncurryThis\\x2C\\n} = primordials;\\n\\nconst {\\n  getOwnNonIndexProperties\\x2C\\n  getPromiseDetails\\x2C\\n  getProxyDetails\\x2C\\n  kPending\\x2C\\n  kRejected\\x2C\\n  previewEntries\\x2C\\n  getConstructorName: internalGetConstructorName\\x2C\\n  getExternalValue\\x2C\\n  propertyFilter: {\\n    ALL_PROPERTIES\\x2C\\n    ONLY_ENUMERABLE\\n  }\\n} = internalBinding('util');\\n\\nconst {\\n  customInspectSymbol\\x2C\\n  isError\\x2C\\n  join\\x2C\\n  removeColors\\n} = require('internal/util');\\n\\nconst {\\n  codes: {\\n    ERR_INVALID_ARG_TYPE\\n  }\\x2C\\n  isStackOverflowError\\n} = require('internal/errors');\\n\\nconst {\\n  isAsyncFunction\\x2C\\n  isGeneratorFunction\\x2C\\n  isAnyArrayBuffer\\x2C\\n  isArrayBuffer\\x2C\\n  isArgumentsObject\\x2C\\n  isBoxedPrimitive\\x2C\\n  isDataView\\x2C\\n  isExternal\\x2C\\n  isMap\\x2C\\n  isMapIterator\\x2C\\n  isModuleNamespaceObject\\x2C\\n  isNativeError\\x2C\\n  isPromise\\x2C\\n  isSet\\x2C\\n  isSetIterator\\x2C\\n  isWeakMap\\x2C\\n  isWeakSet\\x2C\\n  isRegExp\\x2C\\n  isDate\\x2C\\n  isTypedArray\\x2C\\n  isStringObject\\x2C\\n  isNumberObject\\x2C\\n  isBooleanObject\\x2C\\n  isBigIntObject\\x2C\\n} = require('internal/util/types');\\n\\nconst assert = require('internal/assert');\\n\\nconst { NativeModule } = require('internal/bootstrap/loaders');\\nconst {\\n  validateObject\\x2C\\n  validateString\\x2C\\n} = require('internal/validators');\\n\\nlet hexSlice;\\n\\nconst builtInObjects = new SafeSet(\\n  ArrayPrototypeFilter(\\n    ObjectGetOwnPropertyNames(globalThis)\\x2C\\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/\\x2C e)\\n  )\\n);\\n\\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\\n\\n// These options must stay in sync with `getUserOptions`. So if any option will\\n// be added or removed\\x2C `getUserOptions` must also be updated accordingly.\\nconst inspectDefaultOptions = ObjectSeal({\\n  showHidden: false\\x2C\\n  depth: 2\\x2C\\n  colors: false\\x2C\\n  customInspect: true\\x2C\\n  showProxy: false\\x2C\\n  maxArrayLength: 100\\x2C\\n  maxStringLength: 10000\\x2C\\n  breakLength: 80\\x2C\\n  compact: 3\\x2C\\n  sorted: false\\x2C\\n  getters: false\\x2C\\n  numericSeparator: false\\x2C\\n});\\n\\nconst kObjectType = 0;\\nconst kArrayType = 1;\\nconst kArrayExtrasType = 2;\\n\\n/* eslint-disable no-control-regex */\\nconst strEscapeSequencesRegExp = /[\\\\x00-\\\\x1f\\\\x27\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/;\\nconst strEscapeSequencesReplacer = /[\\\\x00-\\\\x1f\\\\x27\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/g;\\nconst strEscapeSequencesRegExpSingle = /[\\\\x00-\\\\x1f\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/;\\nconst strEscapeSequencesReplacerSingle = /[\\\\x00-\\\\x1f\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/g;\\n/* eslint-enable no-control-regex */\\n\\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\\n\\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\\\\\(]+ \\\\(|)node:(.+):\\\\d+:\\\\d+\\\\)?$/;\\nconst nodeModulesRegExp = /[/\\\\\\\\]node_modules[/\\\\\\\\](.+?)(?=[/\\\\\\\\])/g;\\n\\nconst classRegExp = /^(\\\\s+[^(]*?)\\\\s*{/;\\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\\nconst stripCommentsRegExp = /(\\\\/\\\\/.*?\\\\n)|(\\\\/\\\\*(.|\\\\n)*?\\\\*\\\\/)/g;\\n\\nconst kMinLineLength = 16;\\n\\n// Constants to map the iterator state.\\nconst kWeak = 0;\\nconst kIterator = 1;\\nconst kMapEntries = 2;\\n\\n// Escaped control characters (plus the single quote and the backslash). Use\\n// empty strings to fill up unused entries.\\nconst meta = [\\n  '\\\\\\\\x00'\\x2C '\\\\\\\\x01'\\x2C '\\\\\\\\x02'\\x2C '\\\\\\\\x03'\\x2C '\\\\\\\\x04'\\x2C '\\\\\\\\x05'\\x2C '\\\\\\\\x06'\\x2C '\\\\\\\\x07'\\x2C // x07\\n  '\\\\\\\\b'\\x2C '\\\\\\\\t'\\x2C '\\\\\\\\n'\\x2C '\\\\\\\\x0B'\\x2C '\\\\\\\\f'\\x2C '\\\\\\\\r'\\x2C '\\\\\\\\x0E'\\x2C '\\\\\\\\x0F'\\x2C           // x0F\\n  '\\\\\\\\x10'\\x2C '\\\\\\\\x11'\\x2C '\\\\\\\\x12'\\x2C '\\\\\\\\x13'\\x2C '\\\\\\\\x14'\\x2C '\\\\\\\\x15'\\x2C '\\\\\\\\x16'\\x2C '\\\\\\\\x17'\\x2C // x17\\n  '\\\\\\\\x18'\\x2C '\\\\\\\\x19'\\x2C '\\\\\\\\x1A'\\x2C '\\\\\\\\x1B'\\x2C '\\\\\\\\x1C'\\x2C '\\\\\\\\x1D'\\x2C '\\\\\\\\x1E'\\x2C '\\\\\\\\x1F'\\x2C // x1F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C \"\\\\\\\\'\"\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C      // x2F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x3F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x4F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C '\\\\\\\\\\\\\\\\'\\x2C ''\\x2C ''\\x2C ''\\x2C     // x5F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x6F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C '\\\\\\\\x7F'\\x2C    // x7F\\n  '\\\\\\\\x80'\\x2C '\\\\\\\\x81'\\x2C '\\\\\\\\x82'\\x2C '\\\\\\\\x83'\\x2C '\\\\\\\\x84'\\x2C '\\\\\\\\x85'\\x2C '\\\\\\\\x86'\\x2C '\\\\\\\\x87'\\x2C // x87\\n  '\\\\\\\\x88'\\x2C '\\\\\\\\x89'\\x2C '\\\\\\\\x8A'\\x2C '\\\\\\\\x8B'\\x2C '\\\\\\\\x8C'\\x2C '\\\\\\\\x8D'\\x2C '\\\\\\\\x8E'\\x2C '\\\\\\\\x8F'\\x2C // x8F\\n  '\\\\\\\\x90'\\x2C '\\\\\\\\x91'\\x2C '\\\\\\\\x92'\\x2C '\\\\\\\\x93'\\x2C '\\\\\\\\x94'\\x2C '\\\\\\\\x95'\\x2C '\\\\\\\\x96'\\x2C '\\\\\\\\x97'\\x2C // x97\\n  '\\\\\\\\x98'\\x2C '\\\\\\\\x99'\\x2C '\\\\\\\\x9A'\\x2C '\\\\\\\\x9B'\\x2C '\\\\\\\\x9C'\\x2C '\\\\\\\\x9D'\\x2C '\\\\\\\\x9E'\\x2C '\\\\\\\\x9F'\\x2C // x9F\\n];\\n\\n// Regex used for ansi escape code splitting\\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\\n// License: MIT\\x2C authors: @sindresorhus\\x2C Qix-\\x2C arjunmehta and LitoMore\\n// Matches all ansi escape code sequences in a string\\nconst ansiPattern = '[\\\\\\\\u001B\\\\\\\\u009B][[\\\\\\\\]()#;?]*' +\\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\\\\\d\\\\\\\\/#&.:=?%@~_]+)*' +\\n  '|[a-zA-Z\\\\\\\\d]+(?:;[-a-zA-Z\\\\\\\\d\\\\\\\\/#&.:=?%@~_]*)*)?\\\\\\\\u0007)' +\\n  '|(?:(?:\\\\\\\\d{1\\x2C4}(?:;\\\\\\\\d{0\\x2C4})*)?[\\\\\\\\dA-PR-TZcf-ntqry=><~]))';\\nconst ansi = new RegExp(ansiPattern\\x2C 'g');\\n\\nlet getStringWidth;\\n\\nfunction getUserOptions(ctx\\x2C isCrossContext) {\\n  const ret = {\\n    stylize: ctx.stylize\\x2C\\n    showHidden: ctx.showHidden\\x2C\\n    depth: ctx.depth\\x2C\\n    colors: ctx.colors\\x2C\\n    customInspect: ctx.customInspect\\x2C\\n    showProxy: ctx.showProxy\\x2C\\n    maxArrayLength: ctx.maxArrayLength\\x2C\\n    maxStringLength: ctx.maxStringLength\\x2C\\n    breakLength: ctx.breakLength\\x2C\\n    compact: ctx.compact\\x2C\\n    sorted: ctx.sorted\\x2C\\n    getters: ctx.getters\\x2C\\n    numericSeparator: ctx.numericSeparator\\x2C\\n    ...ctx.userOptions\\n  };\\n\\n  // Typically\\x2C the target value will be an instance of `Object`. If that is\\n  // *not* the case\\x2C the object may come from another vm.Context\\x2C and we want\\n  // to avoid passing it objects from this Context in that case\\x2C so we remove\\n  // the prototype from the returned object itself + the `stylize()` function\\x2C\\n  // and remove all other non-primitives\\x2C including non-primitive user options.\\n  if (isCrossContext) {\\n    ObjectSetPrototypeOf(ret\\x2C null);\\n    for (const key of ObjectKeys(ret)) {\\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\\n          ret[key] !== null) {\\n        delete ret[key];\\n      }\\n    }\\n    ret.stylize = ObjectSetPrototypeOf((value\\x2C flavour) => {\\n      let stylized;\\n      try {\\n        stylized = `${ctx.stylize(value\\x2C flavour)}`;\\n      } catch {\\n        // Continue regardless of error.\\n      }\\n\\n      if (typeof stylized !== 'string') return value;\\n      // `stylized` is a string as it should be\\x2C which is safe to pass along.\\n      return stylized;\\n    }\\x2C null);\\n  }\\n\\n  return ret;\\n}\\n\\n/**\\n * Echos the value of any input. Tries to print the value out\\n * in the best way possible given the different types.\\n *\\n * @param {any} value The value to print out.\\n * @param {object} opts Optional options object that alters the output.\\n */\\n/* Legacy: value\\x2C showHidden\\x2C depth\\x2C colors */\\nfunction inspect(value\\x2C opts) {\\n  // Default options\\n  const ctx = {\\n    budget: {}\\x2C\\n    indentationLvl: 0\\x2C\\n    seen: []\\x2C\\n    currentDepth: 0\\x2C\\n    stylize: stylizeNoColor\\x2C\\n    showHidden: inspectDefaultOptions.showHidden\\x2C\\n    depth: inspectDefaultOptions.depth\\x2C\\n    colors: inspectDefaultOptions.colors\\x2C\\n    customInspect: inspectDefaultOptions.customInspect\\x2C\\n    showProxy: inspectDefaultOptions.showProxy\\x2C\\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\\x2C\\n    maxStringLength: inspectDefaultOptions.maxStringLength\\x2C\\n    breakLength: inspectDefaultOptions.breakLength\\x2C\\n    compact: inspectDefaultOptions.compact\\x2C\\n    sorted: inspectDefaultOptions.sorted\\x2C\\n    getters: inspectDefaultOptions.getters\\x2C\\n    numericSeparator: inspectDefaultOptions.numericSeparator\\x2C\\n  };\\n  if (arguments.length > 1) {\\n    // Legacy...\\n    if (arguments.length > 2) {\\n      if (arguments[2] !== undefined) {\\n        ctx.depth = arguments[2];\\n      }\\n      if (arguments.length > 3 && arguments[3] !== undefined) {\\n        ctx.colors = arguments[3];\\n      }\\n    }\\n    // Set user-specified options\\n    if (typeof opts === 'boolean') {\\n      ctx.showHidden = opts;\\n    } else if (opts) {\\n      const optKeys = ObjectKeys(opts);\\n      for (let i = 0; i < optKeys.length; ++i) {\\n        const key = optKeys[i];\\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\\n        // this function public or add a new API with a similar or better\\n        // functionality.\\n        if (\\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\\x2C key) ||\\n          key === 'stylize') {\\n          ctx[key] = opts[key];\\n        } else if (ctx.userOptions === undefined) {\\n          // This is required to pass through the actual user input.\\n          ctx.userOptions = opts;\\n        }\\n      }\\n    }\\n  }\\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\\n  return formatValue(ctx\\x2C value\\x2C 0);\\n}\\ninspect.custom = customInspectSymbol;\\n\\nObjectDefineProperty(inspect\\x2C 'defaultOptions'\\x2C {\\n  get() {\\n    return inspectDefaultOptions;\\n  }\\x2C\\n  set(options) {\\n    validateObject(options\\x2C 'options');\\n    return ObjectAssign(inspectDefaultOptions\\x2C options);\\n  }\\n});\\n\\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\\n// Each color consists of an array with the color code as first entry and the\\n// reset code as second entry.\\nconst defaultFG = 39;\\nconst defaultBG = 49;\\ninspect.colors = ObjectAssign(ObjectCreate(null)\\x2C {\\n  reset: [0\\x2C 0]\\x2C\\n  bold: [1\\x2C 22]\\x2C\\n  dim: [2\\x2C 22]\\x2C // Alias: faint\\n  italic: [3\\x2C 23]\\x2C\\n  underline: [4\\x2C 24]\\x2C\\n  blink: [5\\x2C 25]\\x2C\\n  // Swap foreground and background colors\\n  inverse: [7\\x2C 27]\\x2C // Alias: swapcolors\\x2C swapColors\\n  hidden: [8\\x2C 28]\\x2C // Alias: conceal\\n  strikethrough: [9\\x2C 29]\\x2C // Alias: strikeThrough\\x2C crossedout\\x2C crossedOut\\n  doubleunderline: [21\\x2C 24]\\x2C // Alias: doubleUnderline\\n  black: [30\\x2C defaultFG]\\x2C\\n  red: [31\\x2C defaultFG]\\x2C\\n  green: [32\\x2C defaultFG]\\x2C\\n  yellow: [33\\x2C defaultFG]\\x2C\\n  blue: [34\\x2C defaultFG]\\x2C\\n  magenta: [35\\x2C defaultFG]\\x2C\\n  cyan: [36\\x2C defaultFG]\\x2C\\n  white: [37\\x2C defaultFG]\\x2C\\n  bgBlack: [40\\x2C defaultBG]\\x2C\\n  bgRed: [41\\x2C defaultBG]\\x2C\\n  bgGreen: [42\\x2C defaultBG]\\x2C\\n  bgYellow: [43\\x2C defaultBG]\\x2C\\n  bgBlue: [44\\x2C defaultBG]\\x2C\\n  bgMagenta: [45\\x2C defaultBG]\\x2C\\n  bgCyan: [46\\x2C defaultBG]\\x2C\\n  bgWhite: [47\\x2C defaultBG]\\x2C\\n  framed: [51\\x2C 54]\\x2C\\n  overlined: [53\\x2C 55]\\x2C\\n  gray: [90\\x2C defaultFG]\\x2C // Alias: grey\\x2C blackBright\\n  redBright: [91\\x2C defaultFG]\\x2C\\n  greenBright: [92\\x2C defaultFG]\\x2C\\n  yellowBright: [93\\x2C defaultFG]\\x2C\\n  blueBright: [94\\x2C defaultFG]\\x2C\\n  magentaBright: [95\\x2C defaultFG]\\x2C\\n  cyanBright: [96\\x2C defaultFG]\\x2C\\n  whiteBright: [97\\x2C defaultFG]\\x2C\\n  bgGray: [100\\x2C defaultBG]\\x2C // Alias: bgGrey\\x2C bgBlackBright\\n  bgRedBright: [101\\x2C defaultBG]\\x2C\\n  bgGreenBright: [102\\x2C defaultBG]\\x2C\\n  bgYellowBright: [103\\x2C defaultBG]\\x2C\\n  bgBlueBright: [104\\x2C defaultBG]\\x2C\\n  bgMagentaBright: [105\\x2C defaultBG]\\x2C\\n  bgCyanBright: [106\\x2C defaultBG]\\x2C\\n  bgWhiteBright: [107\\x2C defaultBG]\\x2C\\n});\\n\\nfunction defineColorAlias(target\\x2C alias) {\\n  ObjectDefineProperty(inspect.colors\\x2C alias\\x2C {\\n    get() {\\n      return this[target];\\n    }\\x2C\\n    set(value) {\\n      this[target] = value;\\n    }\\x2C\\n    configurable: true\\x2C\\n    enumerable: false\\n  });\\n}\\n\\ndefineColorAlias('gray'\\x2C 'grey');\\ndefineColorAlias('gray'\\x2C 'blackBright');\\ndefineColorAlias('bgGray'\\x2C 'bgGrey');\\ndefineColorAlias('bgGray'\\x2C 'bgBlackBright');\\ndefineColorAlias('dim'\\x2C 'faint');\\ndefineColorAlias('strikethrough'\\x2C 'crossedout');\\ndefineColorAlias('strikethrough'\\x2C 'strikeThrough');\\ndefineColorAlias('strikethrough'\\x2C 'crossedOut');\\ndefineColorAlias('hidden'\\x2C 'conceal');\\ndefineColorAlias('inverse'\\x2C 'swapColors');\\ndefineColorAlias('inverse'\\x2C 'swapcolors');\\ndefineColorAlias('doubleunderline'\\x2C 'doubleUnderline');\\n\\n// TODO(BridgeAR): Add function style support for more complex styles.\\n// Don't use 'blue' not visible on cmd.exe\\ninspect.styles = ObjectAssign(ObjectCreate(null)\\x2C {\\n  special: 'cyan'\\x2C\\n  number: 'yellow'\\x2C\\n  bigint: 'yellow'\\x2C\\n  boolean: 'yellow'\\x2C\\n  undefined: 'grey'\\x2C\\n  null: 'bold'\\x2C\\n  string: 'green'\\x2C\\n  symbol: 'green'\\x2C\\n  date: 'magenta'\\x2C\\n  // \"name\": intentionally not styling\\n  // TODO(BridgeAR): Highlight regular expressions properly.\\n  regexp: 'red'\\x2C\\n  module: 'underline'\\n});\\n\\nfunction addQuotes(str\\x2C quotes) {\\n  if (quotes === -1) {\\n    return `\"${str}\"`;\\n  }\\n  if (quotes === -2) {\\n    return `\\\\`${str}\\\\``;\\n  }\\n  return `'${str}'`;\\n}\\n\\nfunction escapeFn(str) {\\n  const charCode = StringPrototypeCharCodeAt(str);\\n  return meta.length > charCode ? meta[charCode] : `\\\\\\\\u${charCode.toString(16)}`;\\n}\\n\\n// Escape control characters\\x2C single quotes and the backslash.\\n// This is similar to JSON stringify escaping.\\nfunction strEscape(str) {\\n  let escapeTest = strEscapeSequencesRegExp;\\n  let escapeReplace = strEscapeSequencesReplacer;\\n  let singleQuote = 39;\\n\\n  // Check for double quotes. If not present\\x2C do not escape single quotes and\\n  // instead wrap the text in double quotes. If double quotes exist\\x2C check for\\n  // backticks. If they do not exist\\x2C use those as fallback instead of the\\n  // double quotes.\\n  if (StringPrototypeIncludes(str\\x2C \"'\")) {\\n    // This invalidates the charCode and therefore can not be matched for\\n    // anymore.\\n    if (!StringPrototypeIncludes(str\\x2C '\"')) {\\n      singleQuote = -1;\\n    } else if (!StringPrototypeIncludes(str\\x2C '`') &&\\n               !StringPrototypeIncludes(str\\x2C '${')) {\\n      singleQuote = -2;\\n    }\\n    if (singleQuote !== 39) {\\n      escapeTest = strEscapeSequencesRegExpSingle;\\n      escapeReplace = strEscapeSequencesReplacerSingle;\\n    }\\n  }\\n\\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\\n  if (str.length < 5000 && !RegExpPrototypeTest(escapeTest\\x2C str))\\n    return addQuotes(str\\x2C singleQuote);\\n  if (str.length > 100) {\\n    str = StringPrototypeReplace(str\\x2C escapeReplace\\x2C escapeFn);\\n    return addQuotes(str\\x2C singleQuote);\\n  }\\n\\n  let result = '';\\n  let last = 0;\\n  for (let i = 0; i < str.length; i++) {\\n    const point = StringPrototypeCharCodeAt(str\\x2C i);\\n    if (point === singleQuote ||\\n        point === 92 ||\\n        point < 32 ||\\n        (point > 126 && point < 160)) {\\n      if (last === i) {\\n        result += meta[point];\\n      } else {\\n        result += `${StringPrototypeSlice(str\\x2C last\\x2C i)}${meta[point]}`;\\n      }\\n      last = i + 1;\\n    } else if (point >= 0xd800 && point <= 0xdfff) {\\n      if (point <= 0xdbff && i + 1 < str.length) {\\n        const point = StringPrototypeCharCodeAt(str\\x2C i + 1);\\n        if (point >= 0xdc00 && point <= 0xdfff) {\\n          i++;\\n          continue;\\n        }\\n      }\\n      result += `${StringPrototypeSlice(str\\x2C last\\x2C i)}${`\\\\\\\\u${point.toString(16)}`}`;\\n      last = i + 1;\\n    }\\n  }\\n\\n  if (last !== str.length) {\\n    result += StringPrototypeSlice(str\\x2C last);\\n  }\\n  return addQuotes(result\\x2C singleQuote);\\n}\\n\\nfunction stylizeWithColor(str\\x2C styleType) {\\n  const style = inspect.styles[styleType];\\n  if (style !== undefined) {\\n    const color = inspect.colors[style];\\n    if (color !== undefined)\\n      return `\\\\u001b[${color[0]}m${str}\\\\u001b[${color[1]}m`;\\n  }\\n  return str;\\n}\\n\\nfunction stylizeNoColor(str) {\\n  return str;\\n}\\n\\n// Return a new empty array to push in the results of the default formatter.\\nfunction getEmptyFormatArray() {\\n  return [];\\n}\\n\\nfunction isInstanceof(object\\x2C proto) {\\n  try {\\n    return object instanceof proto;\\n  } catch {\\n    return false;\\n  }\\n}\\n\\nfunction getConstructorName(obj\\x2C ctx\\x2C recurseTimes\\x2C protoProps) {\\n  let firstProto;\\n  const tmp = obj;\\n  while (obj || isUndetectableObject(obj)) {\\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\\x2C 'constructor');\\n    if (descriptor !== undefined &&\\n        typeof descriptor.value === 'function' &&\\n        descriptor.value.name !== '' &&\\n        isInstanceof(tmp\\x2C descriptor.value)) {\\n      if (protoProps !== undefined &&\\n         (firstProto !== obj ||\\n         !builtInObjects.has(descriptor.value.name))) {\\n        addPrototypeProperties(\\n          ctx\\x2C tmp\\x2C firstProto || tmp\\x2C recurseTimes\\x2C protoProps);\\n      }\\n      return descriptor.value.name;\\n    }\\n\\n    obj = ObjectGetPrototypeOf(obj);\\n    if (firstProto === undefined) {\\n      firstProto = obj;\\n    }\\n  }\\n\\n  if (firstProto === null) {\\n    return null;\\n  }\\n\\n  const res = internalGetConstructorName(tmp);\\n\\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\\n    return `${res} <Complex prototype>`;\\n  }\\n\\n  const protoConstr = getConstructorName(\\n    firstProto\\x2C ctx\\x2C recurseTimes + 1\\x2C protoProps);\\n\\n  if (protoConstr === null) {\\n    return `${res} <${inspect(firstProto\\x2C {\\n      ...ctx\\x2C\\n      customInspect: false\\x2C\\n      depth: -1\\n    })}>`;\\n  }\\n\\n  return `${res} <${protoConstr}>`;\\n}\\n\\n// This function has the side effect of adding prototype properties to the\\n// `output` argument (which is an array). This is intended to highlight user\\n// defined prototype properties.\\nfunction addPrototypeProperties(ctx\\x2C main\\x2C obj\\x2C recurseTimes\\x2C output) {\\n  let depth = 0;\\n  let keys;\\n  let keySet;\\n  do {\\n    if (depth !== 0 || main === obj) {\\n      obj = ObjectGetPrototypeOf(obj);\\n      // Stop as soon as a null prototype is encountered.\\n      if (obj === null) {\\n        return;\\n      }\\n      // Stop as soon as a built-in object type is detected.\\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\\x2C 'constructor');\\n      if (descriptor !== undefined &&\\n          typeof descriptor.value === 'function' &&\\n          builtInObjects.has(descriptor.value.name)) {\\n        return;\\n      }\\n    }\\n\\n    if (depth === 0) {\\n      keySet = new SafeSet();\\n    } else {\\n      ArrayPrototypeForEach(keys\\x2C (key) => keySet.add(key));\\n    }\\n    // Get all own property names and symbols.\\n    keys = ReflectOwnKeys(obj);\\n    ArrayPrototypePush(ctx.seen\\x2C main);\\n    for (const key of keys) {\\n      // Ignore the `constructor` property and keys that exist on layers above.\\n      if (key === 'constructor' ||\\n          ObjectPrototypeHasOwnProperty(main\\x2C key) ||\\n          (depth !== 0 && keySet.has(key))) {\\n        continue;\\n      }\\n      const desc = ObjectGetOwnPropertyDescriptor(obj\\x2C key);\\n      if (typeof desc.value === 'function') {\\n        continue;\\n      }\\n      const value = formatProperty(\\n        ctx\\x2C obj\\x2C recurseTimes\\x2C key\\x2C kObjectType\\x2C desc\\x2C main);\\n      if (ctx.colors) {\\n        // Faint!\\n        ArrayPrototypePush(output\\x2C `\\\\u001b[2m${value}\\\\u001b[22m`);\\n      } else {\\n        ArrayPrototypePush(output\\x2C value);\\n      }\\n    }\\n    ArrayPrototypePop(ctx.seen);\\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\\n  // is not a good choice here\\x2C because it's as if the properties are declared\\n  // on the current object from the users perspective.\\n  } while (++depth !== 3);\\n}\\n\\nfunction getPrefix(constructor\\x2C tag\\x2C fallback\\x2C size = '') {\\n  if (constructor === null) {\\n    if (tag !== '' && fallback !== tag) {\\n      return `[${fallback}${size}: null prototype] [${tag}] `;\\n    }\\n    return `[${fallback}${size}: null prototype] `;\\n  }\\n\\n  if (tag !== '' && constructor !== tag) {\\n    return `${constructor}${size} [${tag}] `;\\n  }\\n  return `${constructor}${size} `;\\n}\\n\\n// Look up the keys of the object.\\nfunction getKeys(value\\x2C showHidden) {\\n  let keys;\\n  const symbols = ObjectGetOwnPropertySymbols(value);\\n  if (showHidden) {\\n    keys = ObjectGetOwnPropertyNames(value);\\n    if (symbols.length !== 0)\\n      ArrayPrototypePushApply(keys\\x2C symbols);\\n  } else {\\n    // This might throw if `value` is a Module Namespace Object from an\\n    // unevaluated module\\x2C but we don't want to perform the actual type\\n    // check because it's expensive.\\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\\n    // and modify this logic as needed.\\n    try {\\n      keys = ObjectKeys(value);\\n    } catch (err) {\\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\\n             isModuleNamespaceObject(value));\\n      keys = ObjectGetOwnPropertyNames(value);\\n    }\\n    if (symbols.length !== 0) {\\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\\x2C key);\\n      ArrayPrototypePushApply(keys\\x2C ArrayPrototypeFilter(symbols\\x2C filter));\\n    }\\n  }\\n  return keys;\\n}\\n\\nfunction getCtxStyle(value\\x2C constructor\\x2C tag) {\\n  let fallback = '';\\n  if (constructor === null) {\\n    fallback = internalGetConstructorName(value);\\n    if (fallback === tag) {\\n      fallback = 'Object';\\n    }\\n  }\\n  return getPrefix(constructor\\x2C tag\\x2C fallback);\\n}\\n\\nfunction formatProxy(ctx\\x2C proxy\\x2C recurseTimes) {\\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\\n    return ctx.stylize('Proxy [Array]'\\x2C 'special');\\n  }\\n  recurseTimes += 1;\\n  ctx.indentationLvl += 2;\\n  const res = [\\n    formatValue(ctx\\x2C proxy[0]\\x2C recurseTimes)\\x2C\\n    formatValue(ctx\\x2C proxy[1]\\x2C recurseTimes)\\x2C\\n  ];\\n  ctx.indentationLvl -= 2;\\n  return reduceToSingleString(\\n    ctx\\x2C res\\x2C ''\\x2C ['Proxy ['\\x2C ']']\\x2C kArrayExtrasType\\x2C recurseTimes);\\n}\\n\\n// Note: using `formatValue` directly requires the indentation level to be\\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\\n// value afterwards again.\\nfunction formatValue(ctx\\x2C value\\x2C recurseTimes\\x2C typedArray) {\\n  // Primitive types cannot have properties.\\n  if (typeof value !== 'object' &&\\n      typeof value !== 'function' &&\\n      !isUndetectableObject(value)) {\\n    return formatPrimitive(ctx.stylize\\x2C value\\x2C ctx);\\n  }\\n  if (value === null) {\\n    return ctx.stylize('null'\\x2C 'null');\\n  }\\n\\n  // Memorize the context for custom inspection on proxies.\\n  const context = value;\\n  // Always check for proxies to prevent side effects and to prevent triggering\\n  // any proxy handlers.\\n  const proxy = getProxyDetails(value\\x2C !!ctx.showProxy);\\n  if (proxy !== undefined) {\\n    if (ctx.showProxy) {\\n      return formatProxy(ctx\\x2C proxy\\x2C recurseTimes);\\n    }\\n    value = proxy;\\n  }\\n\\n  // Provide a hook for user-specified inspect functions.\\n  // Check that value is an object with an inspect function on it.\\n  if (ctx.customInspect) {\\n    const maybeCustom = value[customInspectSymbol];\\n    if (typeof maybeCustom === 'function' &&\\n        // Filter out the util module\\x2C its inspect function is special.\\n        maybeCustom !== inspect &&\\n        // Also filter out any prototype objects using the circular check.\\n        !(value.constructor && value.constructor.prototype === value)) {\\n      // This makes sure the recurseTimes are reported as before while using\\n      // a counter internally.\\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\\n      const isCrossContext =\\n        proxy !== undefined || !(context instanceof Object);\\n      const ret = FunctionPrototypeCall(\\n        maybeCustom\\x2C\\n        context\\x2C\\n        depth\\x2C\\n        getUserOptions(ctx\\x2C isCrossContext)\\x2C\\n        inspect\\n      );\\n      // If the custom inspection method returned `this`\\x2C don't go into\\n      // infinite recursion.\\n      if (ret !== context) {\\n        if (typeof ret !== 'string') {\\n          return formatValue(ctx\\x2C ret\\x2C recurseTimes);\\n        }\\n        return ret.replace(/\\\\n/g\\x2C `\\\\n${' '.repeat(ctx.indentationLvl)}`);\\n      }\\n    }\\n  }\\n\\n  // Using an array here is actually better for the average case than using\\n  // a Set. `seen` will only check for the depth and will never grow too large.\\n  if (ctx.seen.includes(value)) {\\n    let index = 1;\\n    if (ctx.circular === undefined) {\\n      ctx.circular = new SafeMap();\\n      ctx.circular.set(value\\x2C index);\\n    } else {\\n      index = ctx.circular.get(value);\\n      if (index === undefined) {\\n        index = ctx.circular.size + 1;\\n        ctx.circular.set(value\\x2C index);\\n      }\\n    }\\n    return ctx.stylize(`[Circular *${index}]`\\x2C 'special');\\n  }\\n\\n  return formatRaw(ctx\\x2C value\\x2C recurseTimes\\x2C typedArray);\\n}\\n\\nfunction formatRaw(ctx\\x2C value\\x2C recurseTimes\\x2C typedArray) {\\n  let keys;\\n  let protoProps;\\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\\n    protoProps = [];\\n  }\\n\\n  const constructor = getConstructorName(value\\x2C ctx\\x2C recurseTimes\\x2C protoProps);\\n  // Reset the variable to check for this later on.\\n  if (protoProps !== undefined && protoProps.length === 0) {\\n    protoProps = undefined;\\n  }\\n\\n  let tag = value[SymbolToStringTag];\\n  // Only list the tag in case it's non-enumerable / not an own property.\\n  // Otherwise we'd print this twice.\\n  if (typeof tag !== 'string' ||\\n      (tag !== '' &&\\n      (ctx.showHidden ?\\n        ObjectPrototypeHasOwnProperty :\\n        ObjectPrototypePropertyIsEnumerable)(\\n        value\\x2C SymbolToStringTag\\n      ))) {\\n    tag = '';\\n  }\\n  let base = '';\\n  let formatter = getEmptyFormatArray;\\n  let braces;\\n  let noIterator = true;\\n  let i = 0;\\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\\n\\n  let extrasType = kObjectType;\\n\\n  // Iterators and the rest are split to reduce checks.\\n  // We have to check all values in case the constructor is set to null.\\n  // Otherwise it would not possible to identify all types properly.\\n  if (value[SymbolIterator] || constructor === null) {\\n    noIterator = false;\\n    if (ArrayIsArray(value)) {\\n      // Only set the constructor for non ordinary (\"Array [...]\") arrays.\\n      const prefix = (constructor !== 'Array' || tag !== '') ?\\n        getPrefix(constructor\\x2C tag\\x2C 'Array'\\x2C `(${value.length})`) :\\n        '';\\n      keys = getOwnNonIndexProperties(value\\x2C filter);\\n      braces = [`${prefix}[`\\x2C ']'];\\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\\n        return `${braces[0]}]`;\\n      extrasType = kArrayExtrasType;\\n      formatter = formatArray;\\n    } else if (isSet(value)) {\\n      const size = SetPrototypeGetSize(value);\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C 'Set'\\x2C `(${size})`);\\n      keys = getKeys(value\\x2C ctx.showHidden);\\n      formatter = constructor !== null ?\\n        formatSet.bind(null\\x2C value) :\\n        formatSet.bind(null\\x2C SetPrototypeValues(value));\\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\\n        return `${prefix}{}`;\\n      braces = [`${prefix}{`\\x2C '}'];\\n    } else if (isMap(value)) {\\n      const size = MapPrototypeGetSize(value);\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C 'Map'\\x2C `(${size})`);\\n      keys = getKeys(value\\x2C ctx.showHidden);\\n      formatter = constructor !== null ?\\n        formatMap.bind(null\\x2C value) :\\n        formatMap.bind(null\\x2C MapPrototypeEntries(value));\\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\\n        return `${prefix}{}`;\\n      braces = [`${prefix}{`\\x2C '}'];\\n    } else if (isTypedArray(value)) {\\n      keys = getOwnNonIndexProperties(value\\x2C filter);\\n      let bound = value;\\n      let fallback = '';\\n      if (constructor === null) {\\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\\n        // Reconstruct the array information.\\n        bound = new primordials[fallback](value);\\n      }\\n      const size = TypedArrayPrototypeGetLength(value);\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C fallback\\x2C `(${size})`);\\n      braces = [`${prefix}[`\\x2C ']'];\\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\\n        return `${braces[0]}]`;\\n      // Special handle the value. The original value is required below. The\\n      // bound function is required to reconstruct missing information.\\n      formatter = formatTypedArray.bind(null\\x2C bound\\x2C size);\\n      extrasType = kArrayExtrasType;\\n    } else if (isMapIterator(value)) {\\n      keys = getKeys(value\\x2C ctx.showHidden);\\n      braces = getIteratorBraces('Map'\\x2C tag);\\n      // Add braces to the formatter parameters.\\n      formatter = formatIterator.bind(null\\x2C braces);\\n    } else if (isSetIterator(value)) {\\n      keys = getKeys(value\\x2C ctx.showHidden);\\n      braces = getIteratorBraces('Set'\\x2C tag);\\n      // Add braces to the formatter parameters.\\n      formatter = formatIterator.bind(null\\x2C braces);\\n    } else {\\n      noIterator = true;\\n    }\\n  }\\n  if (noIterator) {\\n    keys = getKeys(value\\x2C ctx.showHidden);\\n    braces = ['{'\\x2C '}'];\\n    if (constructor === 'Object') {\\n      if (isArgumentsObject(value)) {\\n        braces[0] = '[Arguments] {';\\n      } else if (tag !== '') {\\n        braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'Object')}{`;\\n      }\\n      if (keys.length === 0 && protoProps === undefined) {\\n        return `${braces[0]}}`;\\n      }\\n    } else if (typeof value === 'function') {\\n      base = getFunctionBase(value\\x2C constructor\\x2C tag);\\n      if (keys.length === 0 && protoProps === undefined)\\n        return ctx.stylize(base\\x2C 'special');\\n    } else if (isRegExp(value)) {\\n      // Make RegExps say that they are RegExps\\n      base = RegExpPrototypeToString(\\n        constructor !== null ? value : new RegExp(value)\\n      );\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C 'RegExp');\\n      if (prefix !== 'RegExp ')\\n        base = `${prefix}${base}`;\\n      if ((keys.length === 0 && protoProps === undefined) ||\\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\\n        return ctx.stylize(base\\x2C 'regexp');\\n      }\\n    } else if (isDate(value)) {\\n      // Make dates with properties first say the date\\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\\n        DatePrototypeToString(value) :\\n        DatePrototypeToISOString(value);\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C 'Date');\\n      if (prefix !== 'Date ')\\n        base = `${prefix}${base}`;\\n      if (keys.length === 0 && protoProps === undefined) {\\n        return ctx.stylize(base\\x2C 'date');\\n      }\\n    } else if (isError(value)) {\\n      base = formatError(value\\x2C constructor\\x2C tag\\x2C ctx\\x2C keys);\\n      if (keys.length === 0 && protoProps === undefined)\\n        return base;\\n    } else if (isAnyArrayBuffer(value)) {\\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\\n      // Can't do the same for DataView because it has a non-primitive\\n      // .buffer property that we need to recurse for.\\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\\n        'SharedArrayBuffer';\\n      const prefix = getPrefix(constructor\\x2C tag\\x2C arrayType);\\n      if (typedArray === undefined) {\\n        formatter = formatArrayBuffer;\\n      } else if (keys.length === 0 && protoProps === undefined) {\\n        return prefix +\\n              `{ byteLength: ${formatNumber(ctx.stylize\\x2C value.byteLength\\x2C false)} }`;\\n      }\\n      braces[0] = `${prefix}{`;\\n      ArrayPrototypeUnshift(keys\\x2C 'byteLength');\\n    } else if (isDataView(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'DataView')}{`;\\n      // .buffer goes last\\x2C it's not a primitive like the others.\\n      ArrayPrototypeUnshift(keys\\x2C 'byteLength'\\x2C 'byteOffset'\\x2C 'buffer');\\n    } else if (isPromise(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'Promise')}{`;\\n      formatter = formatPromise;\\n    } else if (isWeakSet(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'WeakSet')}{`;\\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\\n    } else if (isWeakMap(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'WeakMap')}{`;\\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\\n    } else if (isModuleNamespaceObject(value)) {\\n      braces[0] = `${getPrefix(constructor\\x2C tag\\x2C 'Module')}{`;\\n      // Special handle keys for namespace objects.\\n      formatter = formatNamespaceObject.bind(null\\x2C keys);\\n    } else if (isBoxedPrimitive(value)) {\\n      base = getBoxedBase(value\\x2C ctx\\x2C keys\\x2C constructor\\x2C tag);\\n      if (keys.length === 0 && protoProps === undefined) {\\n        return base;\\n      }\\n    } else {\\n      if (keys.length === 0 && protoProps === undefined) {\\n        if (isExternal(value)) {\\n          const address = getExternalValue(value).toString(16);\\n          return ctx.stylize(`[External: ${address}]`\\x2C 'special');\\n        }\\n        return `${getCtxStyle(value\\x2C constructor\\x2C tag)}{}`;\\n      }\\n      braces[0] = `${getCtxStyle(value\\x2C constructor\\x2C tag)}{`;\\n    }\\n  }\\n\\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\\n    let constructorName = getCtxStyle(value\\x2C constructor\\x2C tag).slice(0\\x2C -1);\\n    if (constructor !== null)\\n      constructorName = `[${constructorName}]`;\\n    return ctx.stylize(constructorName\\x2C 'special');\\n  }\\n  recurseTimes += 1;\\n\\n  ctx.seen.push(value);\\n  ctx.currentDepth = recurseTimes;\\n  let output;\\n  const indentationLvl = ctx.indentationLvl;\\n  try {\\n    output = formatter(ctx\\x2C value\\x2C recurseTimes);\\n    for (i = 0; i < keys.length; i++) {\\n      output.push(\\n        formatProperty(ctx\\x2C value\\x2C recurseTimes\\x2C keys[i]\\x2C extrasType));\\n    }\\n    if (protoProps !== undefined) {\\n      output.push(...protoProps);\\n    }\\n  } catch (err) {\\n    const constructorName = getCtxStyle(value\\x2C constructor\\x2C tag).slice(0\\x2C -1);\\n    return handleMaxCallStackSize(ctx\\x2C err\\x2C constructorName\\x2C indentationLvl);\\n  }\\n  if (ctx.circular !== undefined) {\\n    const index = ctx.circular.get(value);\\n    if (index !== undefined) {\\n      const reference = ctx.stylize(`<ref *${index}>`\\x2C 'special');\\n      // Add reference always to the very beginning of the output.\\n      if (ctx.compact !== true) {\\n        base = base === '' ? reference : `${reference} ${base}`;\\n      } else {\\n        braces[0] = `${reference} ${braces[0]}`;\\n      }\\n    }\\n  }\\n  ctx.seen.pop();\\n\\n  if (ctx.sorted) {\\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\\n    if (extrasType === kObjectType) {\\n      output = output.sort(comparator);\\n    } else if (keys.length > 1) {\\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\\n      output.splice(output.length - keys.length\\x2C keys.length\\x2C ...sorted);\\n    }\\n  }\\n\\n  const res = reduceToSingleString(\\n    ctx\\x2C output\\x2C base\\x2C braces\\x2C extrasType\\x2C recurseTimes\\x2C value);\\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\\n  const newLength = budget + res.length;\\n  ctx.budget[ctx.indentationLvl] = newLength;\\n  // If any indentationLvl exceeds this limit\\x2C limit further inspecting to the\\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\\n  // This limit also makes sure that huge objects don't block the event loop\\n  // significantly.\\n  if (newLength > 2 ** 27) {\\n    ctx.depth = -1;\\n  }\\n  return res;\\n}\\n\\nfunction getIteratorBraces(type\\x2C tag) {\\n  if (tag !== `${type} Iterator`) {\\n    if (tag !== '')\\n      tag += '] [';\\n    tag += `${type} Iterator`;\\n  }\\n  return [`[${tag}] {`\\x2C '}'];\\n}\\n\\nfunction getBoxedBase(value\\x2C ctx\\x2C keys\\x2C constructor\\x2C tag) {\\n  let fn;\\n  let type;\\n  if (isNumberObject(value)) {\\n    fn = NumberPrototypeValueOf;\\n    type = 'Number';\\n  } else if (isStringObject(value)) {\\n    fn = StringPrototypeValueOf;\\n    type = 'String';\\n    // For boxed Strings\\x2C we have to remove the 0-n indexed entries\\x2C\\n    // since they just noisy up the output and are redundant\\n    // Make boxed primitive Strings look like such\\n    keys.splice(0\\x2C value.length);\\n  } else if (isBooleanObject(value)) {\\n    fn = BooleanPrototypeValueOf;\\n    type = 'Boolean';\\n  } else if (isBigIntObject(value)) {\\n    fn = BigIntPrototypeValueOf;\\n    type = 'BigInt';\\n  } else {\\n    fn = SymbolPrototypeValueOf;\\n    type = 'Symbol';\\n  }\\n  let base = `[${type}`;\\n  if (type !== constructor) {\\n    if (constructor === null) {\\n      base += ' (null prototype)';\\n    } else {\\n      base += ` (${constructor})`;\\n    }\\n  }\\n  base += `: ${formatPrimitive(stylizeNoColor\\x2C fn(value)\\x2C ctx)}]`;\\n  if (tag !== '' && tag !== constructor) {\\n    base += ` [${tag}]`;\\n  }\\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\\n    return base;\\n  return ctx.stylize(base\\x2C StringPrototypeToLowerCase(type));\\n}\\n\\nfunction getClassBase(value\\x2C constructor\\x2C tag) {\\n  const hasName = ObjectPrototypeHasOwnProperty(value\\x2C 'name');\\n  const name = (hasName && value.name) || '(anonymous)';\\n  let base = `class ${name}`;\\n  if (constructor !== 'Function' && constructor !== null) {\\n    base += ` [${constructor}]`;\\n  }\\n  if (tag !== '' && constructor !== tag) {\\n    base += ` [${tag}]`;\\n  }\\n  if (constructor !== null) {\\n    const superName = ObjectGetPrototypeOf(value).name;\\n    if (superName) {\\n      base += ` extends ${superName}`;\\n    }\\n  } else {\\n    base += ' extends [null prototype]';\\n  }\\n  return `[${base}]`;\\n}\\n\\nfunction getFunctionBase(value\\x2C constructor\\x2C tag) {\\n  const stringified = FunctionPrototypeToString(value);\\n  if (stringified.startsWith('class') && stringified.endsWith('}')) {\\n    const slice = stringified.slice(5\\x2C -1);\\n    const bracketIndex = slice.indexOf('{');\\n    if (bracketIndex !== -1 &&\\n        (!slice.slice(0\\x2C bracketIndex).includes('(') ||\\n          // Slow path to guarantee that it's indeed a class.\\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\\n      return getClassBase(value\\x2C constructor\\x2C tag);\\n    }\\n  }\\n  let type = 'Function';\\n  if (isGeneratorFunction(value)) {\\n    type = `Generator${type}`;\\n  }\\n  if (isAsyncFunction(value)) {\\n    type = `Async${type}`;\\n  }\\n  let base = `[${type}`;\\n  if (constructor === null) {\\n    base += ' (null prototype)';\\n  }\\n  if (value.name === '') {\\n    base += ' (anonymous)';\\n  } else {\\n    base += `: ${value.name}`;\\n  }\\n  base += ']';\\n  if (constructor !== type && constructor !== null) {\\n    base += ` ${constructor}`;\\n  }\\n  if (tag !== '' && constructor !== tag) {\\n    base += ` [${tag}]`;\\n  }\\n  return base;\\n}\\n\\nfunction identicalSequenceRange(a\\x2C b) {\\n  for (let i = 0; i < a.length - 3; i++) {\\n    // Find the first entry of b that matches the current entry of a.\\n    const pos = b.indexOf(a[i]);\\n    if (pos !== -1) {\\n      const rest = b.length - pos;\\n      if (rest > 3) {\\n        let len = 1;\\n        const maxLen = MathMin(a.length - i\\x2C rest);\\n        // Count the number of consecutive entries.\\n        while (maxLen > len && a[i + len] === b[pos + len]) {\\n          len++;\\n        }\\n        if (len > 3) {\\n          return { len\\x2C offset: i };\\n        }\\n      }\\n    }\\n  }\\n\\n  return { len: 0\\x2C offset: 0 };\\n}\\n\\nfunction getStackString(error) {\\n  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);\\n}\\n\\nfunction getStackFrames(ctx\\x2C err\\x2C stack) {\\n  const frames = stack.split('\\\\n');\\n\\n  // Remove stack frames identical to frames in cause.\\n  if (err.cause && isError(err.cause)) {\\n    const causeStack = getStackString(err.cause);\\n    const causeStackStart = causeStack.indexOf('\\\\n    at');\\n    if (causeStackStart !== -1) {\\n      const causeFrames = causeStack.slice(causeStackStart + 1).split('\\\\n');\\n      const { len\\x2C offset } = identicalSequenceRange(frames\\x2C causeFrames);\\n      if (len > 0) {\\n        const skipped = len - 2;\\n        const msg = `    ... ${skipped} lines matching cause stack trace ...`;\\n        frames.splice(offset + 1\\x2C skipped\\x2C ctx.stylize(msg\\x2C 'undefined'));\\n      }\\n    }\\n  }\\n  return frames;\\n}\\n\\nfunction improveStack(stack\\x2C constructor\\x2C name\\x2C tag) {\\n  // A stack trace may contain arbitrary data. Only manipulate the output\\n  // for \"regular errors\" (errors that \"look normal\") for now.\\n  let len = name.length;\\n\\n  if (constructor === null ||\\n      (name.endsWith('Error') &&\\n      stack.startsWith(name) &&\\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\\\n'))) {\\n    let fallback = 'Error';\\n    if (constructor === null) {\\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\\\]()-]+)(?::|\\\\n {4}at)/) ||\\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\\n      fallback = (start && start[1]) ||" at the file end is broken
(node:3100) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:3100) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.3/tick-processor.log is broken
"tick,0x3fd6439d40,57367994,0,0x0,3,0x0,0x3fd13af2c9," at the file end is broken
(node:3156) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:3156) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.3/tick-processor.log is broken
"script-source,43,node:internal/abort_controller,'use strict';\\n\\n// Modeled very closely on the AbortController implementation\\n// in https://github.com/mysticatea/abort-controller (MIT license)\\n\\nconst {\\n  ObjectAssign\\x2C\\n  ObjectDefineProperties\\x2C\\n  ObjectSetPrototypeOf\\x2C\\n  ObjectDefineProperty\\x2C\\n  SafeFinalizationRegistry\\x2C\\n  SafeSet\\x2C\\n  Symbol\\x2C\\n  SymbolToStringTag\\x2C\\n  WeakRef\\x2C\\n} = primordials;\\n\\nconst {\\n  defineEventHandler\\x2C\\n  EventTarget\\x2C\\n  Event\\x2C\\n  kTrustEvent\\x2C\\n  kNewListener\\x2C\\n  kRemoveListener\\x2C\\n} = require('internal/event_target');\\nconst {\\n  customInspectSymbol\\x2C\\n} = require('internal/util');\\nconst { inspect } = require('internal/util/inspect');\\nconst {\\n  codes: {\\n    ERR_ILLEGAL_CONSTRUCTOR\\x2C\\n    ERR_INVALID_THIS\\x2C\\n  }\\n} = require('internal/errors');\\n\\nconst {\\n  validateUint32\\x2C\\n} = require('internal/validators');\\n\\nconst {\\n  DOMException\\x2C\\n} = internalBinding('messaging');\\n\\nconst {\\n  clearTimeout\\x2C\\n  setTimeout\\x2C\\n} = require('timers');\\n\\nconst {\\n  messaging_deserialize_symbol: kDeserialize\\x2C\\n  messaging_transfer_symbol: kTransfer\\x2C\\n  messaging_transfer_list_symbol: kTransferList\\n} = internalBinding('symbols');\\n\\nlet _MessageChannel;\\nlet makeTransferable;\\n\\n// Loading the MessageChannel and makeTransferable have to be done lazily\\n// because otherwise we'll end up with a require cycle that ends up with\\n// an incomplete initialization of abort_controller.\\n\\nfunction lazyMessageChannel() {\\n  _MessageChannel ??= require('internal/worker/io').MessageChannel;\\n  return new _MessageChannel();\\n}\\n\\nfunction lazyMakeTransferable(obj) {\\n  makeTransferable ??=\\n    require('internal/worker/js_transferable').makeTransferable;\\n  return makeTransferable(obj);\\n}\\n\\nconst clearTimeoutRegistry = new SafeFinalizationRegistry(clearTimeout);\\nconst timeOutSignals = new SafeSet();\\n\\nconst kAborted = Symbol('kAborted');\\nconst kReason = Symbol('kReason');\\nconst kCloneData = Symbol('kCloneData');\\nconst kTimeout = Symbol('kTimeout');\\n\\nfunction customInspect(self\\x2C obj\\x2C depth\\x2C options) {\\n  if (depth < 0)\\n    return self;\\n\\n  const opts = ObjectAssign({}\\x2C options\\x2C {\\n    depth: options.depth === null ? null : options.depth - 1\\n  });\\n\\n  return `${self.constructor.name} ${inspect(obj\\x2C opts)}`;\\n}\\n\\nfunction validateAbortSignal(obj) {\\n  if (obj?.[kAborted] === undefined)\\n    throw new ERR_INVALID_THIS('AbortSignal');\\n}\\n\\n// Because the AbortSignal timeout cannot be canceled\\x2C we don't want the\\n// presence of the timer alone to keep the AbortSignal from being garbage\\n// collected if it otherwise no longer accessible. We also don't want the\\n// timer to keep the Node.js process open on it's own. Therefore\\x2C we wrap\\n// the AbortSignal in a WeakRef and have the setTimeout callback close\\n// over the WeakRef rather than directly over the AbortSignal\\x2C and we unref\\n// the created timer object. Separately\\x2C we add the signal to a\\n// FinalizerRegistry that will clear the timeout when the signal is gc'd.\\nfunction setWeakAbortSignalTimeout(weakRef\\x2C delay) {\\n  const timeout = setTimeout(() => {\\n    const signal = weakRef.deref();\\n    if (signal !== undefined) {\\n      timeOutSignals.delete(signal);\\n      abortSignal(\\n        signal\\x2C\\n        new DOMException(\\n          'The operation was aborted due to timeout'\\x2C\\n          'TimeoutError'));\\n    }\\n  }\\x2C delay);\\n  timeout.unref();\\n  return timeout;\\n}\\n\\nclass AbortSignal extends EventTarget {\\n  constructor() {\\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\\n  }\\n\\n  /**\\n   * @type {boolean}\\n   */\\n  get aborted() {\\n    validateAbortSignal(this);\\n    return !!this[kAborted];\\n  }\\n\\n  /**\\n   * @type {any}\\n   */\\n  get reason() {\\n    validateAbortSignal(this);\\n    return this[kReason];\\n  }\\n\\n  [customInspectSymbol](depth\\x2C options) {\\n    return customInspect(this\\x2C {\\n      aborted: this.aborted\\n    }\\x2C depth\\x2C options);\\n  }\\n\\n  /**\\n   * @param {any} reason\\n   * @returns {AbortSignal}\\n   */\\n  static abort(reason) {\\n    return createAbortSignal(true\\x2C reason);\\n  }\\n\\n  /**\\n   * @param {number} delay\\n   * @returns {AbortSignal}\\n   */\\n  static timeout(delay) {\\n    validateUint32(delay\\x2C 'delay'\\x2C true);\\n    const signal = createAbortSignal();\\n    signal[kTimeout] = true;\\n    clearTimeoutRegistry.register(\\n      signal\\x2C\\n      setWeakAbortSignalTimeout(new WeakRef(signal)\\x2C delay));\\n    return signal;\\n  }\\n\\n  [kNewListener](size\\x2C type\\x2C listener\\x2C once\\x2C capture\\x2C passive\\x2C weak) {\\n    super[kNewListener](size\\x2C type\\x2C listener\\x2C once\\x2C capture\\x2C passive\\x2C weak);\\n    if (this[kTimeout] &&\\n        type === 'abort' &&\\n        !this.aborted &&\\n" at the file end is broken
(node:3216) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
Command: out/Release/node /root/rpmbuild/BUILD/node-v16.14.2/test/tick-processor/test-tick-processor-preprocess-flag.js
--- TIMEOUT ---
=== release test-tick-processor-unknown ===                           
Path: tick-processor/test-tick-processor-unknown
(node:3280) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
(node:3294) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:3294) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.4/tick-processor.log is broken
"code-creation,Builtin,2,4847427,0x3fee071b60,1040,S" at the file end is broken
(node:3351) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:3351) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.4/tick-processor.log is broken
"script-source,9,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\\n// modules. In contrast\\x2C user land modules are loaded using\\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\\n// lib/internal/modules/esm/* (ES Modules).\\n//\\n// This file is compiled and run by node.cc before bootstrap/node.js\\n// was called\\x2C therefore the loaders are bootstrapped before we start to\\n// actually bootstrap Node.js. It creates the following objects:\\n//\\n// C++ binding loaders:\\n// - process.binding(): the legacy C++ binding loader\\x2C accessible from user land\\n//   because it is an object attached to the global process object.\\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\\n//   about the stability of these bindings\\x2C but still have to take care of\\n//   compatibility issues caused by them from time to time.\\n// - process._linkedBinding(): intended to be used by embedders to add\\n//   additional C++ bindings in their applications. These C++ bindings\\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\\n//   NM_F_LINKED.\\n// - internalBinding(): the private internal C++ binding loader\\x2C inaccessible\\n//   from user land unless through `require('internal/test/binding')`.\\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\\n//   and have their nm_flags set to NM_F_INTERNAL.\\n//\\n// Internal JavaScript module loader:\\n// - NativeModule: a minimal module system used to load the JavaScript core\\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\\x2C\\n//   so they can be loaded faster without the cost of I/O. This class makes the\\n//   lib/internal/*\\x2C deps/internal/* modules and internalBinding() available by\\n//   default to core modules\\x2C and lets the core modules require itself via\\n//   require('internal/bootstrap/loaders') even when this file is not written in\\n//   CommonJS style.\\n//\\n// Other objects:\\n// - process.moduleLoadList: an array recording the bindings and the modules\\n//   loaded in the process and the order in which they are loaded.\\n\\n'use strict';\\n\\n// This file is compiled as if it's wrapped in a function with arguments\\n// passed by node::RunBootstrapping()\\n/* global process\\x2C getLinkedBinding\\x2C getInternalBinding\\x2C primordials */\\n\\nconst {\\n  ArrayPrototypeMap\\x2C\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypeSlice\\x2C\\n  Error\\x2C\\n  ObjectCreate\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  ReflectGet\\x2C\\n  SafeMap\\x2C\\n  SafeSet\\x2C\\n  String\\x2C\\n  StringPrototypeStartsWith\\x2C\\n  TypeError\\x2C\\n} = primordials;\\n\\n// Set up process.moduleLoadList.\\nconst moduleLoadList = [];\\nObjectDefineProperty(process\\x2C 'moduleLoadList'\\x2C {\\n  value: moduleLoadList\\x2C\\n  configurable: true\\x2C\\n  enumerable: true\\x2C\\n  writable: false\\n});\\n\\n\\n// internalBindingAllowlist contains the name of internalBinding modules\\n// that are allowed for access via process.binding()... This is used\\n// to provide a transition path for modules that are being moved over to\\n// internalBinding.\\nconst internalBindingAllowlist = new SafeSet([\\n  'async_wrap'\\x2C\\n  'buffer'\\x2C\\n  'cares_wrap'\\x2C\\n  'config'\\x2C\\n  'constants'\\x2C\\n  'contextify'\\x2C\\n  'crypto'\\x2C\\n  'fs'\\x2C\\n  'fs_event_wrap'\\x2C\\n  'http_parser'\\x2C\\n  'icu'\\x2C\\n  'inspector'\\x2C\\n  'js_stream'\\x2C\\n  'natives'\\x2C\\n  'os'\\x2C\\n  'pipe_wrap'\\x2C\\n  'process_wrap'\\x2C\\n  'signal_wrap'\\x2C\\n  'spawn_sync'\\x2C\\n  'stream_wrap'\\x2C\\n  'tcp_wrap'\\x2C\\n  'tls_wrap'\\x2C\\n  'tty_wrap'\\x2C\\n  'udp_wrap'\\x2C\\n  'url'\\x2C\\n  'util'\\x2C\\n  'uv'\\x2C\\n  'v8'\\" at the file end is broken
(node:3407) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:3407) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.4/tick-processor.log is broken
"script-source,20,node:internal/util/inspect,'use strict';\\n\\nconst {\\n  Array\\x2C\\n  ArrayIsArray\\x2C\\n  ArrayPrototypeFilter\\x2C\\n  ArrayPrototypeForEach\\x2C\\n  ArrayPrototypePop\\x2C\\n  ArrayPrototypePush\\x2C\\n  ArrayPrototypePushApply\\x2C\\n  ArrayPrototypeSort\\x2C\\n  ArrayPrototypeUnshift\\x2C\\n  BigIntPrototypeValueOf\\x2C\\n  BooleanPrototypeValueOf\\x2C\\n  DatePrototypeGetTime\\x2C\\n  DatePrototypeToISOString\\x2C\\n  DatePrototypeToString\\x2C\\n  ErrorPrototypeToString\\x2C\\n  FunctionPrototypeCall\\x2C\\n  FunctionPrototypeToString\\x2C\\n  JSONStringify\\x2C\\n  MapPrototypeGetSize\\x2C\\n  MapPrototypeEntries\\x2C\\n  MathFloor\\x2C\\n  MathMax\\x2C\\n  MathMin\\x2C\\n  MathRound\\x2C\\n  MathSqrt\\x2C\\n  MathTrunc\\x2C\\n  Number\\x2C\\n  NumberIsFinite\\x2C\\n  NumberIsNaN\\x2C\\n  NumberParseFloat\\x2C\\n  NumberParseInt\\x2C\\n  NumberPrototypeValueOf\\x2C\\n  Object\\x2C\\n  ObjectAssign\\x2C\\n  ObjectCreate\\x2C\\n  ObjectDefineProperty\\x2C\\n  ObjectGetOwnPropertyDescriptor\\x2C\\n  ObjectGetOwnPropertyNames\\x2C\\n  ObjectGetOwnPropertySymbols\\x2C\\n  ObjectGetPrototypeOf\\x2C\\n  ObjectIs\\x2C\\n  ObjectKeys\\x2C\\n  ObjectPrototypeHasOwnProperty\\x2C\\n  ObjectPrototypePropertyIsEnumerable\\x2C\\n  ObjectSeal\\x2C\\n  ObjectSetPrototypeOf\\x2C\\n  ReflectOwnKeys\\x2C\\n  RegExp\\x2C\\n  RegExpPrototypeTest\\x2C\\n  RegExpPrototypeToString\\x2C\\n  SafeStringIterator\\x2C\\n  SafeMap\\x2C\\n  SafeSet\\x2C\\n  SetPrototypeGetSize\\x2C\\n  SetPrototypeValues\\x2C\\n  String\\x2C\\n  StringPrototypeCharCodeAt\\x2C\\n  StringPrototypeCodePointAt\\x2C\\n  StringPrototypeIncludes\\x2C\\n  StringPrototypeNormalize\\x2C\\n  StringPrototypePadEnd\\x2C\\n  StringPrototypePadStart\\x2C\\n  StringPrototypeRepeat\\x2C\\n  StringPrototypeReplace\\x2C\\n  StringPrototypeSlice\\x2C\\n  StringPrototypeSplit\\x2C\\n  StringPrototypeToLowerCase\\x2C\\n  StringPrototypeTrim\\x2C\\n  StringPrototypeValueOf\\x2C\\n  SymbolPrototypeToString\\x2C\\n  SymbolPrototypeValueOf\\x2C\\n  SymbolIterator\\x2C\\n  SymbolToStringTag\\x2C\\n  TypedArrayPrototypeGetLength\\x2C\\n  TypedArrayPrototypeGetSymbolToStringTag\\x2C\\n  Uint8Array\\x2C\\n  globalThis\\x2C\\n  uncurryThis\\x2C\\n} = primordials;\\n\\nconst {\\n  getOwnNonIndexProperties\\x2C\\n  getPromiseDetails\\x2C\\n  getProxyDetails\\x2C\\n  kPending\\x2C\\n  kRejected\\x2C\\n  previewEntries\\x2C\\n  getConstructorName: internalGetConstructorName\\x2C\\n  getExternalValue\\x2C\\n  propertyFilter: {\\n    ALL_PROPERTIES\\x2C\\n    ONLY_ENUMERABLE\\n  }\\n} = internalBinding('util');\\n\\nconst {\\n  customInspectSymbol\\x2C\\n  isError\\x2C\\n  join\\x2C\\n  removeColors\\n} = require('internal/util');\\n\\nconst {\\n  codes: {\\n    ERR_INVALID_ARG_TYPE\\n  }\\x2C\\n  isStackOverflowError\\n} = require('internal/errors');\\n\\nconst {\\n  isAsyncFunction\\x2C\\n  isGeneratorFunction\\x2C\\n  isAnyArrayBuffer\\x2C\\n  isArrayBuffer\\x2C\\n  isArgumentsObject\\x2C\\n  isBoxedPrimitive\\x2C\\n  isDataView\\x2C\\n  isExternal\\x2C\\n  isMap\\x2C\\n  isMapIterator\\x2C\\n  isModuleNamespaceObject\\x2C\\n  isNativeError\\x2C\\n  isPromise\\x2C\\n  isSet\\x2C\\n  isSetIterator\\x2C\\n  isWeakMap\\x2C\\n  isWeakSet\\x2C\\n  isRegExp\\x2C\\n  isDate\\x2C\\n  isTypedArray\\x2C\\n  isStringObject\\x2C\\n  isNumberObject\\x2C\\n  isBooleanObject\\x2C\\n  isBigIntObject\\x2C\\n} = require('internal/util/types');\\n\\nconst assert = require('internal/assert');\\n\\nconst { NativeModule } = require('internal/bootstrap/loaders');\\nconst {\\n  validateObject\\x2C\\n  validateString\\x2C\\n} = require('internal/validators');\\n\\nlet hexSlice;\\n\\nconst builtInObjects = new SafeSet(\\n  ArrayPrototypeFilter(\\n    ObjectGetOwnPropertyNames(globalThis)\\x2C\\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/\\x2C e)\\n  )\\n);\\n\\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\\n\\n// These options must stay in sync with `getUserOptions`. So if any option will\\n// be added or removed\\x2C `getUserOptions` must also be updated accordingly.\\nconst inspectDefaultOptions = ObjectSeal({\\n  showHidden: false\\x2C\\n  depth: 2\\x2C\\n  colors: false\\x2C\\n  customInspect: true\\x2C\\n  showProxy: false\\x2C\\n  maxArrayLength: 100\\x2C\\n  maxStringLength: 10000\\x2C\\n  breakLength: 80\\x2C\\n  compact: 3\\x2C\\n  sorted: false\\x2C\\n  getters: false\\x2C\\n  numericSeparator: false\\x2C\\n});\\n\\nconst kObjectType = 0;\\nconst kArrayType = 1;\\nconst kArrayExtrasType = 2;\\n\\n/* eslint-disable no-control-regex */\\nconst strEscapeSequencesRegExp = /[\\\\x00-\\\\x1f\\\\x27\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/;\\nconst strEscapeSequencesReplacer = /[\\\\x00-\\\\x1f\\\\x27\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/g;\\nconst strEscapeSequencesRegExpSingle = /[\\\\x00-\\\\x1f\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/;\\nconst strEscapeSequencesReplacerSingle = /[\\\\x00-\\\\x1f\\\\x5c\\\\x7f-\\\\x9f]|[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|(?<![\\\\ud800-\\\\udbff])[\\\\udc00-\\\\udfff]/g;\\n/* eslint-enable no-control-regex */\\n\\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\\n\\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\\\\\(]+ \\\\(|)node:(.+):\\\\d+:\\\\d+\\\\)?$/;\\nconst nodeModulesRegExp = /[/\\\\\\\\]node_modules[/\\\\\\\\](.+?)(?=[/\\\\\\\\])/g;\\n\\nconst classRegExp = /^(\\\\s+[^(]*?)\\\\s*{/;\\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\\nconst stripCommentsRegExp = /(\\\\/\\\\/.*?\\\\n)|(\\\\/\\\\*(.|\\\\n)*?\\\\*\\\\/)/g;\\n\\nconst kMinLineLength = 16;\\n\\n// Constants to map the iterator state.\\nconst kWeak = 0;\\nconst kIterator = 1;\\nconst kMapEntries = 2;\\n\\n// Escaped control characters (plus the single quote and the backslash). Use\\n// empty strings to fill up unused entries.\\nconst meta = [\\n  '\\\\\\\\x00'\\x2C '\\\\\\\\x01'\\x2C '\\\\\\\\x02'\\x2C '\\\\\\\\x03'\\x2C '\\\\\\\\x04'\\x2C '\\\\\\\\x05'\\x2C '\\\\\\\\x06'\\x2C '\\\\\\\\x07'\\x2C // x07\\n  '\\\\\\\\b'\\x2C '\\\\\\\\t'\\x2C '\\\\\\\\n'\\x2C '\\\\\\\\x0B'\\x2C '\\\\\\\\f'\\x2C '\\\\\\\\r'\\x2C '\\\\\\\\x0E'\\x2C '\\\\\\\\x0F'\\x2C           // x0F\\n  '\\\\\\\\x10'\\x2C '\\\\\\\\x11'\\x2C '\\\\\\\\x12'\\x2C '\\\\\\\\x13'\\x2C '\\\\\\\\x14'\\x2C '\\\\\\\\x15'\\x2C '\\\\\\\\x16'\\x2C '\\\\\\\\x17'\\x2C // x17\\n  '\\\\\\\\x18'\\x2C '\\\\\\\\x19'\\x2C '\\\\\\\\x1A'\\x2C '\\\\\\\\x1B'\\x2C '\\\\\\\\x1C'\\x2C '\\\\\\\\x1D'\\x2C '\\\\\\\\x1E'\\x2C '\\\\\\\\x1F'\\x2C // x1F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C \"\\\\\\\\'\"\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C      // x2F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x3F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x4F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C '\\\\\\\\\\\\\\\\'\\x2C ''\\x2C ''\\x2C ''\\x2C     // x5F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C         // x6F\\n  ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C ''\\x2C '\\\\\\\\x7F'\\x2C    // x7F\\n  '\\\\\\\\x80'\\x2C '\\\\\\\\x81'\\x2C '\\\\\\\\x82'\\x2C '\\\\\\\\x83'\\x2C '\\\\\\\\x84'\\x2C '\\\\\\\\x85'\\x2C '\\\\\\\\x86'\\x2C '\\\\\\\\x87'\\x2C // x87\\n  '\\\\\\\\x88'\\x2C '\\\\\\\\x89'\\x2C '\\\\\\\\x8A'\\x2C '\\\\\\\\x8B'\\x2C '\\\\\\\\x8C'\\x2C '\\\\\\\\x8D'\\x2C '\\\\\\\\x8E'\\x2C '\\\\\\\\x8F'\\x2C // x8F\\n  '\\\\\\\\x90'\\x2C '\\\\\\\\x91'\\x2C '\\\\\\\\x92'\\x2C '\\\\\\\\x93'\\x2C '\\\\\\\\x94'\\x2C '\\\\\\\\x95'\\x2C '\\\\\\\\x96'\\x2C '\\\\\\\\x97'\\x2C // x97\\n  '\\\\\\\\x98'\\x2C '\\\\\\\\x99'\\x2C '\\\\\\\\x9A'\\x2C '\\\\\\\\x9B'\\x2C '\\\\\\\\x9C'\\x2C '\\\\\\\\x9D'\\x2C '\\\\\\\\x9E'\\x2C '\\\\\\\\x9F'\\x2C // x9F\\n];\\n\\n// Regex used for ansi escape code splitting\\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\\n// License: MIT\\x2C authors: @sindresorhus\\x2C Qix-\\x2C arjunmehta and LitoMore\\n// Matches all ansi escape code sequences in a string\\nconst ansiPattern = '[\\\\\\\\u001B\\\\\\\\u009B][[\\\\\\\\]()#;?]*' +\\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\\\\\d\\\\\\\\/#&.:=?%@~_]+)*' +\\n  '|[a-zA-Z\\\\\\\\d]+(?:;[-a-zA-Z\\\\\\\\d\\\\\\\\/#&.:=?%@~_]*)*)?\\\\\\\\u0007)' +\\n  '|(?:(?:\\\\\\\\d{1\\x2C4}(?:;\\\\\\\\d{0\\x2C4})*)?[\\\\\\\\dA-PR-TZcf-ntqry=><~]))';\\nconst ansi = new RegExp(ansiPattern\\x2C 'g');\\n\\nlet getStringWidth;\\n\\nfunction getUserOptions(ctx\\x2C isCrossContext) {\\n  const ret = {\\n    stylize: ctx.stylize\\x2C\\n    showHidden: ctx.showHidden\\x2C\\n    depth: ctx.depth\\x2C\\n    colors: ctx.colors\\x2C\\n    customInspect: ctx.customInspect\\x2C\\n    showProxy: ctx.showProxy\\x2C\\n    maxArrayLength: ctx.maxArrayLength\\x2C\\n    maxStringLength: ctx.maxStringLength\\x2C\\n    breakLength: ctx.breakLength\\x2C\\n    compact: ctx.compact\\x2C\\n    sorted: ctx.sorted\\x2C\\n    getters: ctx.getters\\x2C\\n    numericSeparator: ctx.numericSeparator\\x2C\\n    ...ctx.userOptions\\n  };\\n\\n  // Typically\\x2C the target value will be an instance of `Object`. If that is\\n  // *not* the case\\x2C the object may come from another vm.Context\\x2C and we want\\n  // to avoid passing it objects from this Context in that case\\x2C so we remove\\n  // the prototype from the returned object itself + the `stylize()` function\\x2C\\n  // and remove all other non-primitives\\x2C including non-primitive user options.\\n  if (isCrossContext) {\\n    ObjectSetPrototypeOf(ret\\x2C null);\\n    for (const key of ObjectKeys(ret)) {\\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\\n          ret[key] !== null) {\\n        delete ret[key];\\n      }\\n    }\\n    ret.stylize = ObjectSetPrototypeOf((value\\x2C flavour) => {\\n      let stylized;\\n      try {\\n        stylized = `${ctx.stylize(value\\x2C flavour)}`;\\n      } catch {\\n        // Continue regardless of error.\\n      }\\n\\n      if (typeof stylized !== 'string') return value;\\n      // `stylized` is a string as it should be\\x2C which is safe to pass along.\\n      return stylized;\\n    }\\x2C null);\\n  }\\n\\n  return ret;\\n}\\n\\n/**\\n * Echos the value of any input. Tries to print the value out\\n * in the best way possible given the different types.\\n *\\n * @param {any} value The value to print out.\\n * @param {object} opts Optional options object that alters the output.\\n */\\n/* Legacy: value\\x2C showHidden\\x2C depth\\x2C colors */\\nfunction inspect(value\\x2C opts) {\\n  // Default options\\n  const ctx = {\\n    budget: {}\\x2C\\n    indentationLvl: 0\\x2C\\n    seen: []\\x2C\\n    currentDepth: 0\\x2C\\n    stylize: stylizeNoColor\\x2C\\n    showHidden: inspectDefaultOptions.showHidden\\x2C\\n    depth: inspectDefaultOptions.depth\\x2C\\n    colors: inspectDefaultOptions.colors\\x2C\\n    customInspect: inspectDefaultOptions.customInspect\\x2C\\n    showProxy: inspectDefaultOptions.showProxy\\x2C\\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\\x2C\\n    maxStringLength: inspectDefaultOptions.maxStringLength\\x2C\\n    breakLength: inspectDefaultOptions.breakLength\\x2C\\n    compact: inspectDefaultOptions.compact\\x2C\\n    sorted: inspectDefaultOptions.sorted\\x2C\\n    getters: inspectDefaultOptions.getters\\x2C\\n    numericSeparator: inspectDefaultOptions.numericSeparator\\x2C\\n  };\\n  if (arguments.length > 1) {\\n    // Legacy...\\n    if (arguments.length > 2) {\\n      if (arguments[2] !== undefined) {\\n        ctx.depth = arguments[2];\\n      }\\n      if (arguments.length > 3 && arguments[3] !== undefined) {\\n        ctx.colors = arguments[3];\\n      }\\n    }\\n    // Set user-specified options\\n    if (typeof opts === 'boolean') {\\n      ctx.showHidden = opts;\\n    } else if (opts) {\\n      const optKeys = ObjectKeys(opts);\\n      for (let i = 0; i < optKeys.length; ++i) {\\n        const key = optKeys[i];\\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\\n        // this function public or add a new API with a similar or better\\n        // functionality.\\n        if (\\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\\x2C key) ||\\n          key === 'stylize') {\\n          ctx[key] = opts[key];\\n        } else if (ctx.userOptions === undefined) {\\n          // This is required to pass through the actual user input.\\n          ctx.userOptions = opts;\\n        }\\n      }\\n    }\\n  }\\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\\n  return formatValue(ctx\\x2C value\\x2C 0);\\n}\\ninspect.custom = customInspectSymbol;\\n\\nObjectDefineProperty(inspect\\x2C 'defaultOptions'\\x2C {\\n  get() {\\n    return inspectDefaultOptions;\\n  }\\x2C\\n  set(options) {\\n    validateObject(options\\x2C 'options');\\n    return ObjectAssign(inspectDefaultOptions\\x2C o" at the file end is broken
(node:3463) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
(node:3463) [BROKEN_PROFILE_FILE] Warning: Profile file /root/rpmbuild/BUILD/node-v16.14.2/test/.tmp.4/tick-processor.log is broken
"tick,0x3fee94ec8c,73148604,1,0x3fede51550,2,0x0,0x3fd404efdc,0x" at the file end is broken
(node:3519) ExperimentalWarning: VM Modules is an experimental feature. This feature could change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
dropping: overflow
Command: out/Release/node /root/rpmbuild/BUILD/node-v16.14.2/test/tick-processor/test-tick-processor-unknown.js
--- TIMEOUT ---
[08:09|% 100|+   1|-   4]: Done                               

```



